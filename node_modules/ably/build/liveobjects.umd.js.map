{
  "version": 3,
  "sources": ["../src/plugins/liveobjects/index.ts", "../src/plugins/liveobjects/objectid.ts", "../src/plugins/liveobjects/objectmessage.ts", "../src/plugins/liveobjects/livecountervaluetype.ts", "../node_modules/dequal/dist/index.mjs", "../src/plugins/liveobjects/constants.ts", "../src/plugins/liveobjects/liveobject.ts", "../src/plugins/liveobjects/defaults.ts", "../src/plugins/liveobjects/objectspool.ts", "../src/plugins/liveobjects/batchcontext.ts", "../src/plugins/liveobjects/rootbatchcontext.ts", "../src/plugins/liveobjects/instance.ts", "../src/plugins/liveobjects/pathobject.ts", "../src/plugins/liveobjects/pathobjectsubscriptionregister.ts", "../src/plugins/liveobjects/syncobjectsdatapool.ts", "../src/plugins/liveobjects/realtimeobject.ts", "../src/plugins/liveobjects/livecounter.ts", "../src/plugins/liveobjects/livemap.ts", "../src/plugins/liveobjects/livemapvaluetype.ts"],
  "sourcesContent": ["import { LiveCounterValueType } from './livecountervaluetype';\nimport { LiveMapValueType } from './livemapvaluetype';\nimport { ObjectMessage, WireObjectMessage } from './objectmessage';\nimport { RealtimeObject } from './realtimeobject';\n\nexport {\n  LiveCounterValueType as LiveCounter,\n  LiveMapValueType as LiveMap,\n  ObjectMessage,\n  RealtimeObject,\n  WireObjectMessage,\n};\n\n/**\n * The named LiveObjects plugin object export to be passed to the Ably client.\n */\nexport const LiveObjects = {\n  LiveCounter: LiveCounterValueType,\n  LiveMap: LiveMapValueType,\n  ObjectMessage,\n  RealtimeObject,\n  WireObjectMessage,\n};\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type Platform from 'common/platform';\n\nexport type LiveObjectType = 'map' | 'counter';\n\n/**\n * Represents a parsed object id.\n *\n * @internal\n */\nexport class ObjectId {\n  private constructor(\n    readonly type: LiveObjectType,\n    readonly hash: string,\n    readonly msTimestamp: number,\n  ) {}\n\n  static fromInitialValue(\n    platform: typeof Platform,\n    objectType: LiveObjectType,\n    initialValue: string,\n    nonce: string,\n    msTimestamp: number,\n  ): ObjectId {\n    const valueForHashBuffer = platform.BufferUtils.concat([\n      platform.BufferUtils.utf8Encode(initialValue),\n      platform.BufferUtils.utf8Encode(':'),\n      platform.BufferUtils.utf8Encode(nonce),\n    ]);\n    const hashBuffer = platform.BufferUtils.sha256(valueForHashBuffer);\n    const hash = platform.BufferUtils.base64UrlEncode(hashBuffer);\n\n    return new ObjectId(objectType, hash, msTimestamp);\n  }\n\n  /**\n   * Create ObjectId instance from hashed object id string.\n   */\n  static fromString(client: BaseClient, objectId: string | null | undefined): ObjectId {\n    if (client.Utils.isNil(objectId)) {\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\n    }\n\n    // RTO6b1\n    const [type, rest] = objectId.split(':');\n    if (!type || !rest) {\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\n    }\n\n    if (!['map', 'counter'].includes(type)) {\n      throw new client.ErrorInfo(`Invalid object type in object id: ${objectId}`, 92000, 500);\n    }\n\n    const [hash, msTimestamp] = rest.split('@');\n    if (!hash || !msTimestamp) {\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\n    }\n\n    if (!Number.isInteger(Number.parseInt(msTimestamp))) {\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\n    }\n\n    return new ObjectId(type as LiveObjectType, hash, Number.parseInt(msTimestamp));\n  }\n\n  toString(): string {\n    return `${this.type}:${this.hash}@${this.msTimestamp}`;\n  }\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type RealtimeChannel from 'common/lib/client/realtimechannel';\nimport type { MessageEncoding } from 'common/lib/types/basemessage';\nimport type * as Utils from 'common/lib/util/utils';\nimport type * as ObjectsApi from '../../../liveobjects';\n\nconst operationActions: ObjectsApi.ObjectOperationAction[] = [\n  'map.create',\n  'map.set',\n  'map.remove',\n  'counter.create',\n  'counter.inc',\n  'object.delete',\n];\n\nconst mapSemantics: ObjectsApi.ObjectsMapSemantics[] = ['lww'];\n\nexport type EncodeObjectDataFunction = (data: ObjectData | WireObjectData) => WireObjectData;\n\n/** @spec OOP2 */\nexport enum ObjectOperationAction {\n  MAP_CREATE = 0,\n  MAP_SET = 1,\n  MAP_REMOVE = 2,\n  COUNTER_CREATE = 3,\n  COUNTER_INC = 4,\n  OBJECT_DELETE = 5,\n}\n\n/** @spec OMP2 */\nexport enum ObjectsMapSemantics {\n  LWW = 0,\n}\n\n/**\n * An ObjectData represents a value in an object on a channel decoded from {@link WireObjectData}.\n * @spec OD1\n */\nexport interface ObjectData {\n  /** A reference to another object, used to support composable object structures. */\n  objectId?: string; // OD2a\n  /** A decoded leaf value from {@link WireObjectData}. */\n  value?: ObjectsApi.Primitive;\n}\n\n/**\n * A WireObjectData represents a value in an object on a channel received from the server.\n * @spec OD1\n */\nexport interface WireObjectData {\n  /** A reference to another object, used to support composable object structures. */\n  objectId?: string; // OD2a\n\n  /** A primitive boolean leaf value in the object graph. Only one value field can be set. */\n  boolean?: boolean; // OD2c\n  /** A primitive binary leaf value in the object graph. Only one value field can be set. Represented as a Base64-encoded string in JSON protocol */\n  bytes?: Buffer | ArrayBuffer | string; // OD2d\n  /** A primitive number leaf value in the object graph. Only one value field can be set. */\n  number?: number; // OD2e\n  /** A primitive string leaf value in the object graph. Only one value field can be set. */\n  string?: string; // OD2f\n  /** A primitive JSON-encoded string leaf value in the object graph. Only one value field can be set. */\n  json?: string; // OD2g\n}\n\n/**\n * An ObjectsMapOp describes an operation to be applied to a Map object.\n * @spec OMO1\n */\nexport interface ObjectsMapOp<TData> {\n  /** The key of the map entry to which the operation should be applied. */\n  key: string; // OMO2a\n  /** The data that the map entry should contain if the operation is a MAP_SET operation. */\n  data?: TData; // OMO2b\n}\n\n/**\n * An ObjectsCounterOp describes an operation to be applied to a Counter object.\n * @spec OCO1\n */\nexport interface ObjectsCounterOp {\n  /** The data value that should be added to the counter. */\n  amount: number; // OCO2a\n}\n\n/**\n * An ObjectsMapEntry represents the value at a given key in a Map object.\n * @spec OME1\n */\nexport interface ObjectsMapEntry<TData> {\n  /** Indicates whether the map entry has been removed. */\n  tombstone?: boolean; // OME2a\n  /**\n   * The {@link ObjectMessage.serial} value of the last operation that was applied to the map entry.\n   *\n   * It is optional in a MAP_CREATE operation and might be missing, in which case the client should use a nullish value for it\n   * and treat it as the \"earliest possible\" serial for comparison purposes.\n   */\n  timeserial?: string; // OME2b\n  /** A timestamp from the {@link timeserial} field. Only present if {@link tombstone} is `true` */\n  serialTimestamp?: number; // OME2d\n  /** The data that represents the value of the map entry. */\n  data?: TData; // OME2c\n}\n\n/**\n * An ObjectsMap object represents a map of key-value pairs.\n * @spec OMP1\n */\nexport interface ObjectsMap<TData> {\n  /** The conflict-resolution semantics used by the map object. */\n  semantics?: ObjectsMapSemantics; // OMP3a\n  /** The map entries, indexed by key. */\n  entries?: Record<string, ObjectsMapEntry<TData>>; // OMP3b\n}\n\n/**\n * An ObjectsCounter object represents an incrementable and decrementable value\n * @spec OCN1\n */\nexport interface ObjectsCounter {\n  /** The value of the counter */\n  count?: number; // OCN2a\n}\n\n/**\n * An ObjectOperation describes an operation to be applied to an object on a channel.\n * @spec OOP1\n */\nexport interface ObjectOperation<TData> {\n  /** Defines the operation to be applied to the object. */\n  action: ObjectOperationAction; // OOP3a\n  /** The object ID of the object on a channel to which the operation should be applied. */\n  objectId: string; // OOP3b\n  /** The payload for the operation if it is an operation on a Map object type. */\n  mapOp?: ObjectsMapOp<TData>; // OOP3c\n  /** The payload for the operation if it is an operation on a Counter object type. */\n  counterOp?: ObjectsCounterOp; // OOP3d\n  /**\n   * The payload for the operation if the operation is MAP_CREATE.\n   * Defines the initial value for the Map object.\n   */\n  map?: ObjectsMap<TData>; // OOP3e\n  /**\n   * The payload for the operation if the operation is COUNTER_CREATE.\n   * Defines the initial value for the Counter object.\n   */\n  counter?: ObjectsCounter; // OOP3f\n  /**\n   * The nonce, must be present on create operations. This is the random part\n   * that has been hashed with the type and initial value to create the object ID.\n   */\n  nonce?: string; // OOP3g\n  /**\n   * The initial value of the object, represented as a JSON string.\n   * Used along with the nonce and timestamp to create the object ID.\n   *\n   * This field must be set by the client for MAP_CREATE and COUNTER_CREATE operations.\n   * The server uses it to verify the object ID, and after verification, the JSON string\n   * is decoded into the initial value for new Map or Counter objects.\n   *\n   * This field must not be read by the client if received from the server.\n   */\n  initialValue?: string; // OOP3h\n}\n\n/**\n * An ObjectState describes the instantaneous state of an object on a channel.\n * @spec OST1\n */\nexport interface ObjectState<TData> {\n  /** The identifier of the object. */\n  objectId: string; // OST2a\n  /** A map of serials keyed by a {@link ObjectMessage.siteCode}, representing the last operations applied to this object */\n  siteTimeserials: Record<string, string>; // OST2b\n  /** True if the object has been tombstoned. */\n  tombstone: boolean; // OST2c\n  /**\n   * The operation that created the object.\n   *\n   * Can be missing if create operation for the object is not known at this point.\n   */\n  createOp?: ObjectOperation<TData>; // OST2d\n  /**\n   * The data that represents the result of applying all operations to a Map object\n   * excluding the initial value from the create operation if it is a Map object type.\n   */\n  map?: ObjectsMap<TData>; // OST2e\n  /**\n   * The data that represents the result of applying all operations to a Counter object\n   * excluding the initial value from the create operation if it is a Counter object type.\n   */\n  counter?: ObjectsCounter; // OST2f\n}\n\nfunction encode(\n  message: Utils.Properties<ObjectMessage> | Utils.Properties<WireObjectMessage>,\n  utils: typeof Utils,\n  messageEncoding: typeof MessageEncoding,\n  encodeObjectDataFn: EncodeObjectDataFunction,\n): WireObjectMessage {\n  // deep copy the message to avoid mutating the original one.\n  // buffer values won't be correctly copied, so we will need to use the original message when encoding.\n  const result = Object.assign(new WireObjectMessage(utils, messageEncoding), copyMsg(message));\n\n  // encode \"object\" field\n  if (message.object?.map?.entries) {\n    result.object!.map!.entries = encodeMapEntries(message.object.map.entries, encodeObjectDataFn);\n  }\n\n  if (message.object?.createOp?.map?.entries) {\n    result.object!.createOp!.map!.entries = encodeMapEntries(message.object.createOp.map.entries, encodeObjectDataFn);\n  }\n\n  if (message.object?.createOp?.mapOp?.data) {\n    result.object!.createOp!.mapOp!.data = encodeObjectData(message.object.createOp.mapOp.data, encodeObjectDataFn);\n  }\n\n  // OOP5\n  // encode \"operation\" field\n  if (message.operation?.map?.entries) {\n    result.operation!.map!.entries = encodeMapEntries(message.operation.map.entries, encodeObjectDataFn);\n  }\n\n  if (message.operation?.mapOp?.data) {\n    result.operation!.mapOp!.data = encodeObjectData(message.operation.mapOp.data, encodeObjectDataFn);\n  }\n\n  return result;\n}\n\nfunction encodeMapEntries(\n  mapEntries: Record<string, ObjectsMapEntry<ObjectData | WireObjectData>>,\n  encodeFn: EncodeObjectDataFunction,\n): Record<string, ObjectsMapEntry<WireObjectData>> {\n  return Object.entries(mapEntries).reduce(\n    (acc, v) => {\n      const [key, entry] = v;\n      const encodedData = entry.data ? encodeObjectData(entry.data, encodeFn) : undefined;\n      acc[key] = {\n        ...entry,\n        data: encodedData,\n      };\n      return acc;\n    },\n    {} as Record<string, ObjectsMapEntry<WireObjectData>>,\n  );\n}\n\n/** @spec OD4 */\nfunction encodeObjectData(data: ObjectData | WireObjectData, encodeFn: EncodeObjectDataFunction): WireObjectData {\n  const encodedData = encodeFn(data);\n  return encodedData;\n}\n\n/**\n * Used to create an {@link ObjectOperation.initialValue} JSON string for *_CREATE operations,\n * based on the object operation message that contains the initial value for the object.\n */\nexport function createInitialValueJSONString(\n  operation: Partial<ObjectOperation<ObjectData>>,\n  client: BaseClient,\n): string {\n  // the object operation may contain user-provided data that requires encoding.\n  // for example, buffers must be encoded since the initial value will be represented as a JSON string.\n  // we can use ObjectMessage methods to encode the object operation.\n  const msg = ObjectMessage.fromValues(\n    // cast initialValue to ObjectOperation here, even though it may lack some properties\n    // that are usually present on ObjectOperation.\n    // this ObjectMessage instance is only used to get the encoded body,\n    // so it's ok for the operation field to be incomplete in this context.\n    // doing the type assertion here avoids the need to define a separate ObjectMessage\n    // type that supports a fully optional ObjectOperation.\n    { operation: operation as ObjectOperation<ObjectData> },\n    client.Utils,\n    client.MessageEncoding,\n  );\n  const wireMsg = msg.encode(client);\n\n  // get the encoded operation that is safe to be sent over the wire as a JSON string.\n  const { operation: encodedOperation } = wireMsg.encodeForWire(client.Utils.Format.json);\n\n  // finally, initialValue is the JSON string representation of the encoded operation.\n  return JSON.stringify(encodedOperation);\n}\n\nfunction strMsg(msg: any, className: string) {\n  let result = '[' + className;\n\n  for (const attr in msg) {\n    if (msg[attr] === undefined || attr === '_utils' || attr === '_messageEncoding') {\n      continue;\n    }\n\n    if (attr === 'operation' || attr === 'object' || attr === 'extras') {\n      result += `; ${attr}=${JSON.stringify(msg[attr])}`;\n    } else {\n      result += `; ${attr}=${msg[attr]}`;\n    }\n  }\n\n  result += ']';\n  return result;\n}\n\n/**\n * Deep copy public properties of an object message, using `JSON.parse(JSON.stringify(object))` for nested object fields like `operation` and `object`.\n *\n * Important: Buffer instances are not copied correctly using `JSON.parse(JSON.stringify(object))`, as they lose their type and become plain objects.\n * If you need access to the original Buffer values, use the original message instance instead.\n */\n\nfunction copyMsg(\n  msg: Utils.Properties<ObjectMessage | WireObjectMessage>,\n): Utils.Properties<ObjectMessage | WireObjectMessage> {\n  const result: Utils.Properties<ObjectMessage | WireObjectMessage> = {\n    id: msg.id,\n    clientId: msg.clientId,\n    connectionId: msg.connectionId,\n    timestamp: msg.timestamp,\n    serial: msg.serial,\n    serialTimestamp: msg.serialTimestamp,\n    siteCode: msg.siteCode,\n  };\n\n  if (msg.operation) {\n    result.operation = JSON.parse(JSON.stringify(msg.operation));\n  }\n  if (msg.object) {\n    result.object = JSON.parse(JSON.stringify(msg.object));\n  }\n  if (msg.extras) {\n    result.extras = JSON.parse(JSON.stringify(msg.extras));\n  }\n\n  return result;\n}\n\nfunction stringifyOperation(operation: ObjectOperation<ObjectData>): ObjectsApi.ObjectOperation {\n  return {\n    ...operation,\n    action: operationActions[operation.action] || 'unknown',\n    map: operation.map\n      ? {\n          ...operation.map,\n          semantics: operation.map.semantics != null ? mapSemantics[operation.map.semantics] || 'unknown' : undefined,\n        }\n      : undefined,\n  };\n}\n\n/**\n * A decoded {@link WireObjectMessage} message\n * @spec OM1\n * @internal\n */\nexport class ObjectMessage {\n  id?: string; // OM2a\n  clientId?: string; // OM2b\n  connectionId?: string; // OM2c\n  extras?: any; // OM2d\n  timestamp?: number; // OM2e\n  /**\n   * Describes an operation to be applied to an object.\n   *\n   * Mutually exclusive with the `object` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT`.\n   */\n  operation?: ObjectOperation<ObjectData>; // OM2f\n  /**\n   * Describes the instantaneous state of an object.\n   *\n   * Mutually exclusive with the `operation` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT_SYNC`.\n   */\n  object?: ObjectState<ObjectData>; // OM2g\n  /** An opaque string that uniquely identifies this object message. */\n  serial?: string; // OM2h\n  /** A timestamp from the {@link serial} field. */\n  serialTimestamp?: number; // OM2j\n  /** An opaque string used as a key to update the map of serial values on an object. */\n  siteCode?: string; // OM2i\n\n  constructor(\n    private _utils: typeof Utils,\n    private _messageEncoding: typeof MessageEncoding,\n  ) {}\n\n  static fromValues(\n    values: Utils.Properties<ObjectMessage>,\n    utils: typeof Utils,\n    messageEncoding: typeof MessageEncoding,\n  ): ObjectMessage {\n    return Object.assign(new ObjectMessage(utils, messageEncoding), values);\n  }\n\n  static fromValuesArray(\n    values: Utils.Properties<ObjectMessage>[],\n    utils: typeof Utils,\n    messageEncoding: typeof MessageEncoding,\n  ): ObjectMessage[] {\n    return values.map((x) => ObjectMessage.fromValues(x, utils, messageEncoding));\n  }\n\n  /**\n   * Protocol agnostic encoding of this ObjectMessage. Returns a new {@link WireObjectMessage} instance.\n   *\n   * Uses encoding functions from regular `Message` processing.\n   *\n   * @spec OM4\n   */\n  encode(client: BaseClient): WireObjectMessage {\n    const encodeObjectDataFn: EncodeObjectDataFunction = (data: ObjectData) => {\n      const encodedObjectData: WireObjectData = { objectId: data.objectId };\n\n      if (client.Platform.BufferUtils.isBuffer(data.value)) {\n        // bytes encoding happens later when WireObjectMessage is encoded for wire transmission\n        encodedObjectData.bytes = data.value;\n      } else if (typeof data.value === 'string') {\n        encodedObjectData.string = data.value; // OD4c4, OD4d4\n      } else if (typeof data.value === 'boolean') {\n        encodedObjectData.boolean = data.value; // OD4c1, OD4d1\n      } else if (typeof data.value === 'number') {\n        encodedObjectData.number = data.value; // OD4c3, OD4d3\n      } else if (typeof data.value === 'object' && data.value !== null) {\n        // OD4c5, OD4d5\n        encodedObjectData.json = JSON.stringify(data.value);\n      }\n\n      return encodedObjectData;\n    };\n\n    return encode(this, this._utils, this._messageEncoding, encodeObjectDataFn);\n  }\n\n  toString(): string {\n    return strMsg(this, 'ObjectMessage');\n  }\n\n  isOperationMessage(): boolean {\n    return this.operation != null;\n  }\n\n  isSyncMessage(): boolean {\n    return this.object != null;\n  }\n\n  toUserFacingMessage(channel: RealtimeChannel): ObjectsApi.ObjectMessage {\n    return {\n      id: this.id!,\n      clientId: this.clientId,\n      connectionId: this.connectionId,\n      timestamp: this.timestamp!,\n      channel: channel.name,\n      // we expose only operation messages to users, so operation field is always present\n      operation: stringifyOperation(this.operation!),\n      serial: this.serial,\n      serialTimestamp: this.serialTimestamp,\n      siteCode: this.siteCode,\n      extras: this.extras,\n    };\n  }\n}\n\n/**\n * An individual object message to be sent or received via the Ably Realtime service.\n * @spec OM1\n * @internal\n */\nexport class WireObjectMessage {\n  id?: string; // OM2a\n  clientId?: string; // OM2b\n  connectionId?: string; // OM2c\n  extras?: any; // OM2d\n  timestamp?: number; // OM2e\n  /**\n   * Describes an operation to be applied to an object.\n   *\n   * Mutually exclusive with the `object` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT`.\n   */\n  operation?: ObjectOperation<WireObjectData>; // OM2f\n  /**\n   * Describes the instantaneous state of an object.\n   *\n   * Mutually exclusive with the `operation` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT_SYNC`.\n   */\n  object?: ObjectState<WireObjectData>; // OM2g\n  /** An opaque string that uniquely identifies this object message. */\n  serial?: string; // OM2h\n  /** A timestamp from the {@link serial} field. */\n  serialTimestamp?: number; // OM2j\n  /** An opaque string used as a key to update the map of serial values on an object. */\n  siteCode?: string; // OM2i\n\n  constructor(\n    private _utils: typeof Utils,\n    private _messageEncoding: typeof MessageEncoding,\n  ) {}\n\n  static fromValues(\n    values: Utils.Properties<WireObjectMessage>,\n    utils: typeof Utils,\n    messageEncoding: typeof MessageEncoding,\n  ): WireObjectMessage {\n    return Object.assign(new WireObjectMessage(utils, messageEncoding), values);\n  }\n\n  static fromValuesArray(\n    values: Utils.Properties<WireObjectMessage>[],\n    utils: typeof Utils,\n    messageEncoding: typeof MessageEncoding,\n  ): WireObjectMessage[] {\n    return values.map((x) => WireObjectMessage.fromValues(x, utils, messageEncoding));\n  }\n\n  /**\n   * Encodes WireObjectMessage for wire transmission. Does not mutate the provided WireObjectMessage.\n   *\n   * Uses encoding functions from regular `Message` processing.\n   */\n  encodeForWire(format: Utils.Format): WireObjectMessage {\n    const encodeObjectDataFn: EncodeObjectDataFunction = (data: WireObjectData) => {\n      if (data.bytes != null) {\n        // OD4c2, OD4d2\n        const result = this._messageEncoding.encodeDataForWire(data.bytes, null, format);\n        // no need to set the encoding\n        return { ...data, bytes: result.data };\n      }\n\n      return { ...data };\n    };\n\n    return encode(this, this._utils, this._messageEncoding, encodeObjectDataFn);\n  }\n\n  /**\n   * Decodes this WireObjectMessage and returns a new {@link ObjectMessage} instance.\n   *\n   * Format is used to decode the bytes value as it's implicitly encoded depending on the protocol used:\n   * - json: bytes are Base64-encoded string\n   * - msgpack: bytes have a binary representation and don't need to be decoded\n   *\n   * @spec OM5\n   */\n  decode(client: BaseClient, format: Utils.Format | undefined): ObjectMessage {\n    // deep copy the message to avoid mutating the original one.\n    // buffer values won't be correctly copied, so we will need to use the original message when decoding.\n    const result = Object.assign(new ObjectMessage(this._utils, this._messageEncoding), copyMsg(this));\n\n    try {\n      // decode \"object\" field\n      if (this.object?.map?.entries) {\n        result.object!.map!.entries = this._decodeMapEntries(this.object.map.entries, client, format);\n      }\n\n      if (this.object?.createOp?.map?.entries) {\n        result.object!.createOp!.map!.entries = this._decodeMapEntries(\n          this.object.createOp.map.entries,\n          client,\n          format,\n        );\n      }\n\n      if (this.object?.createOp?.mapOp?.data) {\n        result.object!.createOp!.mapOp!.data = this._decodeObjectData(this.object.createOp.mapOp.data, client, format);\n      }\n\n      // decode \"operation\" field\n      if (this.operation?.map?.entries) {\n        result.operation!.map!.entries = this._decodeMapEntries(this.operation.map.entries, client, format);\n      }\n\n      if (this.operation?.mapOp?.data) {\n        result.operation!.mapOp!.data = this._decodeObjectData(this.operation.mapOp.data, client, format);\n      }\n    } catch (error) {\n      client.Logger.logAction(\n        client.logger,\n        client.Logger.LOG_ERROR,\n        'WireObjectMessage.decode()',\n        this._utils.inspectError(error),\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Overload toJSON() to intercept JSON.stringify().\n   *\n   * This will prepare the message to be transmitted over the wire to Ably.\n   * It will encode the data payload according to the wire protocol used on the client.\n   */\n  toJSON() {\n    // we can infer the format used by client by inspecting with what arguments this method was called.\n    // if JSON protocol is being used, the JSON.stringify() will be called and this toJSON() method will have a non-empty arguments list.\n    // MSGPack protocol implementation also calls toJSON(), but with an empty arguments list.\n    const format = arguments.length > 0 ? this._utils.Format.json : this._utils.Format.msgpack;\n    const { _utils, _messageEncoding, ...publicProps } = this.encodeForWire(format);\n    return publicProps;\n  }\n\n  toString(): string {\n    return strMsg(this, 'WireObjectMessage');\n  }\n\n  /** @spec OM3 */\n  getMessageSize(): number {\n    let size = 0;\n\n    // OM3a\n    size += this.clientId?.length ?? 0; // OM3f\n    if (this.operation) {\n      size += this._getObjectOperationSize(this.operation); // OM3b\n    }\n    if (this.object) {\n      size += this._getObjectStateSize(this.object); // OM3c\n    }\n    if (this.extras) {\n      size += JSON.stringify(this.extras).length; // OM3d\n    }\n\n    return size;\n  }\n\n  /** @spec OOP4 */\n  private _getObjectOperationSize(operation: ObjectOperation<WireObjectData>): number {\n    let size = 0;\n\n    // OOP4a\n    if (operation.mapOp) {\n      size += this._getMapOpSize(operation.mapOp); // OOP4b\n    }\n    if (operation.counterOp) {\n      size += this._getCounterOpSize(operation.counterOp); // OOP4c\n    }\n    if (operation.map) {\n      size += this._getObjectMapSize(operation.map); // OOP4d\n    }\n    if (operation.counter) {\n      size += this._getObjectCounterSize(operation.counter); // OOP4e\n    }\n\n    return size;\n  }\n\n  /** @spec OST3 */\n  private _getObjectStateSize(obj: ObjectState<WireObjectData>): number {\n    let size = 0;\n\n    // OST3a\n    if (obj.map) {\n      size += this._getObjectMapSize(obj.map); // OST3b\n    }\n    if (obj.counter) {\n      size += this._getObjectCounterSize(obj.counter); // OST3c\n    }\n    if (obj.createOp) {\n      size += this._getObjectOperationSize(obj.createOp); // OST3d\n    }\n\n    return size;\n  }\n\n  /** @spec OMP4 */\n  private _getObjectMapSize(map: ObjectsMap<WireObjectData>): number {\n    let size = 0;\n\n    // OMP4a\n    Object.entries(map.entries ?? {}).forEach(([key, entry]) => {\n      size += key?.length ?? 0; // OMP4a1\n      if (entry) {\n        size += this._getMapEntrySize(entry); // OMP4a2\n      }\n    });\n\n    return size;\n  }\n\n  /** @spec OCN3 */\n  private _getObjectCounterSize(counter: ObjectsCounter): number {\n    // OCN3b\n    if (counter.count == null) {\n      return 0;\n    }\n\n    // OCN3a\n    return 8;\n  }\n\n  /** @spec OME3 */\n  private _getMapEntrySize(entry: ObjectsMapEntry<WireObjectData>): number {\n    let size = 0;\n\n    // OME3a\n    if (entry.data) {\n      size += this._getObjectDataSize(entry.data); // OME3b\n    }\n\n    return size;\n  }\n\n  /** @spec OMO3 */\n  private _getMapOpSize(mapOp: ObjectsMapOp<WireObjectData>): number {\n    let size = 0;\n\n    // OMO3a\n    size += mapOp.key?.length ?? 0; // OMO3d\n    if (mapOp.data) {\n      size += this._getObjectDataSize(mapOp.data); // OMO3b\n    }\n\n    return size;\n  }\n\n  /** @spec OCO3 */\n  private _getCounterOpSize(operation: ObjectsCounterOp): number {\n    // OCO3b\n    if (operation.amount == null) {\n      return 0;\n    }\n\n    // OCO3a\n    return 8;\n  }\n\n  /** @spec OD3 */\n  private _getObjectDataSize(data: WireObjectData): number {\n    let size = 0;\n\n    // OD3a\n    if (data.boolean != null) {\n      size += this._utils.dataSizeBytes(data.boolean); // OD3b\n    }\n    if (data.bytes != null) {\n      size += this._utils.dataSizeBytes(data.bytes); // OD3c\n    }\n    if (data.number != null) {\n      size += this._utils.dataSizeBytes(data.number); // OD3d\n    }\n    if (data.string != null) {\n      size += this._utils.dataSizeBytes(data.string); // OD3e\n    }\n    if (data.json != null) {\n      size += this._utils.dataSizeBytes(data.json);\n    }\n\n    return size;\n  }\n\n  private _decodeMapEntries(\n    mapEntries: Record<string, ObjectsMapEntry<WireObjectData>>,\n    client: BaseClient,\n    format: Utils.Format | undefined,\n  ): Record<string, ObjectsMapEntry<ObjectData>> {\n    return Object.entries(mapEntries).reduce(\n      (acc, v) => {\n        const [key, entry] = v;\n        const decodedData = entry.data ? this._decodeObjectData(entry.data, client, format) : undefined;\n        acc[key] = {\n          ...entry,\n          data: decodedData,\n        };\n        return acc;\n      },\n      {} as Record<string, ObjectsMapEntry<ObjectData>>,\n    );\n  }\n\n  /** @spec OD5 */\n  private _decodeObjectData(\n    objectData: WireObjectData,\n    client: BaseClient,\n    format: Utils.Format | undefined,\n  ): ObjectData {\n    try {\n      if (objectData.objectId != null) {\n        return {\n          objectId: objectData.objectId,\n        };\n      }\n\n      let decodedBytes: Buffer | ArrayBuffer | undefined;\n      if (objectData.bytes != null) {\n        decodedBytes =\n          format === 'msgpack'\n            ? // OD5a1 - connection is using msgpack protocol, bytes are already a buffer\n              (objectData.bytes as Buffer | ArrayBuffer)\n            : // OD5b2 - connection is using JSON protocol, Base64-decode bytes value\n              client.Platform.BufferUtils.base64Decode(String(objectData.bytes));\n      }\n\n      let decodedJson: ObjectsApi.JsonObject | ObjectsApi.JsonArray | undefined;\n      if (objectData.json != null) {\n        decodedJson = JSON.parse(objectData.json); // OD5a2, OD5b3\n      }\n\n      return {\n        value: decodedBytes ?? decodedJson ?? objectData.boolean ?? objectData.number ?? objectData.string,\n      };\n    } catch (error) {\n      client.Logger.logAction(\n        client.logger,\n        client.Logger.LOG_ERROR,\n        'WireObjectMessage._decodeObjectData()',\n        this._utils.inspectError(error),\n      );\n      // object data decoding has failed, return the data as is.\n      return {\n        ...objectData,\n      } as ObjectData;\n    }\n  }\n}\n", "import { __livetype } from '../../../ably';\nimport { LiveCounter } from '../../../liveobjects';\nimport { ObjectId } from './objectid';\nimport {\n  createInitialValueJSONString,\n  ObjectData,\n  ObjectMessage,\n  ObjectOperation,\n  ObjectOperationAction,\n} from './objectmessage';\nimport { RealtimeObject } from './realtimeobject';\n\n/**\n * A value type class that serves as a simple container for LiveCounter data.\n * Contains sufficient information for the client to produce a COUNTER_CREATE operation\n * for the LiveCounter object.\n *\n * Properties of this class are immutable after construction and the instance\n * will be frozen to prevent mutation.\n */\nexport class LiveCounterValueType implements LiveCounter {\n  declare readonly [__livetype]: 'LiveCounter'; // type-only, unique symbol to satisfy branded interfaces, no JS emitted\n  private readonly _livetype = 'LiveCounter'; // use a runtime property to provide a reliable cross-bundle type identification instead of `instanceof` operator\n  private readonly _count: number;\n\n  private constructor(count: number) {\n    this._count = count;\n    Object.freeze(this);\n  }\n\n  static create(initialCount: number = 0): LiveCounter {\n    // We can't directly import the ErrorInfo class from the core library into the plugin (as this would bloat the plugin size),\n    // and, since we're in a user-facing static method, we can't expect a user to pass a client library instance, as this would make the API ugly.\n    // Since we can't use ErrorInfo here, we won't do any validation at this step; instead, validation will happen in the mutation methods\n    // when we try to create this object.\n\n    return new LiveCounterValueType(initialCount);\n  }\n\n  /**\n   * @internal\n   */\n  static instanceof(value: unknown): value is LiveCounterValueType {\n    return typeof value === 'object' && value !== null && (value as LiveCounterValueType)._livetype === 'LiveCounter';\n  }\n\n  /**\n   * @internal\n   */\n  static async createCounterCreateMessage(\n    realtimeObject: RealtimeObject,\n    value: LiveCounterValueType,\n  ): Promise<ObjectMessage> {\n    const client = realtimeObject.getClient();\n    const count = value._count;\n\n    if (count !== undefined && (typeof count !== 'number' || !Number.isFinite(count))) {\n      throw new client.ErrorInfo('Counter value should be a valid number', 40003, 400);\n    }\n\n    const initialValueOperation = LiveCounterValueType.createInitialValueOperation(count);\n    const initialValueJSONString = createInitialValueJSONString(initialValueOperation, client);\n    const nonce = client.Utils.cheapRandStr();\n    const msTimestamp = await client.getTimestamp(true);\n\n    const objectId = ObjectId.fromInitialValue(\n      client.Platform,\n      'counter',\n      initialValueJSONString,\n      nonce,\n      msTimestamp,\n    ).toString();\n\n    const msg = ObjectMessage.fromValues(\n      {\n        operation: {\n          ...initialValueOperation,\n          action: ObjectOperationAction.COUNTER_CREATE,\n          objectId,\n          nonce,\n          initialValue: initialValueJSONString,\n        } as ObjectOperation<ObjectData>,\n      },\n      client.Utils,\n      client.MessageEncoding,\n    );\n\n    return msg;\n  }\n\n  private static createInitialValueOperation(count?: number): Pick<ObjectOperation<ObjectData>, 'counter'> {\n    return {\n      counter: {\n        count: count ?? 0,\n      },\n    };\n  }\n}\n", "var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n", "export const ROOT_OBJECT_ID = 'root';\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type EventEmitter from 'common/lib/util/eventemitter';\nimport type { EventCallback, Subscription } from '../../../ably';\nimport { ROOT_OBJECT_ID } from './constants';\nimport { InstanceEvent } from './instance';\nimport { ObjectData, ObjectMessage, ObjectOperation } from './objectmessage';\nimport { PathEvent } from './pathobjectsubscriptionregister';\nimport { ObjectsOperationSource, RealtimeObject } from './realtimeobject';\n\nexport enum LiveObjectSubscriptionEvent {\n  updated = 'updated',\n}\n\nexport interface LiveObjectData {\n  data: any;\n}\n\nexport interface LiveObjectUpdate {\n  _type: 'LiveMapUpdate' | 'LiveCounterUpdate';\n  /** Delta of the change */\n  update: any;\n  /** Object message that caused an update to an object, if available */\n  objectMessage?: ObjectMessage;\n  /** Indicates whether this update is a result of a tombstone (delete) operation. */\n  tombstone?: boolean;\n}\n\nexport interface LiveObjectUpdateNoop {\n  // have optional update field with undefined type so it's not possible to create a noop object with a meaningful update property.\n  update?: undefined;\n  noop: true;\n}\n\nexport abstract class LiveObject<\n  TData extends LiveObjectData = LiveObjectData,\n  TUpdate extends LiveObjectUpdate = LiveObjectUpdate,\n> {\n  protected _client: BaseClient;\n  protected _subscriptions: EventEmitter;\n  protected _objectId: string;\n  /**\n   * Represents an aggregated value for an object, which combines the initial value for an object from the create operation,\n   * and all object operations applied to the object.\n   */\n  protected _dataRef: TData;\n  protected _siteTimeserials: Record<string, string>;\n  protected _createOperationIsMerged: boolean;\n  private _tombstone: boolean;\n  private _tombstonedAt: number | undefined;\n  /**\n   * Track parent references - which LiveMap objects contain this object and at which keys.\n   * Multiple parents can reference the same object, so we use a Map of parent to Set of keys for efficient lookups.\n   */\n  private _parentReferences: Map<LiveObject, Set<string>>;\n\n  protected constructor(\n    protected _realtimeObject: RealtimeObject,\n    objectId: string,\n  ) {\n    this._client = this._realtimeObject.getClient();\n    this._subscriptions = new this._client.EventEmitter(this._client.logger);\n    this._objectId = objectId;\n    this._dataRef = this._getZeroValueData();\n    // use empty map of serials by default, so any future operation can be applied to this object\n    this._siteTimeserials = {};\n    this._createOperationIsMerged = false;\n    this._tombstone = false;\n    this._parentReferences = new Map<LiveObject, Set<string>>();\n  }\n\n  subscribe(listener: EventCallback<InstanceEvent>): Subscription {\n    this._subscriptions.on(LiveObjectSubscriptionEvent.updated, listener);\n\n    const unsubscribe = () => {\n      this._subscriptions.off(LiveObjectSubscriptionEvent.updated, listener);\n    };\n\n    return { unsubscribe };\n  }\n\n  /**\n   * @internal\n   */\n  getObjectId(): string {\n    return this._objectId;\n  }\n\n  /**\n   * Emits the {@link LiveObjectSubscriptionEvent.updated} event with provided update object if it isn't a noop.\n   * Also notifies the path object subscriptions about path-based events.\n   *\n   * @internal\n   */\n  notifyUpdated(update: TUpdate | LiveObjectUpdateNoop): void {\n    if (this._isNoopUpdate(update)) {\n      // do not emit update events for noop updates\n      return;\n    }\n\n    this._notifyInstanceSubscriptions(update);\n    this._notifyPathSubscriptions(update);\n\n    if (update.tombstone) {\n      // deregister all listeners if update was a result of a tombstone operation\n      this._subscriptions.off();\n    }\n  }\n\n  /**\n   * Clears the object's data, cancels any buffered operations and sets the tombstone flag to `true`.\n   *\n   * @internal\n   */\n  tombstone(objectMessage: ObjectMessage): TUpdate {\n    this._tombstone = true;\n    if (objectMessage.serialTimestamp != null) {\n      this._tombstonedAt = objectMessage.serialTimestamp;\n    } else {\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MINOR,\n        'LiveObject.tombstone()',\n        `object has been tombstoned but no \"serialTimestamp\" found in the message, using local clock instead; objectId=${this.getObjectId()}`,\n      );\n      this._tombstonedAt = Date.now(); // best-effort estimate since no timestamp provided by the server\n    }\n    const update = this.clearData();\n    update.objectMessage = objectMessage;\n    update.tombstone = true;\n\n    return update;\n  }\n\n  /**\n   * @internal\n   */\n  isTombstoned(): boolean {\n    return this._tombstone;\n  }\n\n  /**\n   * @internal\n   */\n  tombstonedAt(): number | undefined {\n    return this._tombstonedAt;\n  }\n\n  /**\n   * @internal\n   */\n  clearData(): TUpdate {\n    const previousDataRef = this._dataRef;\n    this._dataRef = this._getZeroValueData();\n    return this._updateFromDataDiff(previousDataRef, this._dataRef);\n  }\n\n  /**\n   * Add a parent reference indicating that this object is referenced by the given parent LiveMap at the specified key.\n   *\n   * @internal\n   */\n  addParentReference(parent: LiveObject, key: string): void {\n    const keys = this._parentReferences.get(parent);\n\n    if (keys) {\n      keys.add(key);\n    } else {\n      this._parentReferences.set(parent, new Set([key]));\n    }\n  }\n\n  /**\n   * Remove a parent reference indicating that this object is no longer referenced by the given parent LiveMap at the specified key.\n   *\n   * @internal\n   */\n  removeParentReference(parent: LiveObject, key: string): void {\n    const keys = this._parentReferences.get(parent);\n\n    if (keys) {\n      keys.delete(key);\n      // If no more keys for this parent, remove the parent entry entirely\n      if (keys.size === 0) {\n        this._parentReferences.delete(parent);\n      }\n    }\n  }\n\n  /**\n   * Remove all parent references for a specific parent (when parent is being deleted or cleared).\n   *\n   * @internal\n   */\n  removeParentReferenceAll(parent: LiveObject): void {\n    this._parentReferences.delete(parent);\n  }\n\n  /**\n   * Clears all parent references for this object.\n   *\n   * @internal\n   */\n  clearParentReferences(): void {\n    this._parentReferences.clear();\n  }\n\n  /**\n   * Calculates and returns all possible paths to this object from the root object by traversing up the parent hierarchy.\n   * Uses iterative DFS with an explicit stack. Each path is represented as an array of keys from root to this object.\n   *\n   * @internal\n   */\n  getFullPaths(): string[][] {\n    const paths: string[][] = [];\n\n    const stack: { obj: LiveObject; currentPath: string[]; visited: Set<LiveObject> }[] = [\n      { obj: this, currentPath: [], visited: new Set() },\n    ];\n\n    while (stack.length > 0) {\n      const { obj, currentPath, visited } = stack.pop()!;\n\n      // Check for cyclic references\n      if (visited.has(obj)) {\n        continue; // Skip this path to prevent infinite loops\n      }\n\n      // Create new visited set for this path\n      const newVisited = new Set(visited);\n      newVisited.add(obj);\n\n      if (obj.getObjectId() === ROOT_OBJECT_ID) {\n        // Reached the root object, add the current path\n        paths.push(currentPath);\n        continue;\n      }\n\n      // Otherwise, add work items for each parent-key combination to the stack\n      for (const [parent, keys] of obj._parentReferences) {\n        for (const key of keys) {\n          stack.push({\n            obj: parent,\n            currentPath: [key, ...currentPath],\n            visited: newVisited,\n          });\n        }\n      }\n    }\n\n    return paths;\n  }\n\n  /**\n   * Returns true if the given serial indicates that the operation to which it belongs should be applied to the object.\n   *\n   * An operation should be applied if its serial is strictly greater than the serial in the `siteTimeserials` map for the same site.\n   * If `siteTimeserials` map does not contain a serial for the same site, the operation should be applied.\n   */\n  protected _canApplyOperation(opSerial: string | undefined, opSiteCode: string | undefined): boolean {\n    if (!opSerial) {\n      throw new this._client.ErrorInfo(`Invalid serial: ${opSerial}`, 92000, 500);\n    }\n\n    if (!opSiteCode) {\n      throw new this._client.ErrorInfo(`Invalid site code: ${opSiteCode}`, 92000, 500);\n    }\n\n    const siteSerial = this._siteTimeserials[opSiteCode];\n    return !siteSerial || opSerial > siteSerial;\n  }\n\n  protected _applyObjectDelete(objectMessage: ObjectMessage): TUpdate {\n    return this.tombstone(objectMessage);\n  }\n\n  private _notifyInstanceSubscriptions(update: TUpdate): void {\n    const event: InstanceEvent = {\n      // Do not expose object sync messages as they do not represent a single operation on an object\n      message: update.objectMessage?.isOperationMessage() ? update.objectMessage : undefined,\n    };\n    this._subscriptions.emit(LiveObjectSubscriptionEvent.updated, event);\n  }\n\n  /**\n   * Notifies path-based subscriptions about changes to this object.\n   * For LiveMapUpdate events, also creates non-bubbling events for each updated key.\n   */\n  private _notifyPathSubscriptions(update: TUpdate): void {\n    const paths = this.getFullPaths();\n\n    if (paths.length === 0) {\n      // No paths to this object, skip notification\n      return;\n    }\n\n    // Do not expose object sync messages as they do not represent a single operation on an object\n    const operationObjectMessage = update.objectMessage?.isOperationMessage() ? update.objectMessage : undefined;\n    const pathEvents: PathEvent[] = paths.map((path) => ({\n      path,\n      message: operationObjectMessage,\n      bubbles: true,\n    }));\n\n    // For LiveMapUpdate, also create non-bubbling events for each updated key\n    if (update._type === 'LiveMapUpdate') {\n      const updatedKeys = Object.keys(update.update);\n\n      for (const key of updatedKeys) {\n        for (const basePath of paths) {\n          pathEvents.push({\n            path: [...basePath, key],\n            message: operationObjectMessage,\n            bubbles: false,\n          });\n        }\n      }\n    }\n\n    this._realtimeObject.getPathObjectSubscriptionRegister().notifyPathEvents(pathEvents);\n  }\n\n  private _isNoopUpdate(update: TUpdate | LiveObjectUpdateNoop): update is LiveObjectUpdateNoop {\n    return (update as LiveObjectUpdateNoop).noop === true;\n  }\n\n  /**\n   * Apply object operation message on this LiveObject.\n   *\n   * @returns `true` if the operation was applied successfully, `false` if it was skipped.\n   * @spec RTLC7g, RTLM15g\n   * @internal\n   */\n  abstract applyOperation(op: ObjectOperation<ObjectData>, msg: ObjectMessage, source: ObjectsOperationSource): boolean;\n  /**\n   * Overrides internal data for this LiveObject with object state from the given object message.\n   * Provided object state should hold a valid data for current LiveObject, e.g. counter data for LiveCounter, map data for LiveMap.\n   *\n   * Object states are received during sync sequence, and sync sequence is a source of truth for the current state of the objects,\n   * so we can use the data received from the sync sequence directly and override any data values or site serials this LiveObject has\n   * without the need to merge them.\n   *\n   * Returns an update object that describes the changes applied based on the object's previous value.\n   *\n   * @internal\n   */\n  abstract overrideWithObjectState(objectMessage: ObjectMessage): TUpdate | LiveObjectUpdateNoop;\n  /**\n   * @internal\n   */\n  abstract onGCInterval(): void;\n\n  protected abstract _getZeroValueData(): TData;\n  /**\n   * Calculate the update object based on the current LiveObject data and incoming new data.\n   */\n  protected abstract _updateFromDataDiff(prevDataRef: TData, newDataRef: TData): TUpdate;\n  /**\n   * Merges the initial data from the create operation into the LiveObject.\n   *\n   * Client SDKs do not need to keep around the object operation that created the object,\n   * so we can merge the initial data the first time we receive it for the object,\n   * and work with aggregated value after that.\n   *\n   * This saves us from needing to merge the initial value with operations applied to\n   * the object every time the object is read.\n   */\n  protected abstract _mergeInitialDataFromCreateOperation(\n    objectOperation: ObjectOperation<ObjectData>,\n    msg: ObjectMessage,\n  ): TUpdate;\n}\n", "export const DEFAULTS = {\n  gcInterval: 1000 * 60 * 5, // 5 minutes\n  /**\n   * The SDK will attempt to use the `objectsGCGracePeriod` value provided by the server in the `connectionDetails` object of the `CONNECTED` event.\n   * If the server does not provide this value, the SDK will fall back to this default value.\n   *\n   * Must be > 2 minutes to ensure we keep tombstones long enough to avoid the possibility of receiving an operation\n   * with an earlier serial that would not have been applied if the tombstone still existed.\n   *\n   * Applies both for map entries tombstones and object tombstones.\n   */\n  gcGracePeriod: 1000 * 60 * 60 * 24, // 24 hours\n};\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport { ROOT_OBJECT_ID } from './constants';\nimport { DEFAULTS } from './defaults';\nimport { LiveCounter } from './livecounter';\nimport { LiveMap } from './livemap';\nimport { LiveObject } from './liveobject';\nimport { ObjectId } from './objectid';\nimport { RealtimeObject } from './realtimeobject';\n\n/**\n * @internal\n * @spec RTO3\n */\nexport class ObjectsPool {\n  private _client: BaseClient;\n  private _pool: Map<string, LiveObject>; // RTO3a\n  private _gcInterval: ReturnType<typeof setInterval>;\n\n  constructor(private _realtimeObject: RealtimeObject) {\n    this._client = this._realtimeObject.getClient();\n    this._pool = this._createInitialPool();\n    this._gcInterval = setInterval(() => {\n      this._onGCInterval();\n    }, DEFAULTS.gcInterval);\n    // call nodejs's Timeout.unref to not require Node.js event loop to remain active due to this interval. see https://nodejs.org/api/timers.html#timeoutunref\n    this._gcInterval.unref?.();\n  }\n\n  get(objectId: string): LiveObject | undefined {\n    return this._pool.get(objectId);\n  }\n\n  getRoot(): LiveMap {\n    return this._pool.get(ROOT_OBJECT_ID) as LiveMap;\n  }\n\n  /**\n   * Returns all objects in the pool as an iterable.\n   * Used internally for operations that need to process all objects.\n   */\n  getAll(): IterableIterator<LiveObject> {\n    return this._pool.values();\n  }\n\n  /**\n   * Deletes objects from the pool for which object ids are not found in the provided array of ids.\n   */\n  deleteExtraObjectIds(objectIds: string[]): void {\n    const poolObjectIds = [...this._pool.keys()];\n    const extraObjectIds = poolObjectIds.filter((x) => !objectIds.includes(x));\n\n    extraObjectIds.forEach((x) => this._pool.delete(x));\n  }\n\n  set(objectId: string, liveObject: LiveObject): void {\n    this._pool.set(objectId, liveObject);\n  }\n\n  /**\n   * Removes all objects but root from the pool and clears the data for root.\n   * Does not create a new root object, so the reference to the root object remains the same.\n   */\n  resetToInitialPool(emitUpdateEvents: boolean): void {\n    // clear the pool first and keep the root object\n    const root = this.getRoot();\n    this._pool.clear();\n    this._pool.set(root.getObjectId(), root);\n\n    // clear the data, this will only clear the root object\n    this.clearObjectsData(emitUpdateEvents);\n  }\n\n  /**\n   * Clears the data stored for all objects in the pool.\n   */\n  clearObjectsData(emitUpdateEvents: boolean): void {\n    for (const object of this._pool.values()) {\n      const update = object.clearData();\n      if (emitUpdateEvents) {\n        object.notifyUpdated(update);\n      }\n    }\n  }\n\n  /** @spec RTO6 */\n  createZeroValueObjectIfNotExists(objectId: string): LiveObject {\n    const existingObject = this.get(objectId);\n    if (existingObject) {\n      return existingObject; // RTO6a\n    }\n\n    const parsedObjectId = ObjectId.fromString(this._client, objectId); // RTO6b\n    let zeroValueObject: LiveObject;\n    switch (parsedObjectId.type) {\n      case 'map': {\n        zeroValueObject = LiveMap.zeroValue(this._realtimeObject, objectId); // RTO6b2\n        break;\n      }\n\n      case 'counter':\n        zeroValueObject = LiveCounter.zeroValue(this._realtimeObject, objectId); // RTO6b3\n        break;\n    }\n\n    this.set(objectId, zeroValueObject);\n    return zeroValueObject;\n  }\n\n  private _createInitialPool(): Map<string, LiveObject> {\n    const pool = new Map<string, LiveObject>();\n    // RTO3b\n    const root = LiveMap.zeroValue(this._realtimeObject, ROOT_OBJECT_ID);\n    pool.set(root.getObjectId(), root);\n    return pool;\n  }\n\n  private _onGCInterval(): void {\n    const toDelete: string[] = [];\n    for (const [objectId, obj] of this._pool.entries()) {\n      // tombstoned objects should be removed from the pool if they have been tombstoned for longer than grace period.\n      // by removing them from the local pool, LiveObjects plugin no longer keeps a reference to those objects, allowing JS's\n      // Garbage Collection to eventually free the memory for those objects, provided the user no longer references them either.\n      if (obj.isTombstoned() && Date.now() - obj.tombstonedAt()! >= this._realtimeObject.gcGracePeriod) {\n        toDelete.push(objectId);\n        continue;\n      }\n\n      obj.onGCInterval();\n    }\n\n    toDelete.forEach((x) => this._pool.delete(x));\n  }\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type {\n  AnyBatchContext,\n  BatchContext,\n  CompactedJsonValue,\n  CompactedValue,\n  Instance,\n  Primitive,\n  Value,\n} from '../../../liveobjects';\nimport { DefaultInstance } from './instance';\nimport { LiveCounter } from './livecounter';\nimport { LiveMap } from './livemap';\nimport { RealtimeObject } from './realtimeobject';\nimport { RootBatchContext } from './rootbatchcontext';\n\nexport class DefaultBatchContext implements AnyBatchContext {\n  protected _client: BaseClient;\n\n  constructor(\n    protected _realtimeObject: RealtimeObject,\n    protected _instance: Instance<Value>,\n    protected _rootContext: RootBatchContext,\n  ) {\n    this._client = this._realtimeObject.getClient();\n  }\n\n  get id(): string | undefined {\n    this._throwIfClosed();\n    return this._instance.id;\n  }\n\n  get<T extends Value = Value>(key: string): BatchContext<T> | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n    this._throwIfClosed();\n    const instance = this._instance.get(key);\n    if (!instance) {\n      return undefined;\n    }\n    return this._rootContext.wrapInstance(instance) as unknown as BatchContext<T>;\n  }\n\n  value<T extends Primitive = Primitive>(): T | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n    this._throwIfClosed();\n    return this._instance.value();\n  }\n\n  compact<T extends Value = Value>(): CompactedValue<T> | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n    this._throwIfClosed();\n    return this._instance.compact();\n  }\n\n  compactJson<T extends Value = Value>(): CompactedJsonValue<T> | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n    this._throwIfClosed();\n    return this._instance.compactJson();\n  }\n\n  *entries<T extends Record<string, Value>>(): IterableIterator<[keyof T, BatchContext<T[keyof T]>]> {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n    this._throwIfClosed();\n    for (const [key, value] of this._instance.entries()) {\n      const ctx = this._rootContext.wrapInstance(value) as unknown as BatchContext<T[keyof T]>;\n      yield [key, ctx];\n    }\n  }\n\n  *keys<T extends Record<string, Value>>(): IterableIterator<keyof T> {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n    this._throwIfClosed();\n    yield* this._instance.keys();\n  }\n\n  *values<T extends Record<string, Value>>(): IterableIterator<BatchContext<T[keyof T]>> {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n    this._throwIfClosed();\n    for (const [_, value] of this.entries<T>()) {\n      yield value;\n    }\n  }\n\n  size(): number | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n    this._throwIfClosed();\n    return this._instance.size();\n  }\n\n  set(key: string, value: Value): void {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n    this._throwIfClosed();\n    if (!(this._instance as DefaultInstance<Value>).isLiveMap()) {\n      throw new this._client.ErrorInfo('Cannot set a key on a non-LiveMap instance', 92007, 400);\n    }\n    this._rootContext.queueMessages(async () =>\n      LiveMap.createMapSetMessage(this._realtimeObject, this._instance.id!, key, value),\n    );\n  }\n\n  remove(key: string): void {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n    this._throwIfClosed();\n    if (!(this._instance as DefaultInstance<Value>).isLiveMap()) {\n      throw new this._client.ErrorInfo('Cannot remove a key from a non-LiveMap instance', 92007, 400);\n    }\n    this._rootContext.queueMessages(async () => [\n      LiveMap.createMapRemoveMessage(this._realtimeObject, this._instance.id!, key),\n    ]);\n  }\n\n  increment(amount?: number): void {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n    this._throwIfClosed();\n    if (!(this._instance as DefaultInstance<Value>).isLiveCounter()) {\n      throw new this._client.ErrorInfo('Cannot increment a non-LiveCounter instance', 92007, 400);\n    }\n    this._rootContext.queueMessages(async () => [\n      LiveCounter.createCounterIncMessage(this._realtimeObject, this._instance.id!, amount ?? 1),\n    ]);\n  }\n\n  decrement(amount?: number): void {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n    this._throwIfClosed();\n    if (!(this._instance as DefaultInstance<Value>).isLiveCounter()) {\n      throw new this._client.ErrorInfo('Cannot decrement a non-LiveCounter instance', 92007, 400);\n    }\n    this.increment(-(amount ?? 1));\n  }\n\n  private _throwIfClosed(): void {\n    if (this._rootContext.isClosed()) {\n      throw new this._client.ErrorInfo('Batch is closed', 40000, 400);\n    }\n  }\n}\n", "import type { Instance, Value } from '../../../liveobjects';\nimport { DefaultBatchContext } from './batchcontext';\nimport { ObjectMessage } from './objectmessage';\nimport { RealtimeObject } from './realtimeobject';\n\nexport class RootBatchContext extends DefaultBatchContext {\n  /** Maps object ids to the corresponding batch context wrappers  */\n  private _wrappedInstances: Map<string, DefaultBatchContext> = new Map();\n  /**\n   * Some object messages require asynchronous I/O during construction\n   * (for example, generating an objectId for nested value types).\n   * Therefore, messages cannot be constructed immediately during\n   * synchronous method calls from batch context methods.\n   * Instead, message constructors are queued and executed on flush.\n   */\n  private _queuedMessageConstructors: (() => Promise<ObjectMessage[]>)[] = [];\n  private _isClosed = false;\n\n  constructor(realtimeObject: RealtimeObject, instance: Instance<Value>) {\n    // Pass a placeholder null that will be replaced immediately\n    super(realtimeObject, instance, null as any);\n    // Set the root context to itself\n    this._rootContext = this;\n  }\n\n  /** @internal */\n  async flush(): Promise<void> {\n    try {\n      this.close();\n\n      const msgs = (await Promise.all(this._queuedMessageConstructors.map((x) => x()))).flat();\n\n      if (msgs.length > 0) {\n        await this._realtimeObject.publishAndApply(msgs);\n      }\n    } finally {\n      this._wrappedInstances.clear();\n      this._queuedMessageConstructors = [];\n    }\n  }\n\n  /** @internal */\n  close(): void {\n    this._isClosed = true;\n  }\n\n  /** @internal */\n  isClosed(): boolean {\n    return this._isClosed;\n  }\n\n  /** @internal */\n  wrapInstance(instance: Instance<Value>): DefaultBatchContext {\n    const objectId = instance.id;\n    if (objectId) {\n      // memoize liveobject instances by their object ids\n      if (this._wrappedInstances.has(objectId)) {\n        return this._wrappedInstances.get(objectId)!;\n      }\n\n      let wrappedInstance = new DefaultBatchContext(this._realtimeObject, instance, this);\n      this._wrappedInstances.set(objectId, wrappedInstance);\n      return wrappedInstance;\n    }\n\n    return new DefaultBatchContext(this._realtimeObject, instance, this);\n  }\n\n  /** @internal */\n  queueMessages(msgCtors: () => Promise<ObjectMessage[]>): void {\n    this._queuedMessageConstructors.push(msgCtors);\n  }\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type { EventCallback, Subscription } from '../../../ably';\nimport type {\n  AnyInstance,\n  BatchContext,\n  BatchFunction,\n  CompactedJsonValue,\n  CompactedValue,\n  Instance,\n  InstanceSubscriptionEvent,\n  LiveObject as LiveObjectType,\n  Primitive,\n  Value,\n} from '../../../liveobjects';\nimport { LiveCounter } from './livecounter';\nimport { LiveMap } from './livemap';\nimport { LiveObject } from './liveobject';\nimport { ObjectMessage } from './objectmessage';\nimport { RealtimeObject } from './realtimeobject';\nimport { RootBatchContext } from './rootbatchcontext';\n\nexport interface InstanceEvent {\n  /** Object message that caused this event */\n  message?: ObjectMessage;\n}\n\nexport class DefaultInstance<T extends Value> implements AnyInstance<T> {\n  protected _client: BaseClient;\n\n  constructor(\n    private _realtimeObject: RealtimeObject,\n    private _value: T,\n  ) {\n    this._client = this._realtimeObject.getClient();\n  }\n\n  get id(): string | undefined {\n    if (!(this._value instanceof LiveObject)) {\n      // no id exists for non-LiveObject types\n      return undefined;\n    }\n    return this._value.getObjectId();\n  }\n\n  /**\n   * Returns an in-memory JavaScript object representation of this instance.\n   * Buffers are returned as-is.\n   * For primitive types, this is an alias for calling value().\n   *\n   * Use compactJson() for a JSON-serializable representation.\n   */\n  compact<U extends Value = Value>(): CompactedValue<U> | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    if (this._value instanceof LiveMap) {\n      return this._value.compact() as CompactedValue<U>;\n    }\n\n    return this.value() as CompactedValue<U>;\n  }\n\n  /**\n   * Returns a JSON-serializable representation of this instance.\n   * Buffers are converted to base64 strings.\n   *\n   * Use compact() for an in-memory representation.\n   */\n  compactJson<U extends Value = Value>(): CompactedJsonValue<U> | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    if (this._value instanceof LiveMap) {\n      return this._value.compactJson() as CompactedJsonValue<U>;\n    }\n\n    const value = this.value();\n\n    if (this._client.Platform.BufferUtils.isBuffer(value)) {\n      return this._client.Platform.BufferUtils.base64Encode(value) as CompactedJsonValue<U>;\n    }\n\n    return value as CompactedJsonValue<U>;\n  }\n\n  get<U extends Value = Value>(key: string): Instance<U> | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    if (!(this._value instanceof LiveMap)) {\n      // can't get a key from a non-LiveMap type\n      return undefined;\n    }\n\n    if (typeof key !== 'string') {\n      throw new this._client.ErrorInfo(`Key must be a string: ${key}`, 40003, 400);\n    }\n\n    const value = this._value.get(key);\n    if (value === undefined) {\n      return undefined;\n    }\n    return new DefaultInstance<U>(this._realtimeObject, value) as unknown as Instance<U>;\n  }\n\n  value<U extends number | Primitive = number | Primitive>(): U | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    if (this._value instanceof LiveObject) {\n      if (this._value instanceof LiveCounter) {\n        return this._value.value() as U;\n      }\n\n      // for other LiveObject types, return undefined\n      return undefined;\n    } else if (\n      this._client.Platform.BufferUtils.isBuffer(this._value) ||\n      typeof this._value === 'string' ||\n      typeof this._value === 'number' ||\n      typeof this._value === 'boolean' ||\n      typeof this._value === 'object' ||\n      this._value === null\n    ) {\n      // primitive type - return it\n      return this._value as unknown as U;\n    } else {\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MAJOR,\n        'DefaultInstance.value()',\n        `unexpected value type for instance, resolving to undefined; value=${this._value}; type=${typeof this._value}`,\n      );\n      // unknown type - return undefined\n      return undefined;\n    }\n  }\n\n  *entries<U extends Record<string, Value>>(): IterableIterator<[keyof U, Instance<U[keyof U]>]> {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    if (!(this._value instanceof LiveMap)) {\n      // return empty iterator for non-LiveMap objects\n      return;\n    }\n\n    for (const [key, value] of this._value.entries()) {\n      const instance = new DefaultInstance<U[keyof U]>(this._realtimeObject, value) as unknown as Instance<U[keyof U]>;\n      yield [key, instance];\n    }\n  }\n\n  *keys<U extends Record<string, Value>>(): IterableIterator<keyof U> {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    if (!(this._value instanceof LiveMap)) {\n      // return empty iterator for non-LiveMap objects\n      return;\n    }\n\n    yield* this._value.keys();\n  }\n\n  *values<U extends Record<string, Value>>(): IterableIterator<Instance<U[keyof U]>> {\n    for (const [_, value] of this.entries<U>()) {\n      yield value;\n    }\n  }\n\n  size(): number | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    if (!(this._value instanceof LiveMap)) {\n      // can't return size for non-LiveMap objects\n      return undefined;\n    }\n    return this._value.size();\n  }\n\n  set<U extends Record<string, Value> = Record<string, Value>>(\n    key: keyof U & string,\n    value: U[keyof U],\n  ): Promise<void> {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n    if (!(this._value instanceof LiveMap)) {\n      throw new this._client.ErrorInfo('Cannot set a key on a non-LiveMap instance', 92007, 400);\n    }\n    return this._value.set(key, value);\n  }\n\n  remove<U extends Record<string, Value> = Record<string, Value>>(key: keyof U & string): Promise<void> {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n    if (!(this._value instanceof LiveMap)) {\n      throw new this._client.ErrorInfo('Cannot remove a key from a non-LiveMap instance', 92007, 400);\n    }\n    return this._value.remove(key);\n  }\n\n  increment(amount?: number | undefined): Promise<void> {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n    if (!(this._value instanceof LiveCounter)) {\n      throw new this._client.ErrorInfo('Cannot increment a non-LiveCounter instance', 92007, 400);\n    }\n    return this._value.increment(amount ?? 1);\n  }\n\n  decrement(amount?: number | undefined): Promise<void> {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n    if (!(this._value instanceof LiveCounter)) {\n      throw new this._client.ErrorInfo('Cannot decrement a non-LiveCounter instance', 92007, 400);\n    }\n    return this._value.decrement(amount ?? 1);\n  }\n\n  subscribe(listener: EventCallback<InstanceSubscriptionEvent<T>>): Subscription {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    if (!(this._value instanceof LiveObject)) {\n      throw new this._client.ErrorInfo('Cannot subscribe to a non-LiveObject instance', 92007, 400);\n    }\n\n    return this._value.subscribe((event: InstanceEvent) => {\n      listener({\n        object: this as unknown as Instance<T>,\n        message: event.message?.toUserFacingMessage(this._realtimeObject.getChannel()),\n      });\n    });\n  }\n\n  subscribeIterator(): AsyncIterableIterator<InstanceSubscriptionEvent<T>> {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    if (!(this._value instanceof LiveObject)) {\n      throw new this._client.ErrorInfo('Cannot subscribe to a non-LiveObject instance', 92007, 400);\n    }\n\n    return this._client.Utils.listenerToAsyncIterator((listener) => {\n      const { unsubscribe } = this.subscribe(listener);\n      return unsubscribe;\n    });\n  }\n\n  async batch<T extends LiveObjectType = LiveObjectType>(fn: BatchFunction<T>): Promise<void> {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n\n    if (!(this._value instanceof LiveObject)) {\n      throw new this._client.ErrorInfo('Cannot batch operations on a non-LiveObject instance', 92007, 400);\n    }\n\n    const ctx = new RootBatchContext(this._realtimeObject, this);\n    try {\n      fn(ctx as unknown as BatchContext<T>);\n      await ctx.flush();\n    } finally {\n      ctx.close();\n    }\n  }\n\n  /** @internal */\n  public isLiveMap(): boolean {\n    return this._value instanceof LiveMap;\n  }\n\n  /** @internal */\n  public isLiveCounter(): boolean {\n    return this._value instanceof LiveCounter;\n  }\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type { EventCallback, Subscription } from '../../../ably';\nimport type {\n  AnyPathObject,\n  BatchContext,\n  BatchFunction,\n  CompactedJsonValue,\n  CompactedValue,\n  Instance,\n  LiveObject as LiveObjectType,\n  PathObject,\n  PathObjectSubscriptionEvent,\n  PathObjectSubscriptionOptions,\n  Primitive,\n  Value,\n} from '../../../liveobjects';\nimport { DefaultInstance } from './instance';\nimport { LiveCounter } from './livecounter';\nimport { LiveMap } from './livemap';\nimport { LiveObject } from './liveobject';\nimport { RealtimeObject } from './realtimeobject';\nimport { RootBatchContext } from './rootbatchcontext';\n\n/**\n * Implementation of AnyPathObject interface.\n * Provides a generic implementation that can handle any type of PathObject operations.\n */\nexport class DefaultPathObject implements AnyPathObject {\n  private _client: BaseClient;\n  private _path: string[];\n\n  constructor(\n    private _realtimeObject: RealtimeObject,\n    private _root: LiveMap,\n    path: string[],\n    parent?: DefaultPathObject,\n  ) {\n    this._client = this._realtimeObject.getClient();\n    // copy parent path array\n    this._path = [...(parent?._path ?? []), ...path];\n  }\n\n  /**\n   * Returns the fully-qualified string path that this PathObject represents.\n   * Path segments with dots in them are escaped with a backslash.\n   * For example, a path with segments `['a', 'b.c', 'd']` will be represented as `a.b\\.c.d`.\n   */\n  path(): string {\n    // escape dots in path segments to avoid ambiguity in the joined path\n    return this._escapePath(this._path).join('.');\n  }\n\n  /**\n   * Returns an in-memory JavaScript object representation of the object at this path.\n   * If the path does not resolve to any specific entry, returns `undefined`.\n   * Buffers are returned as-is.\n   * For primitive types, this is an alias for calling value().\n   *\n   * Use compactJson() for a JSON-serializable representation.\n   */\n  compact<U extends Value = Value>(): CompactedValue<U> | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    try {\n      const resolved = this._resolvePath(this._path);\n\n      if (resolved instanceof LiveMap) {\n        return resolved.compact() as CompactedValue<U>;\n      }\n\n      return this.value() as CompactedValue<U>;\n    } catch (error) {\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\n        // ignore path resolution errors and return undefined\n        return undefined;\n      }\n      // rethrow everything else\n      throw error;\n    }\n  }\n\n  /**\n   * Returns a JSON-serializable representation of the object at this path.\n   * If the path does not resolve to any specific entry, returns `undefined`.\n   * Buffers are converted to base64 strings.\n   *\n   * Use compact() for an in-memory representation.\n   */\n  compactJson<U extends Value = Value>(): CompactedJsonValue<U> | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    try {\n      const resolved = this._resolvePath(this._path);\n\n      if (resolved instanceof LiveMap) {\n        return resolved.compactJson() as CompactedJsonValue<U>;\n      }\n\n      const value = this.value();\n\n      if (this._client.Platform.BufferUtils.isBuffer(value)) {\n        return this._client.Platform.BufferUtils.base64Encode(value) as CompactedJsonValue<U>;\n      }\n\n      return value as CompactedJsonValue<U>;\n    } catch (error) {\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\n        // ignore path resolution errors and return undefined\n        return undefined;\n      }\n      // rethrow everything else\n      throw error;\n    }\n  }\n\n  /**\n   * Navigate to a child path within the collection by obtaining a PathObject for that path.\n   * The next path segment in a collection is identified with a string key.\n   */\n  get<U extends Value = Value>(key: string): PathObject<U> {\n    if (typeof key !== 'string') {\n      throw new this._client.ErrorInfo(`Path key must be a string: ${key}`, 40003, 400);\n    }\n    return new DefaultPathObject(this._realtimeObject, this._root, [key], this) as unknown as PathObject<U>;\n  }\n\n  /**\n   * Get a PathObject at the specified path relative to this object\n   */\n  at<U extends Value = Value>(path: string): PathObject<U> {\n    if (typeof path !== 'string') {\n      throw new this._client.ErrorInfo(`Path must be a string: ${path}`, 40003, 400);\n    }\n\n    // We need to split the path on unescaped dots, i.e. dots not preceded by a backslash.\n    // The easy way to do this would be to use \"path.split(/(?<!\\\\)\\./)\" to split on unescaped dots\n    // and then call \".replace(/\\\\\\./g, '.')\" on each segment.\n    // However, that uses negative lookbehind which is not supported in some browsers we aim to support\n    // (based on https://github.com/ably/ably-js/pull/2037/files), like Safari before 16.4.\n    // See full list https://caniuse.com/?search=negative%20lookbehind.\n    // So instead we do splitting manually.\n    const pathAsArray: string[] = [];\n    let currentSegment = '';\n    let escaping = false;\n    for (const char of path) {\n      if (escaping) {\n        // keep the escape character if not escaping a dot\n        // this is to replicate the \".replace(/\\\\\\./g, '.')\" behavior where only escaped dots are unescaped\n        if (char !== '.') currentSegment += '\\\\';\n        currentSegment += char;\n        escaping = false;\n        continue;\n      }\n      if (char === '\\\\') {\n        escaping = true;\n        continue;\n      }\n      if (char === '.') {\n        pathAsArray.push(currentSegment);\n        currentSegment = '';\n        continue;\n      }\n      currentSegment += char;\n    }\n    if (escaping) {\n      currentSegment += '\\\\';\n    }\n    pathAsArray.push(currentSegment);\n\n    return new DefaultPathObject(this._realtimeObject, this._root, pathAsArray, this) as unknown as PathObject<U>;\n  }\n\n  /**\n   * Get the current value at this path.\n   * If the path does not resolve to any specific entry, returns `undefined`.\n   */\n  value<U extends number | Primitive = number | Primitive>(): U | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    try {\n      const resolved = this._resolvePath(this._path);\n\n      if (resolved instanceof LiveObject) {\n        if (resolved instanceof LiveCounter) {\n          return resolved.value() as U;\n        }\n\n        // can't resolve value for other live object types\n        return undefined;\n      } else if (\n        this._client.Platform.BufferUtils.isBuffer(resolved) ||\n        typeof resolved === 'string' ||\n        typeof resolved === 'number' ||\n        typeof resolved === 'boolean' ||\n        typeof resolved === 'object' ||\n        resolved === null\n      ) {\n        // primitive type - return it\n        return resolved as U;\n      } else {\n        this._client.Logger.logAction(\n          this._client.logger,\n          this._client.Logger.LOG_MAJOR,\n          'PathObject.value()',\n          `unexpected value type at path, resolving to undefined; path=${this._escapePath(this._path).join('.')}`,\n        );\n        // unknown type - return undefined\n        return undefined;\n      }\n    } catch (error) {\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\n        // ignore path resolution errors and return undefined\n        return undefined;\n      }\n      // rethrow everything else\n      throw error;\n    }\n  }\n\n  instance<T extends Value = Value>(): Instance<T> | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    try {\n      return this._resolveInstance();\n    } catch (error) {\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\n        // ignore path resolution errors and return undefined\n        return undefined;\n      }\n      // rethrow everything else\n      throw error;\n    }\n  }\n\n  /**\n   * Returns an iterator of [key, value] pairs for LiveMap entries\n   */\n  *entries<U extends Record<string, Value>>(): IterableIterator<[keyof U, PathObject<U[keyof U]>]> {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    try {\n      const resolved = this._resolvePath(this._path);\n      if (!(resolved instanceof LiveMap)) {\n        // return empty iterator for non-LiveMap objects\n        return;\n      }\n\n      for (const [key, _] of resolved.entries()) {\n        const value = new DefaultPathObject(this._realtimeObject, this._root, [key], this) as unknown as PathObject<\n          U[keyof U]\n        >;\n        yield [key, value];\n      }\n    } catch (error) {\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\n        // ignore path resolution errors and return empty iterator\n        return;\n      }\n      // rethrow everything else\n      throw error;\n    }\n  }\n\n  /**\n   * Returns an iterator of keys for LiveMap entries\n   */\n  *keys<U extends Record<string, Value>>(): IterableIterator<keyof U> {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    try {\n      const resolved = this._resolvePath(this._path);\n      if (!(resolved instanceof LiveMap)) {\n        // return empty iterator for non-LiveMap objects\n        return;\n      }\n\n      yield* resolved.keys();\n    } catch (error) {\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\n        // ignore path resolution errors and return empty iterator\n        return;\n      }\n      // rethrow everything else\n      throw error;\n    }\n  }\n\n  /**\n   * Returns an iterator of PathObject values for LiveMap entries\n   */\n  *values<U extends Record<string, Value>>(): IterableIterator<PathObject<U[keyof U]>> {\n    for (const [_, value] of this.entries<U>()) {\n      yield value;\n    }\n  }\n\n  /**\n   * Returns the size of the collection at this path\n   */\n  size(): number | undefined {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n\n    try {\n      const resolved = this._resolvePath(this._path);\n      if (!(resolved instanceof LiveMap)) {\n        // can't return size for non-LiveMap objects\n        return undefined;\n      }\n\n      return resolved.size();\n    } catch (error) {\n      if (this._client.Utils.isErrorInfoOrPartialErrorInfo(error) && error.code === 92005) {\n        // ignore path resolution errors and return undefined\n        return undefined;\n      }\n      // rethrow everything else\n      throw error;\n    }\n  }\n\n  set<T extends Record<string, Value> = Record<string, Value>>(\n    key: keyof T & string,\n    value: T[keyof T],\n  ): Promise<void> {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n\n    const resolved = this._resolvePath(this._path);\n    if (!(resolved instanceof LiveMap)) {\n      throw new this._client.ErrorInfo(\n        `Cannot set a key on a non-LiveMap object at path: ${this._escapePath(this._path).join('.')}`,\n        92007,\n        400,\n      );\n    }\n\n    return resolved.set(key, value);\n  }\n\n  remove<T extends Record<string, Value> = Record<string, Value>>(key: keyof T & string): Promise<void> {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n\n    const resolved = this._resolvePath(this._path);\n    if (!(resolved instanceof LiveMap)) {\n      throw new this._client.ErrorInfo(\n        `Cannot remove a key from a non-LiveMap object at path: ${this._escapePath(this._path).join('.')}`,\n        92007,\n        400,\n      );\n    }\n\n    return resolved.remove(key);\n  }\n\n  increment(amount?: number): Promise<void> {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n\n    const resolved = this._resolvePath(this._path);\n    if (!(resolved instanceof LiveCounter)) {\n      throw new this._client.ErrorInfo(\n        `Cannot increment a non-LiveCounter object at path: ${this._escapePath(this._path).join('.')}`,\n        92007,\n        400,\n      );\n    }\n\n    return resolved.increment(amount ?? 1);\n  }\n\n  decrement(amount?: number): Promise<void> {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n\n    const resolved = this._resolvePath(this._path);\n    if (!(resolved instanceof LiveCounter)) {\n      throw new this._client.ErrorInfo(\n        `Cannot decrement a non-LiveCounter object at path: ${this._escapePath(this._path).join('.')}`,\n        92007,\n        400,\n      );\n    }\n\n    return resolved.decrement(amount ?? 1);\n  }\n\n  /**\n   * Subscribes to changes to the object (and, by default, its children) or to a primitive value at this path.\n   *\n   * PathObject subscriptions rely on LiveObject instances to broadcast updates through a subscription\n   * registry for the paths they occupy in the object graph. These updates are then routed to the appropriate\n   * PathObject subscriptions based on their paths.\n   *\n   * When the underlying object or primitive value at this path is changed via an update to its parent\n   * collection (for example, if a new LiveCounter instance is set at this path, or a key's value is\n   * changed in a parent LiveMap), a subscription to this path will receive a separate **non-bubbling**\n   * event indicating the change. This event is not propagated to parent path subscriptions, as they will\n   * receive their own event for changes made directly to the object at their respective paths.\n   *\n   * PathObject subscriptions observe nested changes by default. Optional `depth` parameter can be provided\n   * to control this behavior. A subscription depth of `1` means that only direct updates to the underlying\n   * object - and changes that overwrite the value at this path (via parent object updates) - will trigger events.\n   */\n\n  subscribe(\n    listener: EventCallback<PathObjectSubscriptionEvent>,\n    options?: PathObjectSubscriptionOptions,\n  ): Subscription {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n    return this._realtimeObject.getPathObjectSubscriptionRegister().subscribe(this._path, listener, options ?? {});\n  }\n\n  subscribeIterator(options?: PathObjectSubscriptionOptions): AsyncIterableIterator<PathObjectSubscriptionEvent> {\n    this._realtimeObject.throwIfInvalidAccessApiConfiguration();\n    return this._client.Utils.listenerToAsyncIterator((listener) => {\n      const { unsubscribe } = this.subscribe(listener, options);\n      return unsubscribe;\n    });\n  }\n\n  async batch<T extends LiveObjectType = LiveObjectType>(fn: BatchFunction<T>): Promise<void> {\n    this._realtimeObject.throwIfInvalidWriteApiConfiguration();\n\n    const instance = this._resolveInstance();\n    if (!instance) {\n      throw new this._client.ErrorInfo(\n        `Cannot batch operations on a non-LiveObject at path: ${this._escapePath(this._path).join('.')}`,\n        92007,\n        400,\n      );\n    }\n\n    const ctx = new RootBatchContext(this._realtimeObject, instance);\n    try {\n      fn(ctx as unknown as BatchContext<T>);\n      await ctx.flush();\n    } finally {\n      ctx.close();\n    }\n  }\n\n  private _resolvePath(path: string[]): Value {\n    let current: Value = this._root;\n\n    for (let i = 0; i < path.length; i++) {\n      const segment = path[i];\n\n      if (!(current instanceof LiveMap)) {\n        throw new this._client.ErrorInfo(\n          `Cannot resolve path segment '${segment}' on non-collection type at path: ${this._escapePath(path.slice(0, i)).join('.')}`,\n          92005,\n          400,\n        );\n      }\n\n      const next: Value | undefined = current.get(segment);\n\n      if (next === undefined) {\n        throw new this._client.ErrorInfo(\n          `Could not resolve value at path: ${this._escapePath(path.slice(0, i + 1)).join('.')}`,\n          92005,\n          400,\n        );\n      }\n\n      current = next;\n    }\n\n    return current;\n  }\n\n  private _resolveInstance<T extends Value = Value>(): Instance<T> | undefined {\n    const value = this._resolvePath(this._path);\n\n    if (value instanceof LiveObject) {\n      // only return an Instance for LiveObject values\n      return new DefaultInstance(this._realtimeObject, value) as unknown as Instance<T>;\n    }\n\n    // return undefined for non live objects\n    return undefined;\n  }\n\n  private _escapePath(path: string[]): string[] {\n    return path.map((x) => x.replace(/\\./g, '\\\\.'));\n  }\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type { EventCallback, Subscription } from '../../../ably';\nimport type { PathObjectSubscriptionEvent, PathObjectSubscriptionOptions } from '../../../liveobjects';\nimport { ObjectMessage } from './objectmessage';\nimport { DefaultPathObject } from './pathobject';\nimport { RealtimeObject } from './realtimeobject';\n\n/**\n * Internal subscription entry that tracks a listener and its options\n */\nexport interface SubscriptionEntry {\n  /** The listener function to call when events match */\n  listener: EventCallback<PathObjectSubscriptionEvent>;\n  /** The subscription options including depth */\n  options: PathObjectSubscriptionOptions;\n  /** The path this subscription is registered for */\n  path: string[];\n}\n\n/**\n * Event data that LiveObjects provide when notifying of changes\n */\nexport interface PathEvent {\n  /** The path where the event occurred */\n  path: string[];\n  /** Object message that caused this event */\n  message?: ObjectMessage;\n  /** Whether this event should bubble up to parent paths. Defaults to true if not specified. */\n  bubbles?: boolean;\n}\n\n/**\n * Registry for managing PathObject subscriptions and routing events to appropriate listeners.\n * Handles depth-based filtering for subscription matching.\n *\n * @internal\n */\nexport class PathObjectSubscriptionRegister {\n  private _client: BaseClient;\n  private _subscriptions: Map<string, SubscriptionEntry> = new Map();\n  private _nextSubscriptionId = 0;\n\n  constructor(private _realtimeObject: RealtimeObject) {\n    this._client = this._realtimeObject.getClient();\n  }\n\n  /**\n   * Registers a new subscription for the given path.\n   *\n   * @param path - Array of keys representing the path to subscribe to\n   * @param listener - Function to call when matching events occur\n   * @param options - Subscription options including depth parameter\n   * @returns Unsubscribe function\n   */\n  subscribe(\n    path: string[],\n    listener: EventCallback<PathObjectSubscriptionEvent>,\n    options: PathObjectSubscriptionOptions,\n  ): Subscription {\n    if (options == null || typeof options !== 'object') {\n      throw new this._client.ErrorInfo('Subscription options must be an object', 40000, 400);\n    }\n\n    if (options.depth !== undefined && options.depth <= 0) {\n      throw new this._client.ErrorInfo(\n        'Subscription depth must be greater than 0 or undefined for infinite depth',\n        40003,\n        400,\n      );\n    }\n\n    const subscriptionId = (this._nextSubscriptionId++).toString();\n    const entry: SubscriptionEntry = {\n      listener,\n      options,\n      path: [...path], // Make a copy to avoid external mutations\n    };\n\n    this._subscriptions.set(subscriptionId, entry);\n\n    return {\n      unsubscribe: () => {\n        this._subscriptions.delete(subscriptionId);\n      },\n    };\n  }\n\n  /**\n   * Notifies all matching subscriptions about an event that occurred at the specified path(s).\n   *\n   * @param events - Array of path events to process\n   */\n  notifyPathEvents(events: PathEvent[]): void {\n    for (const event of events) {\n      this._processEvent(event);\n    }\n  }\n\n  /**\n   * Processes a single path event and calls all matching subscription listeners.\n   */\n  private _processEvent(event: PathEvent): void {\n    for (const subscription of this._subscriptions.values()) {\n      if (!this._shouldNotifySubscription(subscription, event)) {\n        continue;\n      }\n\n      try {\n        const subscriptionEvent: PathObjectSubscriptionEvent = {\n          object: new DefaultPathObject(this._realtimeObject, this._realtimeObject.getPool().getRoot(), event.path),\n          message: event.message?.toUserFacingMessage(this._realtimeObject.getChannel()),\n        };\n\n        subscription.listener(subscriptionEvent);\n      } catch (error) {\n        // Log error but don't let one subscription failure affect others\n        this._client.Logger.logAction(\n          this._client.logger,\n          this._client.Logger.LOG_MINOR,\n          'PathObjectSubscriptionRegister._processEvent()',\n          `Error in PathObject subscription listener; path=${JSON.stringify(event.path)}, error=${error}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Determines if a subscription should be notified about an event at the given path.\n   * Implements depth-based filtering logic and bubbling control.\n   *\n   * Depth examples (when event.bubbles is true):\n   * - subscription at [\"users\"] with depth=undefined: matches [\"users\"], [\"users\", \"emma\"], [\"users\", \"emma\", \"visits\"], etc.\n   * - subscription at [\"users\"] with depth=1: matches [\"users\"] only\n   * - subscription at [\"users\"] with depth=2: matches [\"users\"], [\"users\", \"emma\"] only\n   * - subscription at [\"users\"] with depth=3: matches [\"users\"], [\"users\", \"emma\"], [\"users\", \"emma\", \"visits\"] only\n   *\n   * Non-bubbling examples (when event.bubbles is false):\n   * - Event at [\"users\", \"emma\"] with bubbles=false:\n   *   - subscription at [\"users\"]: NOT triggered (no bubbling to parent)\n   *   - subscription at [\"users\", \"emma\"]: triggered (exact path match)\n   *\n   * The depth calculation is: eventPath.length - subscriptionPath.length + 1\n   * This means:\n   * - Same level ([\"users\"] -> [\"users\"]): 1 - 1 + 1 = 1 (depth=1)\n   * - One level deeper ([\"users\"] -> [\"users\", \"emma\"]): 2 - 1 + 1 = 2 (depth=2)\n   * - Two levels deeper ([\"users\"] -> [\"users\", \"emma\", \"visits\"]): 3 - 1 + 1 = 3 (depth=3)\n   */\n  private _shouldNotifySubscription(subscription: SubscriptionEntry, event: PathEvent): boolean {\n    const subPath = subscription.path;\n    const eventPath = event.path;\n    const depth = subscription.options.depth;\n    const bubbles = event.bubbles !== false; // Default to true if not specified\n\n    // If event doesn't bubble, only match exact paths\n    if (!bubbles) {\n      return this._pathsAreEqual(eventPath, subPath);\n    }\n\n    // Otherwise check if the event path starts with the subscription path\n    if (!this._pathStartsWith(eventPath, subPath)) {\n      return false;\n    }\n\n    // If depth is undefined, allow infinite depth\n    if (depth === undefined) {\n      return true;\n    }\n\n    // Otherwise calculate the relative depth from subscription path to event path\n    const relativeDepth = eventPath.length - subPath.length + 1;\n\n    // Check if the event is within the allowed depth\n    return relativeDepth <= depth;\n  }\n\n  /**\n   * Checks if eventPath starts with subscriptionPath.\n   *\n   * @param eventPath - The path where the event occurred\n   * @param subscriptionPath - The path that was subscribed to\n   * @returns true if eventPath starts with subscriptionPath\n   */\n  private _pathStartsWith(eventPath: string[], subscriptionPath: string[]): boolean {\n    if (subscriptionPath.length > eventPath.length) {\n      return false;\n    }\n\n    for (let i = 0; i < subscriptionPath.length; i++) {\n      if (eventPath[i] !== subscriptionPath[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks if two paths are exactly equal.\n   *\n   * @param path1 - First path to compare\n   * @param path2 - Second path to compare\n   * @returns true if paths are exactly equal\n   */\n  private _pathsAreEqual(path1: string[], path2: string[]): boolean {\n    return this._client.Utils.arrEquals(path1, path2);\n  }\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type RealtimeChannel from 'common/lib/client/realtimechannel';\nimport { ObjectMessage } from './objectmessage';\nimport { RealtimeObject } from './realtimeobject';\n\nexport interface LiveObjectDataEntry {\n  objectMessage: ObjectMessage;\n  objectType: 'LiveMap' | 'LiveCounter';\n}\n\nexport interface LiveCounterDataEntry extends LiveObjectDataEntry {\n  objectType: 'LiveCounter';\n}\n\nexport interface LiveMapDataEntry extends LiveObjectDataEntry {\n  objectType: 'LiveMap';\n}\n\nexport type AnyDataEntry = LiveCounterDataEntry | LiveMapDataEntry;\n\n// TODO: investigate if this class is still needed after changes with createOp. objects are now initialized from the stateObject and this class does minimal processing\n/**\n * @internal\n */\nexport class SyncObjectsDataPool {\n  private _client: BaseClient;\n  private _channel: RealtimeChannel;\n  private _pool: Map<string, AnyDataEntry>;\n\n  constructor(private _realtimeObject: RealtimeObject) {\n    this._client = this._realtimeObject.getClient();\n    this._channel = this._realtimeObject.getChannel();\n    this._pool = new Map<string, AnyDataEntry>();\n  }\n\n  entries() {\n    return this._pool.entries();\n  }\n\n  size(): number {\n    return this._pool.size;\n  }\n\n  isEmpty(): boolean {\n    return this._pool.size === 0;\n  }\n\n  clear(): void {\n    this._pool.clear();\n  }\n\n  applyObjectSyncMessages(objectMessages: ObjectMessage[]): void {\n    for (const objectMessage of objectMessages) {\n      if (!objectMessage.object) {\n        this._client.Logger.logAction(\n          this._client.logger,\n          this._client.Logger.LOG_MAJOR,\n          'SyncObjectsDataPool.applyObjectSyncMessages()',\n          `object message is received during OBJECT_SYNC without 'object' field, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\n        );\n        continue;\n      }\n\n      const objectState = objectMessage.object;\n\n      if (objectState.counter) {\n        this._pool.set(objectState.objectId, this._createLiveCounterDataEntry(objectMessage));\n      } else if (objectState.map) {\n        this._pool.set(objectState.objectId, this._createLiveMapDataEntry(objectMessage));\n      } else {\n        this._client.Logger.logAction(\n          this._client.logger,\n          this._client.Logger.LOG_MAJOR,\n          'SyncObjectsDataPool.applyObjectSyncMessages()',\n          `received unsupported object state message during OBJECT_SYNC, expected 'counter' or 'map' to be present, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\n        );\n      }\n    }\n  }\n\n  private _createLiveCounterDataEntry(objectMessage: ObjectMessage): LiveCounterDataEntry {\n    const newEntry: LiveCounterDataEntry = {\n      objectMessage,\n      objectType: 'LiveCounter',\n    };\n\n    return newEntry;\n  }\n\n  private _createLiveMapDataEntry(objectMessage: ObjectMessage): LiveMapDataEntry {\n    const newEntry: LiveMapDataEntry = {\n      objectMessage,\n      objectType: 'LiveMap',\n    };\n\n    return newEntry;\n  }\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type RealtimeChannel from 'common/lib/client/realtimechannel';\nimport type EventEmitter from 'common/lib/util/eventemitter';\nimport type * as API from '../../../ably';\nimport type { ChannelState, StatusSubscription } from '../../../ably';\nimport type * as ObjectsApi from '../../../liveobjects';\nimport { DEFAULTS } from './defaults';\nimport { LiveCounter } from './livecounter';\nimport { LiveMap } from './livemap';\nimport { LiveObject, LiveObjectUpdate, LiveObjectUpdateNoop } from './liveobject';\nimport { ObjectMessage, ObjectOperationAction } from './objectmessage';\nimport { ObjectsPool } from './objectspool';\nimport { DefaultPathObject } from './pathobject';\nimport { PathObjectSubscriptionRegister } from './pathobjectsubscriptionregister';\nimport { SyncObjectsDataPool } from './syncobjectsdatapool';\n\nexport enum ObjectsEvent {\n  syncing = 'syncing',\n  synced = 'synced',\n}\n\n/** @spec RTO22 */\nexport enum ObjectsOperationSource {\n  local = 'local',\n  channel = 'channel',\n}\n\nexport enum ObjectsState {\n  initialized = 'initialized',\n  syncing = 'syncing',\n  synced = 'synced',\n}\n\nconst StateToEventsMap: Record<ObjectsState, ObjectsEvent | undefined> = {\n  initialized: undefined,\n  syncing: ObjectsEvent.syncing,\n  synced: ObjectsEvent.synced,\n};\n\nexport type ObjectsEventCallback = () => void;\n\nexport class RealtimeObject {\n  gcGracePeriod: number;\n\n  private _client: BaseClient;\n  private _channel: RealtimeChannel;\n  private _state: ObjectsState;\n  // composition over inheritance since we cannot import class directly into plugin code.\n  // instead we obtain a class type from the client\n  private _eventEmitterInternal: EventEmitter;\n  // related to RTC10, should have a separate EventEmitter for users of the library\n  private _eventEmitterPublic: EventEmitter;\n  private _objectsPool: ObjectsPool; // RTO3\n  private _syncObjectsDataPool: SyncObjectsDataPool;\n  private _currentSyncId: string | undefined;\n  private _currentSyncCursor: string | undefined;\n  private _bufferedObjectOperations: ObjectMessage[];\n  private _appliedOnAckSerials: Set<string>; // RTO7b\n  private _pathObjectSubscriptionRegister: PathObjectSubscriptionRegister;\n\n  // Used by tests\n  static _DEFAULTS = DEFAULTS;\n\n  constructor(channel: RealtimeChannel) {\n    this._channel = channel;\n    this._client = channel.client;\n    this._state = ObjectsState.initialized;\n    this._eventEmitterInternal = new this._client.EventEmitter(this._client.logger);\n    this._eventEmitterPublic = new this._client.EventEmitter(this._client.logger);\n    this._objectsPool = new ObjectsPool(this);\n    this._syncObjectsDataPool = new SyncObjectsDataPool(this);\n    this._bufferedObjectOperations = [];\n    this._appliedOnAckSerials = new Set(); // RTO7b1\n    this._pathObjectSubscriptionRegister = new PathObjectSubscriptionRegister(this);\n    // use server-provided objectsGCGracePeriod if available, and subscribe to new connectionDetails that can be emitted as part of the RTN24\n    this.gcGracePeriod =\n      this._channel.connectionManager.connectionDetails?.objectsGCGracePeriod ?? DEFAULTS.gcGracePeriod;\n    this._channel.connectionManager.on('connectiondetails', (details: Record<string, any>) => {\n      this.gcGracePeriod = details.objectsGCGracePeriod ?? DEFAULTS.gcGracePeriod;\n    });\n  }\n\n  /**\n   * When called without a type variable, we return a default root type which is based on globally defined interface for Objects feature.\n   * A user can provide an explicit type for the this method to explicitly set the type structure on this particular channel.\n   * This is useful when working with multiple channels with different underlying data structure.\n   */\n  async get<T extends Record<string, ObjectsApi.Value>>(): Promise<ObjectsApi.PathObject<ObjectsApi.LiveMap<T>>> {\n    this._throwIfMissingChannelMode('object_subscribe');\n\n    // implicit attach before proceeding\n    await this._channel.ensureAttached();\n\n    // if we're not synced yet, wait for sync sequence to finish before returning root\n    if (this._state !== ObjectsState.synced) {\n      await this._eventEmitterInternal.once(ObjectsEvent.synced); // RTO1c\n    }\n\n    const pathObject = new DefaultPathObject(this, this._objectsPool.getRoot(), []);\n    return pathObject;\n  }\n\n  on(event: ObjectsEvent, callback: ObjectsEventCallback): StatusSubscription {\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\n    this._eventEmitterPublic.on(event, callback);\n\n    const off = () => {\n      this._eventEmitterPublic.off(event, callback);\n    };\n\n    return { off };\n  }\n\n  off(event: ObjectsEvent, callback: ObjectsEventCallback): void {\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\n\n    // prevent accidentally calling .off without any arguments on an EventEmitter and removing all callbacks\n    if (this._client.Utils.isNil(event) && this._client.Utils.isNil(callback)) {\n      return;\n    }\n\n    this._eventEmitterPublic.off(event, callback);\n  }\n\n  /**\n   * @internal\n   */\n  getPool(): ObjectsPool {\n    return this._objectsPool;\n  }\n\n  /**\n   * @internal\n   */\n  getChannel(): RealtimeChannel {\n    return this._channel;\n  }\n\n  /**\n   * @internal\n   */\n  getClient(): BaseClient {\n    return this._client;\n  }\n\n  /**\n   * @internal\n   */\n  getPathObjectSubscriptionRegister(): PathObjectSubscriptionRegister {\n    return this._pathObjectSubscriptionRegister;\n  }\n\n  /**\n   * @internal\n   * @spec RTO5\n   */\n  handleObjectSyncMessages(objectMessages: ObjectMessage[], syncChannelSerial: string | null | undefined): void {\n    const { syncId, syncCursor } = this._parseSyncChannelSerial(syncChannelSerial); // RTO5a\n    const newSyncSequence = this._currentSyncId !== syncId;\n    if (newSyncSequence) {\n      // RTO5a2 - new sync sequence started\n      this._startNewSync(syncId, syncCursor); // RTO5a2a\n    }\n\n    // RTO5a3 - continue current sync sequence\n    this._syncObjectsDataPool.applyObjectSyncMessages(objectMessages); // RTO5b\n\n    // RTO5a4 - if this is the last (or only) message in a sequence of sync updates, end the sync\n    if (!syncCursor) {\n      this._endSync();\n    }\n  }\n\n  /**\n   * @internal\n   * @spec RTO8\n   */\n  handleObjectMessages(objectMessages: ObjectMessage[]): void {\n    if (this._state !== ObjectsState.synced) {\n      // The client receives object messages in realtime over the channel concurrently with the sync sequence.\n      // Some of the incoming object messages may have already been applied to the objects described in\n      // the sync sequence, but others may not; therefore we must buffer these messages so that we can apply\n      // them to the objects once the sync is complete.\n      this._bufferedObjectOperations.push(...objectMessages);\n      return;\n    }\n\n    this._applyObjectMessages(objectMessages, ObjectsOperationSource.channel); // RTO8b\n  }\n\n  /**\n   * @internal\n   * @spec RTO4\n   */\n  onAttached(hasObjects?: boolean): void {\n    this._client.Logger.logAction(\n      this._client.logger,\n      this._client.Logger.LOG_MINOR,\n      'RealtimeObject.onAttached()',\n      `channel=${this._channel.name}, hasObjects=${hasObjects}`,\n    );\n\n    // RTO4a\n    this._startNewSync();\n\n    // RTO4b\n    if (!hasObjects) {\n      // if no HAS_OBJECTS flag received on attach, we can end sync sequence immediately and treat it as no objects on a channel.\n      // reset the objects pool to its initial state, and emit update events so subscribers to root object get notified about changes.\n      this._objectsPool.resetToInitialPool(true); // RTO4b1, RTO4b2\n      this._syncObjectsDataPool.clear(); // RTO4b3\n      this._endSync(); // RTO4b4\n    }\n  }\n\n  /**\n   * @internal\n   */\n  actOnChannelState(state: ChannelState, hasObjects?: boolean): void {\n    switch (state) {\n      case 'attached':\n        this.onAttached(hasObjects);\n        break;\n\n      case 'detached':\n      case 'failed':\n        // do not emit data update events as the actual current state of Objects data is unknown when we're in these channel states\n        this._objectsPool.clearObjectsData(false);\n        this._syncObjectsDataPool.clear();\n        break;\n    }\n  }\n\n  /**\n   * @internal\n   * @spec RTO15\n   */\n  async publish(objectMessages: ObjectMessage[]): Promise<API.PublishResult> {\n    this._channel.throwIfUnpublishableState();\n\n    const encodedMsgs = objectMessages.map((x) => x.encode(this._client));\n    const maxMessageSize = this._client.options.maxMessageSize;\n    const size = encodedMsgs.reduce((acc, msg) => acc + msg.getMessageSize(), 0);\n    if (size > maxMessageSize) {\n      throw new this._client.ErrorInfo(\n        `Maximum size of object messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,\n        40009,\n        400,\n      );\n    }\n\n    // RTO15h\n    return this._channel.sendState(encodedMsgs);\n  }\n\n  /**\n   * Publishes ObjectMessages and applies them locally upon receiving the ACK from the server.\n   *\n   * @internal\n   * @spec RTO20\n   */\n  async publishAndApply(objectMessages: ObjectMessage[]): Promise<void> {\n    // RTO20b\n    const publishResult = await this.publish(objectMessages);\n\n    this._client.Logger.logAction(\n      this._client.logger,\n      this._client.Logger.LOG_MICRO,\n      'RealtimeObject.publishAndApply()',\n      `received ACK for ${objectMessages.length} message(s), applying locally; channel=${this._channel.name}`,\n    );\n\n    // RTO20c - check required information is available\n    const siteCode = this._channel.connectionManager.connectionDetails?.siteCode;\n    // RTO20c1\n    if (!siteCode) {\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_ERROR,\n        'RealtimeObject.publishAndApply()',\n        `operations will not be applied locally: siteCode not available from connectionDetails; channel=${this._channel.name}`,\n      );\n      return;\n    }\n    // RTO20c2\n    if (!publishResult.serials || publishResult.serials.length !== objectMessages.length) {\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_ERROR,\n        'RealtimeObject.publishAndApply()',\n        `operations will not be applied locally: PublishResult.serials has unexpected length (expected ${objectMessages.length}, got ${publishResult.serials?.length}); channel=${this._channel.name}`,\n      );\n      return;\n    }\n\n    // RTO20d\n    const syntheticMessages: ObjectMessage[] = [];\n    for (let i = 0; i < objectMessages.length; i++) {\n      const serial = publishResult.serials[i];\n\n      // RTO20d1\n      if (serial === null) {\n        this._client.Logger.logAction(\n          this._client.logger,\n          this._client.Logger.LOG_MICRO,\n          'RealtimeObject.publishAndApply()',\n          `operation will not be applied locally: serial is null in PublishResult (index ${i}); channel=${this._channel.name}`,\n        );\n        continue;\n      }\n\n      // RTO20d2, RTO20d3\n      syntheticMessages.push(\n        ObjectMessage.fromValues(\n          {\n            ...objectMessages[i],\n            serial, // RTO20d2a\n            siteCode, // RTO20d2b\n          },\n          this._client.Utils,\n          this._client.MessageEncoding,\n        ),\n      );\n    }\n\n    // RTO20e - Wait for sync to complete if not synced\n    if (this._state !== ObjectsState.synced) {\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'RealtimeObject.publishAndApply()',\n        `waiting for sync to complete before applying ${syntheticMessages.length} message(s); channel=${this._channel.name}`,\n      );\n\n      await new Promise<void>((resolve, reject) => {\n        const cleanup = () => {\n          this._eventEmitterInternal.off(onSynced);\n          this._channel.internalStateChanges.off(onChannelState);\n        };\n        const onSynced = () => {\n          cleanup();\n          resolve();\n        };\n        // RTO20e1\n        const onChannelState = () => {\n          cleanup();\n          reject(\n            new this._client.ErrorInfo(\n              `the operation could not be applied locally due to the channel entering the ${this._channel.state} state whilst waiting for objects sync to complete`,\n              92008,\n              400,\n              this._channel.errorReason || undefined,\n            ),\n          );\n        };\n        this._eventEmitterInternal.once(ObjectsEvent.synced, onSynced);\n        this._channel.internalStateChanges.once(['detached', 'suspended', 'failed'], onChannelState);\n      });\n    }\n\n    // RTO20f - Apply synthetic messages\n    this._client.Logger.logAction(\n      this._client.logger,\n      this._client.Logger.LOG_MICRO,\n      'RealtimeObject.publishAndApply()',\n      `applying ${syntheticMessages.length} message(s); channel=${this._channel.name}`,\n    );\n    this._applyObjectMessages(syntheticMessages, ObjectsOperationSource.local);\n  }\n\n  /**\n   * @internal\n   */\n  throwIfInvalidAccessApiConfiguration(): void {\n    this._throwIfMissingChannelMode('object_subscribe');\n    this._throwIfInChannelState(['detached', 'failed']);\n  }\n\n  /**\n   * @internal\n   */\n  throwIfInvalidWriteApiConfiguration(): void {\n    this._throwIfMissingChannelMode('object_publish');\n    this._throwIfInChannelState(['detached', 'failed', 'suspended']);\n    this._throwIfEchoMessagesDisabled();\n  }\n\n  private _startNewSync(syncId?: string, syncCursor?: string): void {\n    // need to discard all buffered object operation messages on new sync start\n    this._bufferedObjectOperations = [];\n    this._syncObjectsDataPool.clear();\n    this._currentSyncId = syncId;\n    this._currentSyncCursor = syncCursor;\n    this._stateChange(ObjectsState.syncing);\n  }\n\n  /** @spec RTO5c */\n  private _endSync(): void {\n    this._applySync();\n    // should apply buffered object operations after we applied the sync.\n    // can use regular object messages application logic\n    this._applyObjectMessages(this._bufferedObjectOperations, ObjectsOperationSource.channel); // RTO5c6\n\n    this._bufferedObjectOperations = [];\n    this._syncObjectsDataPool.clear(); // RTO5c4\n    this._currentSyncId = undefined; // RTO5c3\n    this._currentSyncCursor = undefined; // RTO5c3\n\n    // RTO5c9 - Clear appliedOnAckSerials\n    this._appliedOnAckSerials.clear();\n\n    this._stateChange(ObjectsState.synced);\n  }\n\n  private _parseSyncChannelSerial(syncChannelSerial: string | null | undefined): {\n    syncId: string | undefined;\n    syncCursor: string | undefined;\n  } {\n    let match: RegExpMatchArray | null;\n    let syncId: string | undefined = undefined;\n    let syncCursor: string | undefined = undefined;\n    // RTO5a1 - syncChannelSerial is a two-part identifier: <sequence id>:<cursor value>\n    if (syncChannelSerial && (match = syncChannelSerial.match(/^([\\w-]+):(.*)$/))) {\n      syncId = match[1];\n      syncCursor = match[2];\n    }\n\n    return {\n      syncId,\n      syncCursor,\n    };\n  }\n\n  private _applySync(): void {\n    if (this._syncObjectsDataPool.isEmpty()) {\n      return;\n    }\n\n    const receivedObjectIds = new Set<string>();\n    const existingObjectUpdates: {\n      object: LiveObject;\n      update: LiveObjectUpdate | LiveObjectUpdateNoop;\n    }[] = [];\n\n    // RTO5c1\n    for (const [objectId, entry] of this._syncObjectsDataPool.entries()) {\n      receivedObjectIds.add(objectId);\n      const existingObject = this._objectsPool.get(objectId);\n\n      // RTO5c1a\n      if (existingObject) {\n        const update = existingObject.overrideWithObjectState(entry.objectMessage); // RTO5c1a1\n        // store updates to call subscription callbacks for all of them once the sync sequence is completed.\n        // this will ensure that clients get notified about the changes only once everything has been applied.\n        existingObjectUpdates.push({ object: existingObject, update });\n        continue;\n      }\n\n      // RTO5c1b,\n      let newObject: LiveObject;\n      // assign to a variable so TS doesn't complain about 'never' type in the default case\n      const objectType = entry.objectType;\n      switch (objectType) {\n        case 'LiveCounter':\n          newObject = LiveCounter.fromObjectState(this, entry.objectMessage); // RTO5c1b1a\n          break;\n\n        case 'LiveMap':\n          newObject = LiveMap.fromObjectState(this, entry.objectMessage); // RTO5c1b1b\n          break;\n\n        default:\n          throw new this._client.ErrorInfo(`Unknown LiveObject type: ${objectType}`, 50000, 500); // RTO5c1b1c\n      }\n\n      this._objectsPool.set(objectId, newObject); // RTO5c1b1\n    }\n\n    // RTO5c2 - need to remove LiveObject instances from the ObjectsPool for which objectIds were not received during the sync sequence\n    this._objectsPool.deleteExtraObjectIds([...receivedObjectIds]);\n\n    // Rebuild all parent references after sync to ensure all object-to-object references are properly established\n    // This is necessary because objects may reference other objects that weren't in the pool when they were initially created\n    this._rebuildAllParentReferences();\n\n    // call subscription callbacks for all updated existing objects.\n    existingObjectUpdates.forEach(({ object, update }) => object.notifyUpdated(update));\n  }\n\n  /** @spec RTO9 */\n  private _applyObjectMessages(objectMessages: ObjectMessage[], source: ObjectsOperationSource): void {\n    for (const objectMessage of objectMessages) {\n      if (!objectMessage.operation) {\n        this._client.Logger.logAction(\n          this._client.logger,\n          this._client.Logger.LOG_MAJOR,\n          'RealtimeObject._applyObjectMessages()',\n          `object operation message is received without 'operation' field, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\n        );\n        continue;\n      }\n\n      const serial = objectMessage.serial;\n\n      // RTO9a3 - Skip if already applied on ACK\n      if (serial && this._appliedOnAckSerials.has(serial)) {\n        this._client.Logger.logAction(\n          this._client.logger,\n          this._client.Logger.LOG_MICRO,\n          'RealtimeObject._applyObjectMessages()',\n          `skipping message: already applied on ACK; serial=${serial}, channel=${this._channel.name}`,\n        );\n        this._appliedOnAckSerials.delete(serial);\n        continue;\n      }\n\n      const objectOperation = objectMessage.operation;\n\n      switch (objectOperation.action) {\n        case ObjectOperationAction.MAP_CREATE:\n        case ObjectOperationAction.COUNTER_CREATE:\n        case ObjectOperationAction.MAP_SET:\n        case ObjectOperationAction.MAP_REMOVE:\n        case ObjectOperationAction.COUNTER_INC:\n        case ObjectOperationAction.OBJECT_DELETE: {\n          // we can receive an op for an object id we don't have yet in the pool. instead of buffering such operations,\n          // we can create a zero-value object for the provided object id and apply the operation to that zero-value object.\n          // this also means that all objects are capable of applying the corresponding *_CREATE ops on themselves,\n          // since they need to be able to eventually initialize themselves from that *_CREATE op.\n          // so to simplify operations handling, we always try to create a zero-value object in the pool first,\n          // and then we can always apply the operation on the existing object in the pool.\n          this._objectsPool.createZeroValueObjectIfNotExists(objectOperation.objectId);\n          const applied = this._objectsPool\n            .get(objectOperation.objectId)!\n            .applyOperation(objectOperation, objectMessage, source); // RTO9a2a3\n\n          // RTO9a2a4\n          if (source === ObjectsOperationSource.local && applied && serial) {\n            this._appliedOnAckSerials.add(serial);\n          }\n          break;\n        }\n\n        default:\n          this._client.Logger.logAction(\n            this._client.logger,\n            this._client.Logger.LOG_MAJOR,\n            'RealtimeObject._applyObjectMessages()',\n            `received unsupported action in object operation message: ${objectOperation.action}, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\n          );\n      }\n    }\n  }\n\n  /** @spec RTO2 */\n  private _throwIfMissingChannelMode(expectedMode: 'object_subscribe' | 'object_publish'): void {\n    // RTO2a - channel.modes is only populated on channel attachment, so use it only if it is set\n    if (this._channel.modes != null && !this._channel.modes.includes(expectedMode)) {\n      throw new this._client.ErrorInfo(`\"${expectedMode}\" channel mode must be set for this operation`, 40024, 400); // RTO2a2\n    }\n    // RTO2b - otherwise as a best effort use user provided channel options\n    if (!this._client.Utils.allToLowerCase(this._channel.channelOptions.modes ?? []).includes(expectedMode)) {\n      throw new this._client.ErrorInfo(`\"${expectedMode}\" channel mode must be set for this operation`, 40024, 400); // RTO2b2\n    }\n  }\n\n  private _stateChange(state: ObjectsState): void {\n    if (this._state === state) {\n      return;\n    }\n\n    this._state = state;\n    const event = StateToEventsMap[state];\n    if (!event) {\n      return;\n    }\n\n    this._eventEmitterInternal.emit(event);\n    this._eventEmitterPublic.emit(event);\n  }\n\n  /**\n   * Rebuilds all parent references in the objects pool.\n   * This is necessary after sync operations where objects may reference other objects\n   * that weren't available when the initial parent references were established.\n   */\n  private _rebuildAllParentReferences(): void {\n    // First, clear all existing parent references\n    for (const object of this._objectsPool.getAll()) {\n      object.clearParentReferences();\n    }\n\n    // Then, rebuild parent references by examining all objects and their data\n    for (const object of this._objectsPool.getAll()) {\n      if (object instanceof LiveMap) {\n        // For LiveMaps, iterate through their entries and establish parent references\n        for (const [key, value] of object.entries()) {\n          if (value instanceof LiveObject) {\n            value.addParentReference(object, key);\n          }\n        }\n      }\n      // Note: LiveCounter doesn't reference other objects, so no special handling needed\n    }\n  }\n\n  private _throwIfInChannelState(channelState: ChannelState[]): void {\n    if (channelState.includes(this._channel.state)) {\n      throw this._client.ErrorInfo.fromValues(this._channel.invalidStateError());\n    }\n  }\n\n  private _throwIfEchoMessagesDisabled(): void {\n    if (this._channel.client.options.echoMessages === false) {\n      throw new this._channel.client.ErrorInfo(\n        `\"echoMessages\" client option must be enabled for this operation`,\n        40000,\n        400,\n      );\n    }\n  }\n}\n", "import { __livetype } from '../../../ably';\nimport { LiveCounter as PublicLiveCounter } from '../../../liveobjects';\nimport { LiveObject, LiveObjectData, LiveObjectUpdate, LiveObjectUpdateNoop } from './liveobject';\nimport { ObjectData, ObjectMessage, ObjectOperation, ObjectOperationAction, ObjectsCounterOp } from './objectmessage';\nimport { ObjectsOperationSource, RealtimeObject } from './realtimeobject';\n\nexport interface LiveCounterData extends LiveObjectData {\n  data: number; // RTLC3\n}\n\nexport interface LiveCounterUpdate extends LiveObjectUpdate {\n  update: { amount: number };\n  _type: 'LiveCounterUpdate';\n}\n\n/** @spec RTLC1, RTLC2 */\nexport class LiveCounter extends LiveObject<LiveCounterData, LiveCounterUpdate> implements PublicLiveCounter {\n  declare readonly [__livetype]: 'LiveCounter'; // type-only, unique symbol to satisfy branded interfaces, no JS emitted\n\n  /**\n   * Returns a {@link LiveCounter} instance with a 0 value.\n   *\n   * @internal\n   * @spec RTLC4\n   */\n  static zeroValue(realtimeObject: RealtimeObject, objectId: string): LiveCounter {\n    return new LiveCounter(realtimeObject, objectId);\n  }\n\n  /**\n   * Returns a {@link LiveCounter} instance based on the provided object state.\n   * The provided object state must hold a valid counter object data.\n   *\n   * @internal\n   */\n  static fromObjectState(realtimeObject: RealtimeObject, objectMessage: ObjectMessage): LiveCounter {\n    const obj = new LiveCounter(realtimeObject, objectMessage.object!.objectId);\n    obj.overrideWithObjectState(objectMessage);\n    return obj;\n  }\n\n  /**\n   * @internal\n   */\n  static createCounterIncMessage(realtimeObject: RealtimeObject, objectId: string, amount: number): ObjectMessage {\n    const client = realtimeObject.getClient();\n\n    if (typeof amount !== 'number' || !Number.isFinite(amount)) {\n      throw new client.ErrorInfo('Counter value increment should be a valid number', 40003, 400);\n    }\n\n    const msg = ObjectMessage.fromValues(\n      {\n        operation: {\n          action: ObjectOperationAction.COUNTER_INC,\n          objectId,\n          counterOp: { amount },\n        } as ObjectOperation<ObjectData>,\n      },\n      client.Utils,\n      client.MessageEncoding,\n    );\n\n    return msg;\n  }\n\n  /** @spec RTLC5 */\n  value(): number {\n    return this._dataRef.data; // RTLC5c\n  }\n\n  /**\n   * Send a COUNTER_INC operation to the realtime system to increment a value on this LiveCounter object.\n   *\n   * The change will be applied locally when the ACK is received from Realtime.\n   *\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message\n   * and applying the operation locally.\n   * @spec RTLC12\n   */\n  async increment(amount: number): Promise<void> {\n    const msg = LiveCounter.createCounterIncMessage(this._realtimeObject, this.getObjectId(), amount);\n    return this._realtimeObject.publishAndApply([msg]);\n  }\n\n  /**\n   * An alias for calling {@link LiveCounter.increment | LiveCounter.increment(-amount)}\n   */\n  async decrement(amount: number): Promise<void> {\n    // do an explicit type safety check here before negating the amount value,\n    // so we don't unintentionally change the type sent by a user\n    if (typeof amount !== 'number' || !Number.isFinite(amount)) {\n      throw new this._client.ErrorInfo('Counter value decrement should be a valid number', 40003, 400);\n    }\n\n    return this.increment(-amount);\n  }\n\n  /**\n   * @internal\n   * @spec RTLC7\n   */\n  applyOperation(op: ObjectOperation<ObjectData>, msg: ObjectMessage, source: ObjectsOperationSource): boolean {\n    if (op.objectId !== this.getObjectId()) {\n      throw new this._client.ErrorInfo(\n        `Cannot apply object operation with objectId=${op.objectId}, to this LiveCounter with objectId=${this.getObjectId()}`,\n        92000,\n        500,\n      );\n    }\n\n    const opSerial = msg.serial!;\n    const opSiteCode = msg.siteCode!;\n    if (!this._canApplyOperation(opSerial, opSiteCode)) {\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'LiveCounter.applyOperation()',\n        `skipping ${op.action} op: op serial ${opSerial.toString()} <= site serial ${this._siteTimeserials[opSiteCode]?.toString()}; objectId=${this.getObjectId()}`,\n      );\n      return false; // RTLC7b\n    }\n\n    // RTLC7c\n    if (source === ObjectsOperationSource.channel) {\n      // should update stored site serial immediately. doesn't matter if we successfully apply the op,\n      // as it's important to mark that the op was processed by the object\n      this._siteTimeserials[opSiteCode] = opSerial;\n    }\n\n    if (this.isTombstoned()) {\n      // this object is tombstoned so the operation cannot be applied\n      return false; // RTLC7e\n    }\n\n    let update: LiveCounterUpdate | LiveObjectUpdateNoop;\n    switch (op.action) {\n      case ObjectOperationAction.COUNTER_CREATE:\n        update = this._applyCounterCreate(op, msg);\n        break;\n\n      case ObjectOperationAction.COUNTER_INC:\n        if (this._client.Utils.isNil(op.counterOp)) {\n          this._throwNoPayloadError(op);\n        } else {\n          update = this._applyCounterInc(op.counterOp, msg);\n        }\n        break;\n\n      case ObjectOperationAction.OBJECT_DELETE:\n        update = this._applyObjectDelete(msg);\n        break;\n\n      default:\n        throw new this._client.ErrorInfo(\n          `Invalid ${op.action} op for LiveCounter objectId=${this.getObjectId()}`,\n          92000,\n          500,\n        );\n    }\n\n    this.notifyUpdated(update);\n    return true; // RTLC7d1b, RTLC7d2b, RTLC7d4b\n  }\n\n  /**\n   * @internal\n   * @spec RTLC6\n   */\n  overrideWithObjectState(objectMessage: ObjectMessage): LiveCounterUpdate | LiveObjectUpdateNoop {\n    const objectState = objectMessage.object;\n    if (objectState == null) {\n      throw new this._client.ErrorInfo(`Missing object state; LiveCounter objectId=${this.getObjectId()}`, 92000, 500);\n    }\n\n    if (objectState.objectId !== this.getObjectId()) {\n      throw new this._client.ErrorInfo(\n        `Invalid object state: object state objectId=${objectState.objectId}; LiveCounter objectId=${this.getObjectId()}`,\n        92000,\n        500,\n      );\n    }\n\n    if (!this._client.Utils.isNil(objectState.createOp)) {\n      // it is expected that create operation can be missing in the object state, so only validate it when it exists\n      if (objectState.createOp.objectId !== this.getObjectId()) {\n        throw new this._client.ErrorInfo(\n          `Invalid object state: object state createOp objectId=${objectState.createOp?.objectId}; LiveCounter objectId=${this.getObjectId()}`,\n          92000,\n          500,\n        );\n      }\n\n      if (objectState.createOp.action !== ObjectOperationAction.COUNTER_CREATE) {\n        throw new this._client.ErrorInfo(\n          `Invalid object state: object state createOp action=${objectState.createOp?.action}; LiveCounter objectId=${this.getObjectId()}`,\n          92000,\n          500,\n        );\n      }\n    }\n\n    // object's site serials are still updated even if it is tombstoned, so always use the site serials received from the operation.\n    // should default to empty map if site serials do not exist on the object state, so that any future operation may be applied to this object.\n    this._siteTimeserials = objectState.siteTimeserials ?? {}; // RTLC6a\n\n    if (this.isTombstoned()) {\n      // this object is tombstoned. this is a terminal state which can't be overridden. skip the rest of object state message processing\n      return { noop: true };\n    }\n\n    const previousDataRef = this._dataRef;\n    let update: LiveCounterUpdate;\n    if (objectState.tombstone) {\n      // tombstone this object and ignore the data from the object state message\n      update = this.tombstone(objectMessage);\n    } else {\n      // otherwise override data for this object with data from the object state\n      this._createOperationIsMerged = false; // RTLC6b\n      this._dataRef = { data: objectState.counter?.count ?? 0 }; // RTLC6c\n      // RTLC6d\n      if (!this._client.Utils.isNil(objectState.createOp)) {\n        this._mergeInitialDataFromCreateOperation(objectState.createOp, objectMessage);\n      }\n\n      // update will contain the diff between previous value and new value from object state\n      update = this._updateFromDataDiff(previousDataRef, this._dataRef);\n      update.objectMessage = objectMessage;\n    }\n\n    return update;\n  }\n\n  /**\n   * @internal\n   */\n  onGCInterval(): void {\n    // nothing to GC for a counter object\n    return;\n  }\n\n  /** @spec RTLC4 */\n  protected _getZeroValueData(): LiveCounterData {\n    return { data: 0 };\n  }\n\n  protected _updateFromDataDiff(prevDataRef: LiveCounterData, newDataRef: LiveCounterData): LiveCounterUpdate {\n    const counterDiff = newDataRef.data - prevDataRef.data;\n    return { update: { amount: counterDiff }, _type: 'LiveCounterUpdate' };\n  }\n\n  protected _mergeInitialDataFromCreateOperation(\n    objectOperation: ObjectOperation<ObjectData>,\n    msg: ObjectMessage,\n  ): LiveCounterUpdate {\n    // if a counter object is missing for the COUNTER_CREATE op, the initial value is implicitly 0 in this case.\n    // note that it is intentional to SUM the incoming count from the create op.\n    // if we got here, it means that current counter instance is missing the initial value in its data reference,\n    // which we're going to add now.\n    this._dataRef.data += objectOperation.counter?.count ?? 0; // RTLC6d1\n    this._createOperationIsMerged = true; // RTLC6d2\n\n    return {\n      update: { amount: objectOperation.counter?.count ?? 0 },\n      objectMessage: msg,\n      _type: 'LiveCounterUpdate',\n    };\n  }\n\n  private _throwNoPayloadError(op: ObjectOperation<ObjectData>): never {\n    throw new this._client.ErrorInfo(\n      `No payload found for ${op.action} op for LiveCounter objectId=${this.getObjectId()}`,\n      92000,\n      500,\n    );\n  }\n\n  private _applyCounterCreate(\n    op: ObjectOperation<ObjectData>,\n    msg: ObjectMessage,\n  ): LiveCounterUpdate | LiveObjectUpdateNoop {\n    if (this._createOperationIsMerged) {\n      // There can't be two different create operation for the same object id, because the object id\n      // fully encodes that operation. This means we can safely ignore any new incoming create operations\n      // if we already merged it once.\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'LiveCounter._applyCounterCreate()',\n        `skipping applying COUNTER_CREATE op on a counter instance as it was already applied before; objectId=${this.getObjectId()}`,\n      );\n      return { noop: true };\n    }\n\n    return this._mergeInitialDataFromCreateOperation(op, msg);\n  }\n\n  private _applyCounterInc(op: ObjectsCounterOp, msg: ObjectMessage): LiveCounterUpdate {\n    this._dataRef.data += op.amount;\n    return {\n      update: { amount: op.amount },\n      objectMessage: msg,\n      _type: 'LiveCounterUpdate',\n    };\n  }\n}\n", "import { dequal } from 'dequal';\n\nimport { __livetype } from '../../../ably';\nimport {\n  CompactedJsonValue,\n  CompactedValue,\n  Primitive,\n  LiveMap as PublicLiveMap,\n  LiveObject as PublicLiveObject,\n  Value,\n} from '../../../liveobjects';\nimport { LiveCounter } from './livecounter';\nimport { LiveCounterValueType } from './livecountervaluetype';\nimport { LiveMapValueType } from './livemapvaluetype';\nimport { LiveObject, LiveObjectData, LiveObjectUpdate, LiveObjectUpdateNoop } from './liveobject';\nimport {\n  ObjectData,\n  ObjectMessage,\n  ObjectOperation,\n  ObjectOperationAction,\n  ObjectsMapEntry,\n  ObjectsMapOp,\n  ObjectsMapSemantics,\n} from './objectmessage';\nimport { ObjectsOperationSource, RealtimeObject } from './realtimeobject';\n\nexport interface ObjectIdObjectData {\n  /** A reference to another object, used to support composable object structures. */\n  objectId: string;\n}\n\nexport interface ValueObjectData {\n  /** A decoded leaf value from {@link WireObjectData}. */\n  value: Primitive;\n}\n\nexport type LiveMapObjectData = ObjectIdObjectData | ValueObjectData;\n\nexport interface LiveMapEntry {\n  tombstone: boolean;\n  tombstonedAt: number | undefined;\n  timeserial: string | undefined;\n  data: LiveMapObjectData | undefined;\n}\n\nexport interface LiveMapData extends LiveObjectData {\n  data: Map<string, LiveMapEntry>; // RTLM3\n}\n\nexport interface LiveMapUpdate<T extends Record<string, Value>> extends LiveObjectUpdate {\n  update: { [keyName in keyof T & string]?: 'updated' | 'removed' };\n  _type: 'LiveMapUpdate';\n}\n\n/** @spec RTLM1, RTLM2 */\nexport class LiveMap<T extends Record<string, Value> = Record<string, Value>>\n  extends LiveObject<LiveMapData, LiveMapUpdate<T>>\n  implements PublicLiveMap<T>\n{\n  declare readonly [__livetype]: 'LiveMap'; // type-only, unique symbol to satisfy branded interfaces, no JS emitted\n\n  constructor(\n    realtimeObject: RealtimeObject,\n    private _semantics: ObjectsMapSemantics,\n    objectId: string,\n  ) {\n    super(realtimeObject, objectId);\n  }\n\n  /**\n   * Returns a {@link LiveMap} instance with an empty map data.\n   *\n   * @internal\n   * @spec RTLM4\n   */\n  static zeroValue(realtimeObject: RealtimeObject, objectId: string): LiveMap {\n    return new LiveMap(realtimeObject, ObjectsMapSemantics.LWW, objectId);\n  }\n\n  /**\n   * Returns a {@link LiveMap} instance based on the provided object state.\n   * The provided object state must hold a valid map object data.\n   *\n   * @internal\n   */\n  static fromObjectState(realtimeObject: RealtimeObject, objectMessage: ObjectMessage): LiveMap {\n    const obj = new LiveMap(realtimeObject, objectMessage.object!.map!.semantics!, objectMessage.object!.objectId);\n    obj.overrideWithObjectState(objectMessage);\n    return obj;\n  }\n\n  /**\n   * @internal\n   */\n  static async createMapSetMessage(\n    realtimeObject: RealtimeObject,\n    objectId: string,\n    key: string,\n    value: Value,\n  ): Promise<ObjectMessage[]> {\n    const client = realtimeObject.getClient();\n\n    LiveMap.validateKeyValue(realtimeObject, key, value);\n\n    let objectData: LiveMapObjectData;\n    let createValueTypesMessages: ObjectMessage[] = [];\n\n    if (LiveCounterValueType.instanceof(value)) {\n      const counterCreateMsg = await LiveCounterValueType.createCounterCreateMessage(realtimeObject, value);\n      createValueTypesMessages = [counterCreateMsg];\n\n      const typedObjectData: ObjectIdObjectData = { objectId: counterCreateMsg.operation?.objectId! };\n      objectData = typedObjectData;\n    } else if (LiveMapValueType.instanceof(value)) {\n      const { mapCreateMsg, nestedObjectsCreateMsgs } = await LiveMapValueType.createMapCreateMessage(\n        realtimeObject,\n        value,\n      );\n      createValueTypesMessages = [...nestedObjectsCreateMsgs, mapCreateMsg];\n\n      const typedObjectData: ObjectIdObjectData = { objectId: mapCreateMsg.operation?.objectId! };\n      objectData = typedObjectData;\n    } else {\n      const typedObjectData: ValueObjectData = { value: value as Primitive };\n      objectData = typedObjectData;\n    }\n\n    const mapSetMsg = ObjectMessage.fromValues(\n      {\n        operation: {\n          action: ObjectOperationAction.MAP_SET,\n          objectId,\n          mapOp: {\n            key,\n            data: objectData,\n          },\n        } as ObjectOperation<ObjectData>,\n      },\n      client.Utils,\n      client.MessageEncoding,\n    );\n\n    return [...createValueTypesMessages, mapSetMsg];\n  }\n\n  /**\n   * @internal\n   */\n  static createMapRemoveMessage(realtimeObject: RealtimeObject, objectId: string, key: string): ObjectMessage {\n    const client = realtimeObject.getClient();\n\n    if (typeof key !== 'string') {\n      throw new client.ErrorInfo('Map key should be string', 40003, 400);\n    }\n\n    const msg = ObjectMessage.fromValues(\n      {\n        operation: {\n          action: ObjectOperationAction.MAP_REMOVE,\n          objectId,\n          mapOp: { key },\n        } as ObjectOperation<ObjectData>,\n      },\n      client.Utils,\n      client.MessageEncoding,\n    );\n\n    return msg;\n  }\n\n  /**\n   * @internal\n   */\n  static validateKeyValue(realtimeObject: RealtimeObject, key: string, value: Value): void {\n    const client = realtimeObject.getClient();\n\n    if (typeof key !== 'string') {\n      throw new client.ErrorInfo('Map key should be string', 40003, 400);\n    }\n\n    if (\n      value === null ||\n      (typeof value !== 'string' &&\n        typeof value !== 'number' &&\n        typeof value !== 'boolean' &&\n        typeof value !== 'object')\n    ) {\n      throw new client.ErrorInfo('Map value data type is unsupported', 40013, 400); // OD4a\n    }\n  }\n\n  /**\n   * Returns the value associated with the specified key in the underlying Map object.\n   *\n   * - If this map object is tombstoned (deleted), `undefined` is returned.\n   * - If no entry is associated with the specified key, `undefined` is returned.\n   * - If map entry is tombstoned (deleted), `undefined` is returned.\n   * - If the value associated with the provided key is an objectId string of another LiveObject, a reference to that LiveObject\n   * is returned, provided it exists in the local pool and is not tombstoned. Otherwise, `undefined` is returned.\n   * - If the value is not an objectId, then that value is returned.\n   *\n   * @spec RTLM5, RTLM5a\n   */\n  // force the key to be of type string as we only allow strings as key in a map\n  get<TKey extends keyof T & string>(key: TKey): T[TKey] | undefined {\n    if (this.isTombstoned()) {\n      return undefined;\n    }\n\n    const element = this._dataRef.data.get(key);\n\n    // RTLM5d1\n    if (element === undefined) {\n      return undefined;\n    }\n\n    // RTLM5d2a\n    if (element.tombstone === true) {\n      return undefined;\n    }\n\n    // data always exists for non-tombstoned elements\n    return this._getResolvedValueFromObjectData(element.data!) as T[TKey];\n  }\n\n  size(): number {\n    let size = 0;\n    for (const value of this._dataRef.data.values()) {\n      if (this._isMapEntryTombstoned(value)) {\n        // should not count tombstoned entries\n        continue;\n      }\n\n      size++;\n    }\n\n    return size;\n  }\n\n  *entries<TKey extends keyof T & string>(): IterableIterator<[TKey, T[TKey]]> {\n    for (const [key, entry] of this._dataRef.data.entries()) {\n      if (this._isMapEntryTombstoned(entry)) {\n        // do not return tombstoned entries\n        continue;\n      }\n\n      // data always exists for non-tombstoned elements\n      const value = this._getResolvedValueFromObjectData(entry.data!) as T[TKey];\n      yield [key as TKey, value];\n    }\n  }\n\n  *keys<TKey extends keyof T & string>(): IterableIterator<TKey> {\n    for (const [key] of this.entries<TKey>()) {\n      yield key;\n    }\n  }\n\n  *values<TKey extends keyof T & string>(): IterableIterator<T[TKey]> {\n    for (const [_, value] of this.entries<TKey>()) {\n      yield value;\n    }\n  }\n\n  /**\n   * Send a MAP_SET operation to the realtime system to set a key on this LiveMap object to a specified value.\n   *\n   * The change will be applied locally when the ACK is received from Realtime.\n   *\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message\n   * and applying the operation locally.\n   * @spec RTLM20\n   */\n  async set<TKey extends keyof T & string>(\n    key: TKey,\n    value: T[TKey] | LiveCounterValueType | LiveMapValueType,\n  ): Promise<void> {\n    const msgs = await LiveMap.createMapSetMessage(this._realtimeObject, this.getObjectId(), key, value);\n    return this._realtimeObject.publishAndApply(msgs);\n  }\n\n  /**\n   * Send a MAP_REMOVE operation to the realtime system to tombstone a key on this LiveMap object.\n   *\n   * The change will be applied locally when the ACK is received from Realtime.\n   *\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message\n   * and applying the operation locally.\n   * @spec RTLM21\n   */\n  async remove<TKey extends keyof T & string>(key: TKey): Promise<void> {\n    const msg = LiveMap.createMapRemoveMessage(this._realtimeObject, this.getObjectId(), key);\n    return this._realtimeObject.publishAndApply([msg]);\n  }\n\n  /**\n   * @internal\n   * @spec RTLM15\n   */\n  applyOperation(op: ObjectOperation<ObjectData>, msg: ObjectMessage, source: ObjectsOperationSource): boolean {\n    if (op.objectId !== this.getObjectId()) {\n      throw new this._client.ErrorInfo(\n        `Cannot apply object operation with objectId=${op.objectId}, to this LiveMap with objectId=${this.getObjectId()}`,\n        92000,\n        500,\n      );\n    }\n\n    const opSerial = msg.serial!;\n    const opSiteCode = msg.siteCode!;\n    if (!this._canApplyOperation(opSerial, opSiteCode)) {\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'LiveMap.applyOperation()',\n        `skipping ${op.action} op: op serial ${opSerial.toString()} <= site serial ${this._siteTimeserials[opSiteCode]?.toString()}; objectId=${this.getObjectId()}`,\n      );\n      return false; // RTLM15b\n    }\n\n    // RTLM15c\n    if (source === ObjectsOperationSource.channel) {\n      // should update stored site serial immediately. doesn't matter if we successfully apply the op,\n      // as it's important to mark that the op was processed by the object\n      this._siteTimeserials[opSiteCode] = opSerial;\n    }\n\n    if (this.isTombstoned()) {\n      // this object is tombstoned so the operation cannot be applied\n      return false; // RTLM15e\n    }\n\n    let update: LiveMapUpdate<T> | LiveObjectUpdateNoop;\n    switch (op.action) {\n      case ObjectOperationAction.MAP_CREATE:\n        update = this._applyMapCreate(op, msg);\n        break;\n\n      case ObjectOperationAction.MAP_SET:\n        if (this._client.Utils.isNil(op.mapOp)) {\n          this._throwNoPayloadError(op);\n        } else {\n          update = this._applyMapSet(op.mapOp, opSerial, msg);\n        }\n        break;\n\n      case ObjectOperationAction.MAP_REMOVE:\n        if (this._client.Utils.isNil(op.mapOp)) {\n          this._throwNoPayloadError(op);\n        } else {\n          update = this._applyMapRemove(op.mapOp, opSerial, msg.serialTimestamp, msg);\n        }\n        break;\n\n      case ObjectOperationAction.OBJECT_DELETE:\n        update = this._applyObjectDelete(msg);\n        break;\n\n      default:\n        throw new this._client.ErrorInfo(\n          `Invalid ${op.action} op for LiveMap objectId=${this.getObjectId()}`,\n          92000,\n          500,\n        );\n    }\n\n    this.notifyUpdated(update);\n    return true; // RTLM15d1b, RTLM15d2b, RTLM15d3b, RTLM15d5b\n  }\n\n  /**\n   * @internal\n   * @spec RTLM6\n   */\n  overrideWithObjectState(objectMessage: ObjectMessage): LiveMapUpdate<T> | LiveObjectUpdateNoop {\n    const objectState = objectMessage.object;\n    if (objectState == null) {\n      throw new this._client.ErrorInfo(`Missing object state; LiveMap objectId=${this.getObjectId()}`, 92000, 500);\n    }\n\n    if (objectState.objectId !== this.getObjectId()) {\n      throw new this._client.ErrorInfo(\n        `Invalid object state: object state objectId=${objectState.objectId}; LiveMap objectId=${this.getObjectId()}`,\n        92000,\n        500,\n      );\n    }\n\n    if (objectState.map?.semantics !== this._semantics) {\n      throw new this._client.ErrorInfo(\n        `Invalid object state: object state map semantics=${objectState.map?.semantics}; LiveMap semantics=${this._semantics}`,\n        92000,\n        500,\n      );\n    }\n\n    if (!this._client.Utils.isNil(objectState.createOp)) {\n      // it is expected that create operation can be missing in the object state, so only validate it when it exists\n      if (objectState.createOp.objectId !== this.getObjectId()) {\n        throw new this._client.ErrorInfo(\n          `Invalid object state: object state createOp objectId=${objectState.createOp?.objectId}; LiveMap objectId=${this.getObjectId()}`,\n          92000,\n          500,\n        );\n      }\n\n      if (objectState.createOp.action !== ObjectOperationAction.MAP_CREATE) {\n        throw new this._client.ErrorInfo(\n          `Invalid object state: object state createOp action=${objectState.createOp?.action}; LiveMap objectId=${this.getObjectId()}`,\n          92000,\n          500,\n        );\n      }\n\n      if (objectState.createOp.map?.semantics !== this._semantics) {\n        throw new this._client.ErrorInfo(\n          `Invalid object state: object state createOp map semantics=${objectState.createOp.map?.semantics}; LiveMap semantics=${this._semantics}`,\n          92000,\n          500,\n        );\n      }\n    }\n\n    // object's site serials are still updated even if it is tombstoned, so always use the site serials received from the op.\n    // should default to empty map if site serials do not exist on the object state, so that any future operation may be applied to this object.\n    this._siteTimeserials = objectState.siteTimeserials ?? {}; // RTLM6a\n\n    if (this.isTombstoned()) {\n      // this object is tombstoned. this is a terminal state which can't be overridden. skip the rest of object state message processing\n      return { noop: true };\n    }\n\n    const previousDataRef = this._dataRef;\n    let update: LiveMapUpdate<T>;\n    if (objectState.tombstone) {\n      // tombstone this object and ignore the data from the object state message\n      update = this.tombstone(objectMessage);\n    } else {\n      // otherwise override data for this object with data from the object state\n      this._createOperationIsMerged = false; // RTLM6b\n      this._dataRef = this._liveMapDataFromMapEntries(objectState.map?.entries ?? {}); // RTLM6c\n      // RTLM6d\n      if (!this._client.Utils.isNil(objectState.createOp)) {\n        this._mergeInitialDataFromCreateOperation(objectState.createOp, objectMessage);\n      }\n\n      // update will contain the diff between previous value and new value from object state\n      update = this._updateFromDataDiff(previousDataRef, this._dataRef);\n      update.objectMessage = objectMessage;\n    }\n\n    // Update parent references based on the calculated diff\n    this._updateParentReferencesFromUpdate(update, previousDataRef);\n\n    return update;\n  }\n\n  /**\n   * @internal\n   */\n  onGCInterval(): void {\n    // should remove any tombstoned entries from the underlying map data that have exceeded the GC grace period\n\n    const keysToDelete: string[] = [];\n    for (const [key, value] of this._dataRef.data.entries()) {\n      if (value.tombstone === true && Date.now() - value.tombstonedAt! >= this._realtimeObject.gcGracePeriod) {\n        keysToDelete.push(key);\n      }\n    }\n\n    keysToDelete.forEach((x) => this._dataRef.data.delete(x));\n  }\n\n  /**\n   * Override clearData to handle parent reference cleanup when this LiveMap is tombstoned.\n   *\n   * @internal\n   */\n  clearData(): LiveMapUpdate<T> {\n    // Remove all parent references for objects this map was referencing\n    for (const [key, entry] of this._dataRef.data.entries()) {\n      if (entry.data && 'objectId' in entry.data) {\n        const referencedObject = this._realtimeObject.getPool().get(entry.data.objectId);\n        if (referencedObject) {\n          referencedObject.removeParentReference(this, key);\n        }\n      }\n    }\n\n    // Call the parent clearData method\n    return super.clearData();\n  }\n\n  /**\n   * Returns an in-memory JavaScript object representation of this LiveMap.\n   * LiveMap values are recursively compacted using their own compact methods.\n   * Compacted LiveMaps are memoized to handle cyclic references (returned as in-memory pointers).\n   *\n   * Use compactJson() for a JSON-serializable representation.\n   *\n   * @internal\n   */\n  compact(visitedObjects?: Map<string, Record<string, any>>): CompactedValue<PublicLiveMap<T>> {\n    const visited = visitedObjects ?? new Map<string, Record<string, any>>();\n    const result: Record<keyof T, any> = {} as Record<keyof T, any>;\n\n    // Memoize the compacted result to handle circular references\n    visited.set(this.getObjectId(), result);\n\n    // Use public entries() method to ensure we only include publicly exposed properties\n    for (const [key, value] of this.entries()) {\n      if (value instanceof LiveMap) {\n        if (visited.has(value.getObjectId())) {\n          // If the LiveMap has already been visited, just reference it to avoid infinite loops\n          result[key] = visited.get(value.getObjectId());\n        } else {\n          // Otherwise, compact it\n          result[key] = value.compact(visited);\n        }\n        continue;\n      }\n\n      if (value instanceof LiveCounter) {\n        result[key] = value.value();\n        continue;\n      }\n\n      // other values are returned as-is\n      result[key] = value;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns a JSON-serializable representation of this LiveMap.\n   * LiveMap values are recursively compacted using their own compactJson methods.\n   * Cyclic references are represented as `{ objectId: string }` instead of in-memory pointers.\n   * Buffers are converted to base64 strings.\n   *\n   * Use compact() for an in-memory representation.\n   *\n   * @internal\n   */\n  compactJson(visitedObjectIds?: Set<string>): CompactedJsonValue<PublicLiveMap<T>> {\n    const visited = visitedObjectIds ?? new Set<string>();\n    const result: Record<keyof T, any> = {} as Record<keyof T, any>;\n\n    // Mark this object ID as visited to handle circular references\n    visited.add(this.getObjectId());\n\n    // Use public entries() method to ensure we only include publicly exposed properties\n    for (const [key, value] of this.entries()) {\n      if (value instanceof LiveMap) {\n        if (visited.has(value.getObjectId())) {\n          // If the LiveMap has already been visited, return its objectId to avoid infinite loops\n          result[key] = { objectId: value.getObjectId() };\n        } else {\n          // Otherwise, compact it\n          result[key] = value.compactJson(visited);\n        }\n        continue;\n      }\n\n      if (value instanceof LiveCounter) {\n        result[key] = value.value();\n        continue;\n      }\n\n      // Convert buffers to base64 strings\n      if (this._client.Platform.BufferUtils.isBuffer(value)) {\n        result[key] = this._client.Platform.BufferUtils.base64Encode(value);\n        continue;\n      }\n\n      // Other values return as is\n      result[key] = value;\n    }\n\n    return result;\n  }\n\n  /** @spec RTLM4 */\n  protected _getZeroValueData(): LiveMapData {\n    return { data: new Map<string, LiveMapEntry>() };\n  }\n\n  protected _updateFromDataDiff(prevDataRef: LiveMapData, newDataRef: LiveMapData): LiveMapUpdate<T> {\n    const update: LiveMapUpdate<T> = { update: {}, _type: 'LiveMapUpdate' };\n\n    for (const [key, currentEntry] of prevDataRef.data.entries()) {\n      const typedKey: keyof T & string = key;\n      // any non-tombstoned properties that exist on a current map, but not in the new data - got removed\n      if (currentEntry.tombstone === false && !newDataRef.data.has(typedKey)) {\n        update.update[typedKey] = 'removed';\n      }\n    }\n\n    for (const [key, newEntry] of newDataRef.data.entries()) {\n      const typedKey: keyof T & string = key;\n      if (!prevDataRef.data.has(typedKey)) {\n        // if property does not exist in the current map, but new data has it as a non-tombstoned property - got updated\n        if (newEntry.tombstone === false) {\n          update.update[typedKey] = 'updated';\n          continue;\n        }\n\n        // otherwise, if new data has this prop tombstoned - do nothing, as property didn't exist anyway\n        if (newEntry.tombstone === true) {\n          continue;\n        }\n      }\n\n      // properties that exist both in current and new map data need to have their values compared to decide on the update type\n      const currentEntry = prevDataRef.data.get(typedKey)!;\n\n      // compare tombstones first\n      if (currentEntry.tombstone === true && newEntry.tombstone === false) {\n        // current prop is tombstoned, but new is not. it means prop was updated to a meaningful value\n        update.update[typedKey] = 'updated';\n        continue;\n      }\n      if (currentEntry.tombstone === false && newEntry.tombstone === true) {\n        // current prop is not tombstoned, but new is. it means prop was removed\n        update.update[typedKey] = 'removed';\n        continue;\n      }\n      if (currentEntry.tombstone === true && newEntry.tombstone === true) {\n        // both props are tombstoned - treat as noop, as there is no data to compare.\n        continue;\n      }\n\n      // both props exist and are not tombstoned, need to compare values with deep equals to see if it was changed\n      const valueChanged = !dequal(currentEntry.data, newEntry.data);\n      if (valueChanged) {\n        update.update[typedKey] = 'updated';\n        continue;\n      }\n    }\n\n    return update;\n  }\n\n  protected _mergeInitialDataFromCreateOperation(\n    objectOperation: ObjectOperation<ObjectData>,\n    msg: ObjectMessage,\n  ): LiveMapUpdate<T> {\n    if (this._client.Utils.isNil(objectOperation.map)) {\n      // if a map object is missing for the MAP_CREATE op, the initial value is implicitly an empty map.\n      // in this case there is nothing to merge into the current map, so we can just end processing the op.\n      return { update: {}, objectMessage: msg, _type: 'LiveMapUpdate' };\n    }\n\n    const aggregatedUpdate: LiveMapUpdate<T> = {\n      update: {},\n      objectMessage: msg,\n      _type: 'LiveMapUpdate',\n    };\n    // RTLM6d1\n    // in order to apply MAP_CREATE op for an existing map, we should merge their underlying entries keys.\n    // we can do this by iterating over entries from MAP_CREATE op and apply changes on per-key basis as if we had MAP_SET, MAP_REMOVE operations.\n    Object.entries(objectOperation.map.entries ?? {}).forEach(([key, entry]) => {\n      // for a MAP_CREATE operation we must use the serial value available on an entry, instead of a serial on a message\n      const opSerial = entry.timeserial;\n      let update: LiveMapUpdate<T> | LiveObjectUpdateNoop;\n      if (entry.tombstone === true) {\n        // RTLM6d1b - entry in MAP_CREATE op is removed, try to apply MAP_REMOVE op\n        update = this._applyMapRemove({ key }, opSerial, entry.serialTimestamp, msg);\n      } else {\n        // RTLM6d1a - entry in MAP_CREATE op is not removed, try to set it via MAP_SET op\n        update = this._applyMapSet({ key, data: entry.data }, opSerial, msg);\n      }\n\n      // skip noop updates\n      if ((update as LiveObjectUpdateNoop).noop) {\n        return;\n      }\n\n      // otherwise copy update data to aggregated update\n      Object.assign(aggregatedUpdate.update, update.update);\n    });\n\n    this._createOperationIsMerged = true; // RTLM6d2\n\n    return aggregatedUpdate;\n  }\n\n  private _throwNoPayloadError(op: ObjectOperation<ObjectData>): never {\n    throw new this._client.ErrorInfo(\n      `No payload found for ${op.action} op for LiveMap objectId=${this.getObjectId()}`,\n      92000,\n      500,\n    );\n  }\n\n  private _applyMapCreate(\n    op: ObjectOperation<ObjectData>,\n    msg: ObjectMessage,\n  ): LiveMapUpdate<T> | LiveObjectUpdateNoop {\n    if (this._createOperationIsMerged) {\n      // There can't be two different create operation for the same object id, because the object id\n      // fully encodes that operation. This means we can safely ignore any new incoming create operations\n      // if we already merged it once.\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'LiveMap._applyMapCreate()',\n        `skipping applying MAP_CREATE op on a map instance as it was already applied before; objectId=${this.getObjectId()}`,\n      );\n      return { noop: true };\n    }\n\n    if (this._semantics !== op.map?.semantics) {\n      throw new this._client.ErrorInfo(\n        `Cannot apply MAP_CREATE op on LiveMap objectId=${this.getObjectId()}; map's semantics=${this._semantics}, but op expected ${op.map?.semantics}`,\n        92000,\n        500,\n      );\n    }\n\n    return this._mergeInitialDataFromCreateOperation(op, msg);\n  }\n\n  /** @spec RTLM7 */\n  private _applyMapSet(\n    op: ObjectsMapOp<ObjectData>,\n    opSerial: string | undefined,\n    msg: ObjectMessage,\n  ): LiveMapUpdate<T> | LiveObjectUpdateNoop {\n    const { ErrorInfo, Utils } = this._client;\n\n    const existingEntry = this._dataRef.data.get(op.key);\n    // RTLM7a\n    if (existingEntry && !this._canApplyMapOperation(existingEntry.timeserial, opSerial)) {\n      // RTLM7a1 - the operation's serial <= the entry's serial, ignore the operation.\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'LiveMap._applyMapSet()',\n        `skipping update for key=\"${op.key}\": op serial ${opSerial?.toString()} <= entry serial ${existingEntry.timeserial?.toString()}; objectId=${this.getObjectId()}`,\n      );\n      return { noop: true };\n    }\n\n    if (Utils.isNil(op.data) || (Utils.isNil(op.data.objectId) && Utils.isNil(op.data.value))) {\n      throw new ErrorInfo(\n        `Invalid object data for MAP_SET op on objectId=${this.getObjectId()} on key=\"${op.key}\"`,\n        92000,\n        500,\n      );\n    }\n\n    let liveData: LiveMapObjectData;\n    // RTLM7c\n    if (!Utils.isNil(op.data.objectId)) {\n      liveData = { objectId: op.data.objectId } as ObjectIdObjectData;\n      // this MAP_SET op is setting a key to point to another object via its object id,\n      // but it is possible that we don't have the corresponding object in the pool yet (for example, we haven't seen the *_CREATE op for it).\n      // we don't want to return undefined from this map's .get() method even if we don't have the object,\n      // so instead we create a zero-value object for that object id if it not exists.\n      this._realtimeObject.getPool().createZeroValueObjectIfNotExists(op.data.objectId); // RTLM7c1\n    } else {\n      liveData = { value: op.data.value } as ValueObjectData;\n    }\n\n    if (existingEntry) {\n      // If there was an existing entry, we need to handle parent reference changes\n      if (existingEntry.data && 'objectId' in existingEntry.data) {\n        // Remove parent reference from the old object\n        const oldReferencedObject = this._realtimeObject.getPool().get(existingEntry.data.objectId);\n        if (oldReferencedObject) {\n          oldReferencedObject.removeParentReference(this, op.key);\n        }\n      }\n\n      // RTLM7a2\n      existingEntry.tombstone = false; // RTLM7a2c\n      existingEntry.tombstonedAt = undefined;\n      existingEntry.timeserial = opSerial; // RTLM7a2b\n      existingEntry.data = liveData; // RTLM7a2a\n    } else {\n      // RTLM7b, RTLM7b1\n      const newEntry: LiveMapEntry = {\n        tombstone: false, // RTLM7b2\n        tombstonedAt: undefined,\n        timeserial: opSerial,\n        data: liveData,\n      };\n      this._dataRef.data.set(op.key, newEntry);\n    }\n\n    // Add parent reference to the new object (if it's an object reference)\n    if ('objectId' in liveData) {\n      const newReferencedObject = this._realtimeObject.getPool().get(liveData.objectId);\n      if (newReferencedObject) {\n        newReferencedObject.addParentReference(this, op.key);\n      }\n    }\n\n    const update: LiveMapUpdate<T> = {\n      update: {},\n      objectMessage: msg,\n      _type: 'LiveMapUpdate',\n    };\n    const typedKey: keyof T & string = op.key;\n    update.update[typedKey] = 'updated';\n\n    return update;\n  }\n\n  /** @spec RTLM8 */\n  private _applyMapRemove(\n    op: ObjectsMapOp<ObjectData>,\n    opSerial: string | undefined,\n    opTimestamp: number | undefined,\n    msg: ObjectMessage,\n  ): LiveMapUpdate<T> | LiveObjectUpdateNoop {\n    const existingEntry = this._dataRef.data.get(op.key);\n    // RTLM8a\n    if (existingEntry && !this._canApplyMapOperation(existingEntry.timeserial, opSerial)) {\n      // RTLM8a1 - the operation's serial <= the entry's serial, ignore the operation.\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'LiveMap._applyMapRemove()',\n        `skipping remove for key=\"${op.key}\": op serial ${opSerial?.toString()} <= entry serial ${existingEntry.timeserial?.toString()}; objectId=${this.getObjectId()}`,\n      );\n      return { noop: true };\n    }\n\n    let tombstonedAt: number;\n    if (opTimestamp != null) {\n      tombstonedAt = opTimestamp;\n    } else {\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MINOR,\n        'LiveMap._applyMapRemove()',\n        `map key has been removed but no \"serialTimestamp\" found in the message, using local clock instead; key=\"${op.key}\", objectId=${this.getObjectId()}`,\n      );\n      tombstonedAt = Date.now(); // best-effort estimate since no timestamp provided by the server\n    }\n\n    if (existingEntry) {\n      // Handle parent reference removal for object references\n      if (existingEntry.data && 'objectId' in existingEntry.data) {\n        // Remove parent reference from the object that was being referenced\n        const referencedObject = this._realtimeObject.getPool().get(existingEntry.data.objectId);\n        if (referencedObject) {\n          referencedObject.removeParentReference(this, op.key);\n        }\n      }\n\n      // RTLM8a2\n      existingEntry.tombstone = true; // RTLM8a2c\n      existingEntry.tombstonedAt = tombstonedAt;\n      existingEntry.timeserial = opSerial; // RTLM8a2b\n      existingEntry.data = undefined; // RTLM8a2a\n    } else {\n      // RTLM8b, RTLM8b1\n      const newEntry: LiveMapEntry = {\n        tombstone: true, // RTLM8b2\n        tombstonedAt: tombstonedAt,\n        timeserial: opSerial,\n        data: undefined,\n      };\n      this._dataRef.data.set(op.key, newEntry);\n    }\n\n    const update: LiveMapUpdate<T> = {\n      update: {},\n      objectMessage: msg,\n      _type: 'LiveMapUpdate',\n    };\n    const typedKey: keyof T & string = op.key;\n    update.update[typedKey] = 'removed';\n\n    return update;\n  }\n\n  /**\n   * Returns true if the serials of the given operation and entry indicate that\n   * the operation should be applied to the entry, following the CRDT semantics of this LiveMap.\n   * @spec RTLM9\n   */\n  private _canApplyMapOperation(mapEntrySerial: string | undefined, opSerial: string | undefined): boolean {\n    // for LWW CRDT semantics (the only supported LiveMap semantic) an operation\n    // should only be applied if its serial is strictly greater (\"after\") than an entry's serial.\n\n    if (!mapEntrySerial && !opSerial) {\n      // RTLM9b - if both serials are nullish or empty strings, we treat them as the \"earliest possible\" serials,\n      // in which case they are \"equal\", so the operation should not be applied\n      return false;\n    }\n\n    if (!mapEntrySerial) {\n      // RTLM9d - any operation serial is greater than non-existing entry serial\n      return true;\n    }\n\n    if (!opSerial) {\n      // RTLM9c - non-existing operation serial is lower than any entry serial\n      return false;\n    }\n\n    // RTLM9e - if both serials exist, compare them lexicographically\n    return opSerial > mapEntrySerial;\n  }\n\n  private _liveMapDataFromMapEntries(entries: Record<string, ObjectsMapEntry<ObjectData>>): LiveMapData {\n    const liveMapData: LiveMapData = {\n      data: new Map<string, LiveMapEntry>(),\n    };\n\n    // need to iterate over entries to correctly process optional parameters\n    Object.entries(entries ?? {}).forEach(([key, entry]) => {\n      let liveData: LiveMapObjectData | undefined = undefined;\n\n      if (!this._client.Utils.isNil(entry.data)) {\n        if (!this._client.Utils.isNil(entry.data.objectId)) {\n          liveData = { objectId: entry.data.objectId } as ObjectIdObjectData;\n        } else {\n          liveData = { value: entry.data.value } as ValueObjectData;\n        }\n      }\n\n      let tombstonedAt: number | undefined;\n      if (entry.tombstone === true) {\n        if (entry.serialTimestamp != null) {\n          tombstonedAt = entry.serialTimestamp;\n        } else {\n          this._client.Logger.logAction(\n            this._client.logger,\n            this._client.Logger.LOG_MINOR,\n            'LiveMap._liveMapDataFromMapEntries()',\n            `map key is removed but no \"serialTimestamp\" found, using local clock instead; key=\"${key}\", objectId=${this.getObjectId()}`,\n          );\n          tombstonedAt = Date.now(); // best-effort estimate since no timestamp provided by the server\n        }\n      }\n\n      const liveDataEntry: LiveMapEntry = {\n        timeserial: entry.timeserial,\n        data: liveData,\n        // consider object as tombstoned only if we received an explicit flag stating that. otherwise it exists\n        tombstone: entry.tombstone === true,\n        tombstonedAt,\n      };\n\n      liveMapData.data.set(key, liveDataEntry);\n    });\n\n    return liveMapData;\n  }\n\n  /**\n   * Returns value as is if object data stores a primitive type, or a reference to another LiveObject from the pool if it stores an objectId.\n   */\n  private _getResolvedValueFromObjectData(data: LiveMapObjectData): Value | undefined {\n    // if object data stores primitive value, just return it as is.\n    const primitiveValue = (data as ValueObjectData).value;\n    if (primitiveValue != null) {\n      return primitiveValue; // RTLM5d2b, RTLM5d2c, RTLM5d2d, RTLM5d2e\n    }\n\n    // RTLM5d2f - otherwise, it has an objectId reference, and we should get the actual object from the pool\n    const objectId = (data as ObjectIdObjectData).objectId;\n    const refObject: LiveObject | undefined = this._realtimeObject.getPool().get(objectId);\n    if (!refObject) {\n      return undefined; // RTLM5d2f1\n    }\n\n    if (refObject.isTombstoned()) {\n      // tombstoned objects must not be surfaced to the end users\n      return undefined;\n    }\n\n    return refObject as unknown as PublicLiveObject; // RTLM5d2f2\n  }\n\n  private _isMapEntryTombstoned(entry: LiveMapEntry): boolean {\n    if (entry.tombstone === true) {\n      return true;\n    }\n\n    // data always exists for non-tombstoned entries\n    const data = entry.data!;\n    if ('objectId' in data) {\n      const refObject = this._realtimeObject.getPool().get(data.objectId);\n\n      if (refObject?.isTombstoned()) {\n        // entry that points to tombstoned object should be considered tombstoned as well\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Update parent references based on the calculated update diff.\n   */\n  private _updateParentReferencesFromUpdate(update: LiveMapUpdate<T>, previousDataRef: LiveMapData): void {\n    for (const [key, changeType] of Object.entries(update.update)) {\n      if (changeType === 'removed') {\n        // Key was removed - remove parent reference from the old object if it was referencing one\n        const previousEntry = previousDataRef.data.get(key);\n        if (previousEntry?.data && 'objectId' in previousEntry.data) {\n          const oldReferencedObject = this._realtimeObject.getPool().get(previousEntry.data.objectId);\n          if (oldReferencedObject) {\n            oldReferencedObject.removeParentReference(this, key);\n          }\n        }\n      }\n\n      if (changeType === 'updated') {\n        // Key was updated - need to handle both removal of old reference and addition of new reference\n        const previousEntry = previousDataRef.data.get(key);\n        const newEntry = this._dataRef.data.get(key);\n\n        // Remove old parent reference if there was one\n        if (previousEntry?.data && 'objectId' in previousEntry.data) {\n          const oldReferencedObject = this._realtimeObject.getPool().get(previousEntry.data.objectId);\n          if (oldReferencedObject) {\n            oldReferencedObject.removeParentReference(this, key);\n          }\n        }\n\n        // Add new parent reference if the new value references an object\n        if (newEntry?.data && 'objectId' in newEntry.data) {\n          const newReferencedObject = this._realtimeObject.getPool().get(newEntry.data.objectId);\n          if (newReferencedObject) {\n            newReferencedObject.addParentReference(this, key);\n          }\n        }\n      }\n    }\n  }\n}\n", "import { __livetype } from '../../../ably';\nimport { Primitive, LiveMap as PublicLiveMap, Value } from '../../../liveobjects';\nimport { LiveCounterValueType } from './livecountervaluetype';\nimport { LiveMap, LiveMapObjectData, ObjectIdObjectData, ValueObjectData } from './livemap';\nimport { ObjectId } from './objectid';\nimport {\n  createInitialValueJSONString,\n  ObjectData,\n  ObjectMessage,\n  ObjectOperation,\n  ObjectOperationAction,\n  ObjectsMapEntry,\n  ObjectsMapSemantics,\n} from './objectmessage';\nimport { RealtimeObject } from './realtimeobject';\n\n/**\n * A value type class that serves as a simple container for LiveMap data.\n * Contains sufficient information for the client to produce a MAP_CREATE operation\n * for the LiveMap object.\n *\n * Properties of this class are immutable after construction and the instance\n * will be frozen to prevent mutation.\n *\n * Note: We do not deep freeze or deep copy the entries data for the following reasons:\n * 1. It adds substantial complexity, especially for handling Buffer/ArrayBuffer values\n * 2. Cross-platform buffer copying would require reimplementing BufferUtils logic\n *    to handle browser vs Node.js environments and check availability of Buffer/ArrayBuffer\n * 3. The protection isn't critical - if users mutate the data after creating the value type,\n *    nothing breaks since we create separate live objects each time the value type is used\n * 4. This behavior should be documented and it's the user's responsibility to understand\n *    how they mutate their data when working with value type classes\n */\nexport class LiveMapValueType<T extends Record<string, Value> = Record<string, Value>> implements PublicLiveMap<T> {\n  declare readonly [__livetype]: 'LiveMap'; // type-only, unique symbol to satisfy branded interfaces, no JS emitted\n  private readonly _livetype = 'LiveMap'; // use a runtime property to provide a reliable cross-bundle type identification instead of `instanceof` operator\n  private readonly _entries: T | undefined;\n\n  private constructor(entries: T | undefined) {\n    this._entries = entries;\n    Object.freeze(this);\n  }\n\n  static create<T extends Record<string, Value>>(\n    initialEntries?: T,\n  ): PublicLiveMap<T extends Record<string, Value> ? T : {}> {\n    // We can't directly import the ErrorInfo class from the core library into the plugin (as this would bloat the plugin size),\n    // and, since we're in a user-facing static method, we can't expect a user to pass a client library instance, as this would make the API ugly.\n    // Since we can't use ErrorInfo here, we won't do any validation at this step; instead, validation will happen in the mutation methods\n    // when we try to create this object.\n\n    return new LiveMapValueType(initialEntries);\n  }\n\n  /**\n   * @internal\n   */\n  static instanceof(value: unknown): value is LiveMapValueType {\n    return typeof value === 'object' && value !== null && (value as LiveMapValueType)._livetype === 'LiveMap';\n  }\n\n  /**\n   * @internal\n   */\n  static async createMapCreateMessage(\n    realtimeObject: RealtimeObject,\n    value: LiveMapValueType,\n  ): Promise<{ mapCreateMsg: ObjectMessage; nestedObjectsCreateMsgs: ObjectMessage[] }> {\n    const client = realtimeObject.getClient();\n    const entries = value._entries;\n\n    if (entries !== undefined && (entries === null || typeof entries !== 'object')) {\n      throw new client.ErrorInfo('Map entries should be a key-value object', 40003, 400);\n    }\n\n    Object.entries(entries ?? {}).forEach(([key, value]) => LiveMap.validateKeyValue(realtimeObject, key, value));\n\n    const { initialValueOperation, nestedObjectsCreateMsgs } = await LiveMapValueType._createInitialValueOperation(\n      realtimeObject,\n      entries,\n    );\n    const initialValueJSONString = createInitialValueJSONString(initialValueOperation, client);\n    const nonce = client.Utils.cheapRandStr();\n    const msTimestamp = await client.getTimestamp(true);\n\n    const objectId = ObjectId.fromInitialValue(\n      client.Platform,\n      'map',\n      initialValueJSONString,\n      nonce,\n      msTimestamp,\n    ).toString();\n\n    const mapCreateMsg = ObjectMessage.fromValues(\n      {\n        operation: {\n          ...initialValueOperation,\n          action: ObjectOperationAction.MAP_CREATE,\n          objectId,\n          nonce,\n          initialValue: initialValueJSONString,\n        } as ObjectOperation<ObjectData>,\n      },\n      client.Utils,\n      client.MessageEncoding,\n    );\n\n    return {\n      mapCreateMsg,\n      nestedObjectsCreateMsgs,\n    };\n  }\n\n  private static async _createInitialValueOperation(\n    realtimeObject: RealtimeObject,\n    entries?: Record<string, Value>,\n  ): Promise<{\n    initialValueOperation: Pick<ObjectOperation<ObjectData>, 'map'>;\n    nestedObjectsCreateMsgs: ObjectMessage[];\n  }> {\n    const mapEntries: Record<string, ObjectsMapEntry<ObjectData>> = {};\n    const nestedObjectsCreateMsgs: ObjectMessage[] = [];\n\n    for (const [key, value] of Object.entries(entries ?? {})) {\n      let objectData: LiveMapObjectData;\n\n      if (LiveMapValueType.instanceof(value)) {\n        const { mapCreateMsg, nestedObjectsCreateMsgs: childNestedObjs } =\n          await LiveMapValueType.createMapCreateMessage(realtimeObject, value);\n        nestedObjectsCreateMsgs.push(...childNestedObjs, mapCreateMsg);\n        const typedObjectData: ObjectIdObjectData = { objectId: mapCreateMsg.operation?.objectId! };\n        objectData = typedObjectData;\n      } else if (LiveCounterValueType.instanceof(value)) {\n        const counterCreateMsg = await LiveCounterValueType.createCounterCreateMessage(realtimeObject, value);\n        nestedObjectsCreateMsgs.push(counterCreateMsg);\n        const typedObjectData: ObjectIdObjectData = { objectId: counterCreateMsg.operation?.objectId! };\n        objectData = typedObjectData;\n      } else {\n        // Handle primitive values\n        const typedObjectData: ValueObjectData = { value: value as Primitive };\n        objectData = typedObjectData;\n      }\n\n      mapEntries[key] = {\n        data: objectData,\n      };\n    }\n\n    const initialValueOperation = {\n      map: {\n        semantics: ObjectsMapSemantics.LWW,\n        entries: mapEntries,\n      },\n    };\n\n    return {\n      initialValueOperation,\n      nestedObjectsCreateMsgs,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": ["_a", "_a", "value"]
}
