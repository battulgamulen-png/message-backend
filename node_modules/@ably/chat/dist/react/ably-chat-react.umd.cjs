(function(p,o){typeof exports=="object"&&typeof module<"u"?o(exports,require("react"),require("ably"),require("react/jsx-runtime")):typeof define=="function"&&define.amd?define(["exports","react","ably","react/jsx-runtime"],o):(p=typeof globalThis<"u"?globalThis:p||self,o(p.AblyChat={},p.React,p.Ably,p.jsxRuntime))})(this,(function(p,o,te,G){"use strict";function X(e){const n=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const s in e)if(s!=="default"){const r=Object.getOwnPropertyDescriptor(e,s);Object.defineProperty(n,s,r.get?r:{enumerable:!0,get:()=>e[s]})}}return n.default=e,Object.freeze(n)}const H=X(o),A=X(te),K=o.createContext(void 0);A.Realtime.EventEmitter;var j=(e=>(e.Initialized="initialized",e.Connecting="connecting",e.Connected="connected",e.Disconnected="disconnected",e.Suspended="suspended",e.Failed="failed",e.Closing="closing",e.Closed="closed",e))(j||{}),I=(e=>(e[e.BadRequest=4e4]="BadRequest",e[e.InvalidArgument=40003]="InvalidArgument",e[e.InvalidClientId=40012]="InvalidClientId",e[e.ResourceDisposed=40014]="ResourceDisposed",e[e.MessageRejectedByBeforePublishRule=42211]="MessageRejectedByBeforePublishRule",e[e.MessageRejectedByModeration=42213]="MessageRejectedByModeration",e[e.Disconnected=80003]="Disconnected",e[e.PresenceAutoReentryFailed=91004]="PresenceAutoReentryFailed",e[e.RoomDiscontinuity=102100]="RoomDiscontinuity",e[e.RoomInInvalidState=102112]="RoomInInvalidState",e[e.RoomReleasedBeforeOperationCompleted=102106]="RoomReleasedBeforeOperationCompleted",e[e.RoomExistsWithDifferentOptions=102107]="RoomExistsWithDifferentOptions",e[e.FeatureNotEnabledInRoom=102108]="FeatureNotEnabledInRoom",e[e.ListenerNotSubscribed=102109]="ListenerNotSubscribed",e[e.ChannelSerialNotDefined=102110]="ChannelSerialNotDefined",e[e.ChannelOptionsCannotBeModified=102111]="ChannelOptionsCannotBeModified",e[e.OperationSerializationFailed=102113]="OperationSerializationFailed",e[e.ReactHookMustBeUsedWithinProvider=102200]="ReactHookMustBeUsedWithinProvider",e[e.ReactComponentUnmounted=102201]="ReactComponentUnmounted",e[e.PresenceFetchFailed=102202]="PresenceFetchFailed",e))(I||{});const re=(e,n)=>e.code===n,J=Symbol.for("__ABLY_CHAT_CLIENT_CONTEXT__"),$=typeof globalThis>"u"?{}:globalThis,U=(()=>{let e=$[J];return e??=$[J]=o.createContext({}),e})();var Z=Object.prototype.hasOwnProperty;function Q(e,n,s){for(s of e.keys())if(F(s,n))return s}function F(e,n){var s,r,i;if(e===n)return!0;if(e&&n&&(s=e.constructor)===n.constructor){if(s===Date)return e.getTime()===n.getTime();if(s===RegExp)return e.toString()===n.toString();if(s===Array){if((r=e.length)===n.length)for(;r--&&F(e[r],n[r]););return r===-1}if(s===Set){if(e.size!==n.size)return!1;for(r of e)if(i=r,i&&typeof i=="object"&&(i=Q(n,i),!i)||!n.has(i))return!1;return!0}if(s===Map){if(e.size!==n.size)return!1;for(r of e)if(i=r[0],i&&typeof i=="object"&&(i=Q(n,i),!i)||!F(r[1],n.get(i)))return!1;return!0}if(s===ArrayBuffer)e=new Uint8Array(e),n=new Uint8Array(n);else if(s===DataView){if((r=e.byteLength)===n.byteLength)for(;r--&&e.getInt8(r)===n.getInt8(r););return r===-1}if(ArrayBuffer.isView(e)){if((r=e.byteLength)===n.byteLength)for(;r--&&e[r]===n[r];);return r===-1}if(!s||typeof e=="object"){r=0;for(s in e)if(Z.call(e,s)&&++r&&!Z.call(n,s)||!(s in n)||!F(e[s],n[s]))return!1;return Object.keys(n).length===r}}return e!==e&&n!==n}const q=e=>{if(e===null||typeof e!="object")return e;if(Array.isArray(e))return e.sort().map(r=>q(r));const n={},s=Object.keys(e).sort();for(const r of s)n[r]=q(e[r]);return n},se=(e,n)=>{if(n===void 0)return;if(n===null||typeof n!="object")return n;if(Array.isArray(n))return n.sort().map(i=>q(i));const s={},r=Object.keys(n).sort();for(const i of r)s[i]=n[i];return s},W=(e,n)=>JSON.stringify({roomName:e,options:n},se);class oe{constructor(n,s){this._refCounts=new Map,this._releaseDelayMs=100,this._pendingReleases=new Map,this._client=n,this._logger=s}get client(){return this._client}async addReference(n,s){this._logger.trace("RoomReferenceManager.addReference();");const r=W(n,s),i=this._refCounts.get(r);if(i)return i.pendingRelease&&(clearTimeout(i.pendingRelease),i.pendingRelease=void 0,this._logger.debug("RoomReferenceManager.addReference(); aborted pending release",{roomName:n,options:s})),i.count++,this._logger.debug("RoomReferenceManager.addReference(); incremented ref count",{roomName:n,options:s,count:i.count}),i.resolvedRoom?i.resolvedRoom:new Promise((c,u)=>{const a=setInterval(()=>{i.resolvedRoom?(clearInterval(a),c(i.resolvedRoom)):i.resolutionError&&(clearInterval(a),u(i.resolutionError))},100)});const l=this._pendingReleases.get(n);if(l){this._logger.debug("RoomReferenceManager.addReference(); waiting for pending release to complete",{roomName:n,options:s});try{await l}catch(c){this._logger.debug("RoomReferenceManager.addReference(); pending release failed, continuing",{roomName:n,options:s,error:c})}}const t=[...this._refCounts.values()].find(c=>c.roomName===n&&!F(c.options,s));if(t){const c=t.pendingRelease!==void 0,u=t.count<=0;if(!c&&!u)throw new A.ErrorInfo(`unable to get room reference; room "${n}" is already in use with different options`,I.RoomExistsWithDifferentOptions,400);this._logger.debug("RoomReferenceManager.addReference(); found existing room with different options, releasing it first",{roomName:n,newOptions:s,existingOptions:t.options,hasPendingRelease:c,hasZeroRefCount:u}),t.pendingRelease&&(clearTimeout(t.pendingRelease),t.pendingRelease=void 0);const a=W(n,t.options);this._refCounts.delete(a);const h=this._client.rooms.release(n).catch(y=>{this._logger.debug("RoomReferenceManager.addReference(); release of existing room failed",{roomName:n,error:y})}).finally(()=>{this._pendingReleases.delete(n)});this._pendingReleases.set(n,h);try{await h}catch(y){this._logger.debug("RoomReferenceManager.addReference(); release of existing room failed, continuing",{roomName:n,error:y})}}const g={count:1,roomName:n,options:s};this._refCounts.set(r,g),this._logger.debug("RoomReferenceManager.addReference(); first reference, attaching room",{roomName:n,options:s});try{const c=await this._client.rooms.get(n,s);return g.resolvedRoom=c,c.attach().catch(u=>{this._logger.error("RoomReferenceManager.addReference(); error attaching room",{roomName:n,options:s,error:u})}),c}catch(c){throw g.resolutionError=c,this._refCounts.delete(r),this._logger.error("RoomReferenceManager.addReference(); error creating room",{roomName:n,options:s,error:c}),c}}removeReference(n,s){this._logger.trace("RoomReferenceManager.removeReference();");const r=W(n,s),i=this._refCounts.get(r);if(!i){this._logger.debug("RoomReferenceManager.removeReference(); no existing reference found",{roomName:n,options:s});return}i.count--,this._logger.debug("RoomReferenceManager.removeReference(); decremented ref count",{roomName:n,options:s,count:i.count}),i.count<=0&&(this._logger.debug("RoomReferenceManager.removeReference(); scheduling delayed release",{roomName:n,options:s,delayMs:this._releaseDelayMs}),i.pendingRelease=setTimeout(()=>{const l=this._refCounts.get(r);if(l&&l.count<=0){this._refCounts.delete(r),this._logger.debug("RoomReferenceManager.removeReference(); executing delayed release",{roomName:n,options:s});const t=this._client.rooms.release(n).catch(g=>{this._logger.debug("RoomReferenceManager.removeReference(); release failed",{roomName:n,options:s,error:g})}).finally(()=>{this._pendingReleases.delete(n)});this._pendingReleases.set(n,t)}},this._releaseDelayMs))}getReferenceCount(n,s){this._logger.trace("RoomReferenceManager.getReferenceCount();");const r=W(n,s);return this._refCounts.get(r)?.count??0}}const N=Symbol("roomReferenceManager"),ie=()=>{const n=H.useContext(U)[N];if(!n)throw new A.ErrorInfo("unable to get room reference manager; useRoomReferenceManager must be used within a ChatClientProvider",I.ReactHookMustBeUsedWithinProvider,400);return n},ee="default",ue=({children:e,client:n})=>{const s=H.useContext(U),r=o.useRef(void 0),i=H.useMemo(()=>{if(n.addReactAgent(),r.current?.client!==n){const t=n.logger;r.current=new oe(n,t)}const l=globalThis.__ABLY_CHAT_REACT_UI_KIT_VERSION__;return typeof l=="string"&&n.addAgentWithVersion("chat-react-ui-kit",l),{...s,[ee]:{client:n},[N]:r.current}},[n,s]);return G.jsx(U.Provider,{value:i,children:e})},z=()=>{const e=o.useContext(U)[ee];if(!e)throw new A.ErrorInfo("unable to get chat client; useChatClient hook must be used within a chat client provider",I.ReactHookMustBeUsedWithinProvider,400);return e.client},D=e=>{const n=o.useContext(K);if(!n)throw new A.ErrorInfo(`unable to get room context; ${e} hook must be used within a <ChatRoomProvider>`,I.ReactHookMustBeUsedWithinProvider,400);return n},Y=()=>{const e=z();return o.useMemo(()=>e.logger,[e])},T=()=>{const e=D("useRoomLogger"),n=z();return o.useMemo(()=>n.logger.withContext({roomName:e.roomName}),[n,e])},ce=()=>{const e=z(),n=Y(),[s,r]=o.useState(()=>(n.debug("useChatClient(); setting initial clientId",{clientId:e.clientId}),e.clientId));return o.useEffect(()=>{n.debug("useChatClient(); subscribing to connection status changes",{clientId:e.clientId}),r(e.clientId);const{off:i}=e.connection.onStatusChange(l=>{l.current===j.Connected&&(n.debug("useChatClient(); connection status is now connected",{clientId:e.clientId}),r(e.clientId))});return()=>{n.debug("useChatClient(); unsubscribing from connection status changes"),i()}},[e,n]),{clientId:s}},v=e=>{const n=o.useRef(e);o.useEffect(()=>{n.current=e});const s=o.useCallback((...r)=>{n.current&&n.current(...r)},[]);return e?s:void 0},x=e=>{const n=z(),s=Y();s.trace("useChatConnection();",e);const[r,i]=o.useState(n.connection.status),[l,t]=o.useState(n.connection.error);o.useEffect(()=>{t(n.connection.error),i(n.connection.status)},[n]);const g=v(e?.onStatusChange);return o.useEffect(()=>{s.debug("useChatConnection(); applying internal listener");const{off:c}=n.connection.onStatusChange(u=>{i(u.current),t(u.error)});return()=>{s.debug("useChatConnection(); cleaning up listener"),c()}},[n.connection,s]),o.useEffect(()=>{if(!g)return;s.debug("useChatConnection(); applying client listener");const{off:c}=n.connection.onStatusChange(g);return()=>{s.debug("useChatConnection(); cleaning up client listener"),c()}},[n.connection,s,g]),{currentStatus:r,error:l}};class ae{constructor(n,s,r){this._unmounted=!1,this._onResolve=s,this._logger=r,this.mount(n).catch(i=>{this._logger.trace("DefaultRoomPromise(); mount error",{error:i})})}async mount(n){this._logger.debug("DefaultRoomPromise(); mount");try{const s=await n;if(this._unmounted)return;this._logger.debug("DefaultRoomPromise(); mount resolved"),this._onUnmount=this._onResolve(s)}catch(s){this._logger.error("DefaultRoomPromise(); mount error",{error:s})}}unmount(){return this._unmounted?()=>{}:()=>{this._logger.debug("DefaultRoomPromise(); unmount"),this._unmounted=!0,this._onUnmount?.()}}}const R=(e,n,s)=>new ae(e,n,s);var L=(e=>(e.Initializing="initializing",e.Initialized="initialized",e.Attaching="attaching",e.Attached="attached",e.Detaching="detaching",e.Detached="detached",e.Suspended="suspended",e.Failed="failed",e.Releasing="releasing",e.Released="released",e))(L||{});const O=e=>{const n=D("useRoomStatus"),[s,r]=o.useState(L.Initializing),[i,l]=o.useState(),t=T(),g=v(e?.onRoomStatusChange);return o.useEffect(()=>R(n.room,u=>{t.debug("useRoomStatus(); subscribing internal listener"),r(u.status),l(u.error);const{off:a}=u.onStatusChange(h=>{t.debug("useRoomStatus(); status change",h),r(h.current),l(h.error)});return()=>{t.debug("useRoomStatus(); unsubscribing internal listener"),a()}},t).unmount(),[n,t]),o.useEffect(()=>R(n.room,u=>{let a;return g&&(t.debug("useRoomStatus(); subscribing to status changes"),a=u.onStatusChange(g).off),t.debug("useRoomStatus(); setting initial status",{status:u.status}),g&&(t.debug("useRoomStatus(); sending initial status event"),g({current:u.status,previous:L.Initializing,error:u.error})),()=>{t.debug("useRoomStatus(); unmounting"),a&&(t.debug("useRoomStatus(); unsubscribing from status changes"),a())}},t).unmount(),[n,t,g]),{status:s,error:i}},ge=e=>{const{currentStatus:n,error:s}=x({onStatusChange:e?.onConnectionStatusChange}),r=D("useMessages"),{status:i,error:l}=O(e),t=T();t.trace("useMessages();",{params:e});const g=v(e?.listener),c=v(e?.reactionsListener),u=v(e?.rawReactionsListener),a=v(e?.onDiscontinuity),h=o.useCallback(async d=>(await r.room).messages.send(d),[r]),y=o.useCallback(async d=>(await r.room).messages.get(d),[r]),S=o.useCallback(async(d,f)=>(await r.room).messages.delete(d,f),[r]),_=o.useCallback(async d=>(await r.room).messages.history(d),[r]),m=o.useCallback(async(d,f,C)=>(await r.room).messages.update(d,f,C),[r]),w=o.useCallback(async(d,f)=>(await r.room).messages.reactions.send(d,f),[r]),P=o.useCallback(async(d,f)=>(await r.room).messages.reactions.delete(d,f),[r]),[k,b]=o.useState();return o.useEffect(()=>{if(g)return R(r.room,d=>{let f=!1;t.debug("useMessages(); applying listener");const C=d.messages.subscribe(g);return b(()=>{if(t.debug("useMessages(); setting historyBeforeSubscribe state",{status:d.status,unmounted:f}),!f)return async E=>{if(t.debug("useMessages(); historyBeforeSubscribe called"),f)throw new A.ErrorInfo("unable to query messages; component unmounted",I.ReactComponentUnmounted,400);return C.historyBeforeSubscribe(E)}}),()=>{t.debug("useMessages(); removing listener and historyBeforeSubscribe state"),f=!0,C.unsubscribe(),b(void 0)}},t).unmount()},[r,t,g]),o.useEffect(()=>{if(a)return R(r.room,d=>{t.debug("useMessages(); applying onDiscontinuity listener");const{off:f}=d.onDiscontinuity(a);return()=>{t.debug("useMessages(); removing onDiscontinuity listener"),f()}},t).unmount()},[r,t,a]),o.useEffect(()=>{if(c)return R(r.room,d=>{t.debug("useMessages(); applying reactions listener");const{unsubscribe:f}=d.messages.reactions.subscribe(c);return()=>{t.debug("useMessages(); removing reactions listener"),f()}},t).unmount()},[r,t,c]),o.useEffect(()=>{if(u)return R(r.room,d=>{t.debug("useMessages(); applying raw reactions listener");const{unsubscribe:f}=d.messages.reactions.subscribeRaw(u);return()=>{t.debug("useMessages(); removing raw reactions listener"),f()}},t).unmount()},[r,t,u]),{connectionStatus:n,connectionError:s,roomStatus:i,roomError:l,sendMessage:h,getMessage:y,updateMessage:m,history:_,deleteMessage:S,sendReaction:w,deleteReaction:P,historyBeforeSubscribe:k}},le=e=>{const{currentStatus:n,error:s}=x({onStatusChange:e?.onConnectionStatusChange}),r=D("useOccupancy"),{status:i,error:l}=O(e),t=T();t.trace("useOccupancy();",{params:e});const[g,c]=o.useState({connections:0,presenceMembers:0}),u=v(e?.listener),a=v(e?.onDiscontinuity);return o.useEffect(()=>{if(a)return R(r.room,h=>{t.debug("useOccupancy(); applying onDiscontinuity listener");const{off:y}=h.onDiscontinuity(a);return()=>{t.debug("useOccupancy(); removing onDiscontinuity listener"),y()}},t).unmount()},[r,a,t]),o.useEffect(()=>R(r.room,y=>{t.debug("useOccupancy(); applying internal listener");const S=y.occupancy.current;c({connections:S?.connections??0,presenceMembers:S?.presenceMembers??0});const{unsubscribe:_}=y.occupancy.subscribe(m=>{c({connections:m.occupancy.connections,presenceMembers:m.occupancy.presenceMembers})});return()=>{t.debug("useOccupancy(); cleaning up internal listener"),_()}},t).unmount(),[r,t]),o.useEffect(()=>{if(u)return R(r.room,h=>{t.debug("useOccupancy(); applying listener");const{unsubscribe:y}=h.occupancy.subscribe(u);return()=>{t.debug("useOccupancy(); cleaning up listener"),y()}},t).unmount()},[u,r,t]),{connectionStatus:n,connectionError:s,roomStatus:i,roomError:l,connections:g.connections,presenceMembers:g.presenceMembers}},ne=new Set([j.Suspended,j.Failed,j.Closing,j.Closed]),fe=e=>{const{currentStatus:n,error:s}=x({onStatusChange:e?.onConnectionStatusChange}),r=D("usePresence"),{status:i,error:l}=O(e),t=T();t.trace("usePresence();",{params:e});const g=o.useMemo(()=>e?.autoEnterLeave!==!1,[e?.autoEnterLeave]),[c,u]=o.useState({present:!1,error:void 0}),a=o.useRef({roomStatus:i,connectionStatus:n}),h=v(e?.onDiscontinuity),y=o.useRef(e?.initialData),S=o.useRef(!1),_=o.useRef(!1),m=o.useRef(!1);o.useEffect(()=>{_.current=!1,m.current=!1},[r]),o.useEffect(()=>{a.current={roomStatus:i,connectionStatus:n},i===L.Detached&&(m.current=!0)},[i,n]),o.useEffect(()=>(t.debug("usePresence(); subscribing to presence state changes"),R(r.room,b=>{const d=b.presence.onPresenceStateChange(f=>{t.debug("usePresence(); presence state changed",{stateChange:f}),u({...f.current,error:f.error})});return()=>{t.debug("usePresence(); unsubscribing from presence state changes"),d.unsubscribe()}},t).unmount()),[r,t]),o.useEffect(()=>(t.debug("usePresence(); running auto-enter hook"),g?R(r.room,b=>{const d=b.status===L.Attached&&!ne.has(n),f=!_.current||m.current;return!d||S.current||!f?(t.debug("usePresence(); skipping enter room",{roomStatus:i,connectionStatus:n,hasExplicitlyLeft:S.current,shouldAutoEnter:f,hasAutoEntered:_.current,roomWasDetached:m.current}),()=>{}):(t.debug("usePresence(); entering room"),b.presence.enter(y.current).then(()=>{t.debug("usePresence(); entered room"),_.current=!0,m.current=!1}).catch(C=>{t.error("usePresence(); error entering room",{error:C})}),()=>{const C=b.status===L.Attached&&!ne.has(a.current.connectionStatus);t.debug("usePresence(); unmounting",{canLeavePresence:C,roomStatus:i,connectionStatus:n}),C&&!S.current&&b.presence.leave().then(()=>{t.debug("usePresence(); left room")}).catch(E=>{t.error("usePresence(); error leaving room",{error:E})})})},t).unmount():(t.debug("usePresence(); auto enter/leave disabled"),()=>{})),[r,n,i,t,g]),o.useEffect(()=>{if(h)return R(r.room,b=>{const{off:d}=b.onDiscontinuity(h);return()=>{t.debug("usePresence(); removing onDiscontinuity listener"),d()}},t).unmount()},[r,h,t]);const w=o.useCallback(async b=>{y.current=b,S.current=!1,await(await r.room).presence.update(b)},[r]),P=o.useCallback(async b=>{y.current=b,S.current=!1,await(await r.room).presence.enter(b)},[r]),k=o.useCallback(async b=>{S.current=!0,await(await r.room).presence.leave(b)},[r]);return{connectionStatus:n,connectionError:s,roomStatus:i,roomError:l,update:w,enter:P,leave:k,myPresenceState:c}},de=1500,he=3e4,me=5,be=e=>{const{currentStatus:n,error:s}=x({onStatusChange:e?.onConnectionStatusChange}),r=D("usePresenceListener"),{status:i,error:l}=O(e),t=T();t.trace("usePresenceListener();");const g=o.useRef(0),c=o.useRef(0),u=o.useRef(void 0),a=o.useRef(0),h=o.useRef([]),[y,S]=o.useState([]),_=o.useRef(void 0),[m,w]=o.useState(),P=v(e?.listener),k=v(e?.onDiscontinuity),b=o.useCallback(f=>{t.debug("usePresenceListener(); setting error state",{error:f}),_.current=f,w(f)},[t]),d=o.useCallback(()=>{t.debug("usePresenceListener(); clearing error state"),_.current=void 0,w(void 0)},[t]);return o.useEffect(()=>{const f=()=>{g.current+=1,u.current&&(clearTimeout(u.current),u.current=void 0,a.current=0),C(g.current)},C=E=>{R(r.room,B=>(B.presence.get({waitForSync:!0}).then(M=>{t.debug("usePresenceListener(); fetched presence data",{presenceMembers:M}),u.current&&(clearTimeout(u.current),u.current=void 0,a.current=0),!(c.current>=E)&&(c.current=E,h.current=M,S(M),_.current&&d())}).catch(()=>{if(!(a.current<me)){t.error("usePresenceListener(); failed to fetch presence data after max retries"),b(new A.ErrorInfo("unable to fetch presence data; failed after max retries",I.PresenceFetchFailed,500));return}if(u.current){t.debug("usePresenceListener(); waiting for retry but new event received");return}const V=Math.min(he,de*Math.pow(2,a.current));a.current+=1,t.debug("usePresenceListener(); retrying to fetch presence data",{numRetries:a.current}),u.current=setTimeout(()=>{u.current=void 0,g.current+=1,C(g.current)},V)}),()=>{}),t)};return R(r.room,E=>{let B;return E.status===L.Attached?E.presence.get({waitForSync:!0}).then(M=>{t.debug("usePresenceListener(); fetched initial presence data",{presenceMembers:M}),h.current=M,S(M),d()}).catch(M=>{const V=M;re(V,I.RoomInInvalidState)||(t.error("usePresenceListener(); error fetching initial presence data",{error:M}),b(V))}).finally(()=>{t.debug("usePresenceListener(); subscribing internal listener to presence events"),B=E.presence.subscribe(()=>{f()}).unsubscribe}):(t.debug("usePresenceListener(); not yet attached, subscribing internal listener to presence events"),B=E.presence.subscribe(()=>{f()}).unsubscribe),()=>{B&&(t.debug("usePresenceListener(); cleaning up internal listener"),B())}},t).unmount()},[r,b,d,t]),o.useEffect(()=>{if(P)return R(r.room,f=>{t.debug("usePresenceListener(); applying external listener");const{unsubscribe:C}=f.presence.subscribe(P);return()=>{t.debug("usePresenceListener(); cleaning up external listener"),C()}},t).unmount()},[r,P,t]),o.useEffect(()=>{if(k)return R(r.room,f=>{t.debug("usePresenceListener(); applying onDiscontinuity listener");const{off:C}=f.onDiscontinuity(k);return()=>{t.debug("usePresenceListener(); removing onDiscontinuity listener"),C()}},t).unmount()},[r,k,t]),{connectionStatus:n,connectionError:s,roomStatus:i,roomError:l,error:m,presenceData:y}},ye=e=>{const n=D("useRoom"),s=n.roomName;T().debug("useRoom();");const{currentStatus:i,error:l}=x({onStatusChange:e?.onConnectionStatusChange}),t=O({onRoomStatusChange:e?.onStatusChange}),g=o.useCallback(async()=>(await n.room).attach(),[n]),c=o.useCallback(async()=>(await n.room).detach(),[n]);return{roomName:s,attach:g,detach:c,roomStatus:t.status,roomError:t.error,connectionStatus:i,connectionError:l}},Re=e=>{const{currentStatus:n,error:s}=x({onStatusChange:e?.onConnectionStatusChange}),r=D("useRoomReactions"),{status:i,error:l}=O(e),t=T();t.trace("useRoomReactions();",{params:e});const g=v(e?.listener),c=v(e?.onDiscontinuity);o.useEffect(()=>{if(c)return R(r.room,a=>{t.debug("useRoomReactions(); applying onDiscontinuity listener");const{off:h}=a.onDiscontinuity(c);return()=>{t.debug("useRoomReactions(); removing onDiscontinuity listener"),h()}},t).unmount()},[r,c,t]),o.useEffect(()=>{if(g)return R(r.room,a=>{t.debug("useRoomReactions(); applying listener");const{unsubscribe:h}=a.reactions.subscribe(g);return()=>{t.debug("useRoomReactions(); removing listener"),h()}},t).unmount()},[r,g,t]);const u=o.useCallback(async a=>(await r.room).reactions.send(a),[r]);return{connectionStatus:n,connectionError:s,roomStatus:i,roomError:l,sendRoomReaction:u}},pe=e=>{const{currentStatus:n,error:s}=x({onStatusChange:e?.onConnectionStatusChange}),r=D("useTyping"),{status:i,error:l}=O(e),t=T();t.trace("useTyping();");const[g,c]=o.useState(new Set),[u,a]=o.useState([]),h=v(e?.listener),y=v(e?.onDiscontinuity);o.useEffect(()=>(c(m=>m.size===0?m:new Set),a(m=>m.length===0?m:[]),R(r.room,m=>{t.debug("useTyping(); subscribing to typing events");const{unsubscribe:w}=m.typing.subscribe(P=>{c(P.currentlyTyping),a(P.currentTypers)});if(m.status===L.Attached){const P=m.typing.current;t.debug("useTyping(); room attached, getting initial typers",{typing:P}),c(P),a(m.typing.currentTypers)}return()=>{t.debug("useTyping(); unsubscribing from typing events"),w()}},t).unmount()),[r,t]),o.useEffect(()=>{if(y)return R(r.room,m=>{t.debug("useTyping(); applying onDiscontinuity listener");const{off:w}=m.onDiscontinuity(y);return()=>{t.debug("useTyping(); removing onDiscontinuity listener"),w()}},t).unmount()},[r,y,t]),o.useEffect(()=>{if(h)return R(r.room,m=>{t.debug("useTyping(); applying listener");const{unsubscribe:w}=m.typing.subscribe(h);return()=>{t.debug("useTyping(); removing listener"),w()}},t).unmount()},[r,h,t]);const S=o.useCallback(async()=>(await r.room).typing.keystroke(),[r]),_=o.useCallback(async()=>(await r.room).typing.stop(),[r]);return{connectionStatus:n,connectionError:s,roomStatus:i,roomError:l,keystroke:S,stop:_,currentlyTyping:g,currentTypers:u}},Ce=({name:e,options:n,children:s})=>{const r=z(),i=Y(),l=o.useMemo(()=>i.withContext({roomName:e}),[i,e]),t=ie();l.debug("ChatRoomProvider();",{options:n});const[g,c]=o.useState(()=>{l.debug("ChatRoomProvider(); initializing value",{options:n});const u=r.rooms.get(e,n);return u.catch(()=>{}),{room:u,roomName:e,options:n,client:r}});return o.useEffect(()=>{l.debug("ChatRoomProvider(); running lifecycle useEffect");let u=!1;const a=t.addReference(e,n);return c(h=>h.client===r&&h.roomName===e&&h.options===n?(l.debug("ChatRoomProvider(); no change in room id or options",{options:n}),h):(l.debug("ChatRoomProvider(); updating value",{options:n}),{room:a,roomName:e,options:n,client:r})),a.then(()=>{if(u){l.debug("ChatRoomProvider(); unmounted before room resolved");return}l.debug("ChatRoomProvider(); room resolved")}).catch(()=>{}),()=>{u=!0,l.debug("ChatRoomProvider(); cleaning up lifecycle useEffect"),t.removeReference(e,n)}},[e,n,l,r,t]),G.jsx(K.Provider,{value:g,children:s})};p.ChatClientProvider=ue,p.ChatRoomContext=K,p.ChatRoomProvider=Ce,p.useChatClient=ce,p.useChatConnection=x,p.useMessages=ge,p.useOccupancy=le,p.usePresence=fe,p.usePresenceListener=be,p.useRoom=ye,p.useRoomReactions=Re,p.useTyping=pe,Object.defineProperty(p,Symbol.toStringTag,{value:"Module"})}));
//# sourceMappingURL=ably-chat-react.umd.cjs.map
