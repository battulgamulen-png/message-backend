import * as q from "react";
import ee, { createContext as oe, useRef as w, useContext as ie, useMemo as Y, useState as D, useEffect as m, useCallback as C } from "react";
import * as B from "ably";
import { jsx as te } from "react/jsx-runtime";
const ne = oe(void 0);
B.Realtime.EventEmitter;
var z = /* @__PURE__ */ ((e) => (e.Initialized = "initialized", e.Connecting = "connecting", e.Connected = "connected", e.Disconnected = "disconnected", e.Suspended = "suspended", e.Failed = "failed", e.Closing = "closing", e.Closed = "closed", e))(z || {}), A = /* @__PURE__ */ ((e) => (e[e.BadRequest = 4e4] = "BadRequest", e[e.InvalidArgument = 40003] = "InvalidArgument", e[e.InvalidClientId = 40012] = "InvalidClientId", e[e.ResourceDisposed = 40014] = "ResourceDisposed", e[e.MessageRejectedByBeforePublishRule = 42211] = "MessageRejectedByBeforePublishRule", e[e.MessageRejectedByModeration = 42213] = "MessageRejectedByModeration", e[e.Disconnected = 80003] = "Disconnected", e[e.PresenceAutoReentryFailed = 91004] = "PresenceAutoReentryFailed", e[e.RoomDiscontinuity = 102100] = "RoomDiscontinuity", e[e.RoomInInvalidState = 102112] = "RoomInInvalidState", e[e.RoomReleasedBeforeOperationCompleted = 102106] = "RoomReleasedBeforeOperationCompleted", e[e.RoomExistsWithDifferentOptions = 102107] = "RoomExistsWithDifferentOptions", e[e.FeatureNotEnabledInRoom = 102108] = "FeatureNotEnabledInRoom", e[e.ListenerNotSubscribed = 102109] = "ListenerNotSubscribed", e[e.ChannelSerialNotDefined = 102110] = "ChannelSerialNotDefined", e[e.ChannelOptionsCannotBeModified = 102111] = "ChannelOptionsCannotBeModified", e[e.OperationSerializationFailed = 102113] = "OperationSerializationFailed", e[e.ReactHookMustBeUsedWithinProvider = 102200] = "ReactHookMustBeUsedWithinProvider", e[e.ReactComponentUnmounted = 102201] = "ReactComponentUnmounted", e[e.PresenceFetchFailed = 102202] = "PresenceFetchFailed", e))(A || {});
const ce = (e, t) => e.code === t, J = Symbol.for("__ABLY_CHAT_CLIENT_CONTEXT__"), $ = typeof globalThis > "u" ? {} : globalThis, ue = () => {
  let e = $[J];
  return e ??= $[J] = ee.createContext({}), e;
}, K = ue();
var Z = Object.prototype.hasOwnProperty;
function Q(e, t, s) {
  for (s of e.keys())
    if (U(s, t)) return s;
}
function U(e, t) {
  var s, r, o;
  if (e === t) return !0;
  if (e && t && (s = e.constructor) === t.constructor) {
    if (s === Date) return e.getTime() === t.getTime();
    if (s === RegExp) return e.toString() === t.toString();
    if (s === Array) {
      if ((r = e.length) === t.length)
        for (; r-- && U(e[r], t[r]); ) ;
      return r === -1;
    }
    if (s === Set) {
      if (e.size !== t.size)
        return !1;
      for (r of e)
        if (o = r, o && typeof o == "object" && (o = Q(t, o), !o) || !t.has(o)) return !1;
      return !0;
    }
    if (s === Map) {
      if (e.size !== t.size)
        return !1;
      for (r of e)
        if (o = r[0], o && typeof o == "object" && (o = Q(t, o), !o) || !U(r[1], t.get(o)))
          return !1;
      return !0;
    }
    if (s === ArrayBuffer)
      e = new Uint8Array(e), t = new Uint8Array(t);
    else if (s === DataView) {
      if ((r = e.byteLength) === t.byteLength)
        for (; r-- && e.getInt8(r) === t.getInt8(r); ) ;
      return r === -1;
    }
    if (ArrayBuffer.isView(e)) {
      if ((r = e.byteLength) === t.byteLength)
        for (; r-- && e[r] === t[r]; ) ;
      return r === -1;
    }
    if (!s || typeof e == "object") {
      r = 0;
      for (s in e)
        if (Z.call(e, s) && ++r && !Z.call(t, s) || !(s in t) || !U(e[s], t[s])) return !1;
      return Object.keys(t).length === r;
    }
  }
  return e !== e && t !== t;
}
const G = (e) => {
  if (e === null || typeof e != "object")
    return e;
  if (Array.isArray(e))
    return e.sort().map((r) => G(r));
  const t = {}, s = Object.keys(e).sort();
  for (const r of s)
    t[r] = G(e[r]);
  return t;
}, ae = (e, t) => {
  if (t === void 0)
    return;
  if (t === null || typeof t != "object")
    return t;
  if (Array.isArray(t))
    return t.sort().map((o) => G(o));
  const s = {}, r = Object.keys(t).sort();
  for (const o of r)
    s[o] = t[o];
  return s;
}, H = (e, t) => JSON.stringify({ roomName: e, options: t }, ae);
class ge {
  // Track pending releases by room name
  constructor(t, s) {
    this._refCounts = /* @__PURE__ */ new Map(), this._releaseDelayMs = 100, this._pendingReleases = /* @__PURE__ */ new Map(), this._client = t, this._logger = s;
  }
  /**
   * Get the client this manager is associated with.
   * @returns The chat client.
   */
  get client() {
    return this._client;
  }
  /**
   * Increment reference count for a room. Attaches on first reference.
   * @param roomName The name of the room.
   * @param options The room options.
   * @returns A promise that resolves to the room instance.
   */
  async addReference(t, s) {
    this._logger.trace("RoomReferenceManager.addReference();");
    const r = H(t, s), o = this._refCounts.get(r);
    if (o)
      return o.pendingRelease && (clearTimeout(o.pendingRelease), o.pendingRelease = void 0, this._logger.debug("RoomReferenceManager.addReference(); aborted pending release", {
        roomName: t,
        options: s
      })), o.count++, this._logger.debug("RoomReferenceManager.addReference(); incremented ref count", {
        roomName: t,
        options: s,
        count: o.count
      }), o.resolvedRoom ? o.resolvedRoom : new Promise((c, i) => {
        const u = setInterval(() => {
          o.resolvedRoom ? (clearInterval(u), c(o.resolvedRoom)) : o.resolutionError && (clearInterval(u), i(o.resolutionError));
        }, 100);
      });
    const g = this._pendingReleases.get(t);
    if (g) {
      this._logger.debug("RoomReferenceManager.addReference(); waiting for pending release to complete", {
        roomName: t,
        options: s
      });
      try {
        await g;
      } catch (c) {
        this._logger.debug("RoomReferenceManager.addReference(); pending release failed, continuing", {
          roomName: t,
          options: s,
          error: c
        });
      }
    }
    const n = [...this._refCounts.values()].find(
      (c) => c.roomName === t && !U(c.options, s)
    );
    if (n) {
      const c = n.pendingRelease !== void 0, i = n.count <= 0;
      if (!c && !i)
        throw new B.ErrorInfo(
          `unable to get room reference; room "${t}" is already in use with different options`,
          A.RoomExistsWithDifferentOptions,
          400
        );
      this._logger.debug(
        "RoomReferenceManager.addReference(); found existing room with different options, releasing it first",
        {
          roomName: t,
          newOptions: s,
          existingOptions: n.options,
          hasPendingRelease: c,
          hasZeroRefCount: i
        }
      ), n.pendingRelease && (clearTimeout(n.pendingRelease), n.pendingRelease = void 0);
      const u = H(t, n.options);
      this._refCounts.delete(u);
      const f = this._client.rooms.release(t).catch((b) => {
        this._logger.debug("RoomReferenceManager.addReference(); release of existing room failed", {
          roomName: t,
          error: b
        });
      }).finally(() => {
        this._pendingReleases.delete(t);
      });
      this._pendingReleases.set(t, f);
      try {
        await f;
      } catch (b) {
        this._logger.debug("RoomReferenceManager.addReference(); release of existing room failed, continuing", {
          roomName: t,
          error: b
        });
      }
    }
    const a = {
      count: 1,
      roomName: t,
      options: s
    };
    this._refCounts.set(r, a), this._logger.debug("RoomReferenceManager.addReference(); first reference, attaching room", {
      roomName: t,
      options: s
    });
    try {
      const c = await this._client.rooms.get(t, s);
      return a.resolvedRoom = c, c.attach().catch((i) => {
        this._logger.error("RoomReferenceManager.addReference(); error attaching room", {
          roomName: t,
          options: s,
          error: i
        });
      }), c;
    } catch (c) {
      throw a.resolutionError = c, this._refCounts.delete(r), this._logger.error("RoomReferenceManager.addReference(); error creating room", {
        roomName: t,
        options: s,
        error: c
      }), c;
    }
  }
  /**
   * Decrement reference count for a room. Releases on last reference after a delay.
   * @param roomName The name of the room.
   * @param options The room options.
   */
  removeReference(t, s) {
    this._logger.trace("RoomReferenceManager.removeReference();");
    const r = H(t, s), o = this._refCounts.get(r);
    if (!o) {
      this._logger.debug("RoomReferenceManager.removeReference(); no existing reference found", {
        roomName: t,
        options: s
      });
      return;
    }
    o.count--, this._logger.debug("RoomReferenceManager.removeReference(); decremented ref count", {
      roomName: t,
      options: s,
      count: o.count
    }), o.count <= 0 && (this._logger.debug("RoomReferenceManager.removeReference(); scheduling delayed release", {
      roomName: t,
      options: s,
      delayMs: this._releaseDelayMs
    }), o.pendingRelease = setTimeout(() => {
      const g = this._refCounts.get(r);
      if (g && g.count <= 0) {
        this._refCounts.delete(r), this._logger.debug("RoomReferenceManager.removeReference(); executing delayed release", {
          roomName: t,
          options: s
        });
        const n = this._client.rooms.release(t).catch((a) => {
          this._logger.debug("RoomReferenceManager.removeReference(); release failed", {
            roomName: t,
            options: s,
            error: a
          });
        }).finally(() => {
          this._pendingReleases.delete(t);
        });
        this._pendingReleases.set(t, n);
      }
    }, this._releaseDelayMs));
  }
  getReferenceCount(t, s) {
    this._logger.trace("RoomReferenceManager.getReferenceCount();");
    const r = H(t, s);
    return this._refCounts.get(r)?.count ?? 0;
  }
}
const re = Symbol("roomReferenceManager"), le = () => {
  const t = q.useContext(K)[re];
  if (!t)
    throw new B.ErrorInfo(
      "unable to get room reference manager; useRoomReferenceManager must be used within a ChatClientProvider",
      A.ReactHookMustBeUsedWithinProvider,
      400
    );
  return t;
}, se = "default", ye = ({ children: e, client: t }) => {
  const s = q.useContext(K), r = w(void 0), o = q.useMemo(() => {
    if (t.addReactAgent(), r.current?.client !== t) {
      const n = t.logger;
      r.current = new ge(t, n);
    }
    const g = globalThis.__ABLY_CHAT_REACT_UI_KIT_VERSION__;
    return typeof g == "string" && t.addAgentWithVersion("chat-react-ui-kit", g), {
      ...s,
      [se]: { client: t },
      [re]: r.current
    };
  }, [t, s]);
  return /* @__PURE__ */ te(K.Provider, { value: o, children: e });
}, W = () => {
  const e = ee.useContext(K)[se];
  if (!e)
    throw new B.ErrorInfo(
      "unable to get chat client; useChatClient hook must be used within a chat client provider",
      A.ReactHookMustBeUsedWithinProvider,
      400
    );
  return e.client;
}, T = (e) => {
  const t = ie(ne);
  if (!t)
    throw new B.ErrorInfo(
      `unable to get room context; ${e} hook must be used within a <ChatRoomProvider>`,
      A.ReactHookMustBeUsedWithinProvider,
      400
    );
  return t;
}, X = () => {
  const e = W();
  return Y(() => e.logger, [e]);
}, E = () => {
  const e = T("useRoomLogger"), t = W();
  return Y(
    () => t.logger.withContext({ roomName: e.roomName }),
    [t, e]
  );
}, pe = () => {
  const e = W(), t = X(), [s, r] = D(() => (t.debug("useChatClient(); setting initial clientId", { clientId: e.clientId }), e.clientId));
  return m(() => {
    t.debug("useChatClient(); subscribing to connection status changes", {
      clientId: e.clientId
    }), r(e.clientId);
    const { off: o } = e.connection.onStatusChange((g) => {
      g.current === z.Connected && (t.debug("useChatClient(); connection status is now connected", {
        clientId: e.clientId
      }), r(e.clientId));
    });
    return () => {
      t.debug("useChatClient(); unsubscribing from connection status changes"), o();
    };
  }, [e, t]), {
    clientId: s
  };
}, _ = (e) => {
  const t = w(e);
  m(() => {
    t.current = e;
  });
  const s = C((...r) => {
    t.current && t.current(...r);
  }, []);
  return e ? s : void 0;
}, k = (e) => {
  const t = W(), s = X();
  s.trace("useChatConnection();", e);
  const [r, o] = D(t.connection.status), [g, n] = D(t.connection.error);
  m(() => {
    n(t.connection.error), o(t.connection.status);
  }, [t]);
  const a = _(e?.onStatusChange);
  return m(() => {
    s.debug("useChatConnection(); applying internal listener");
    const { off: c } = t.connection.onStatusChange((i) => {
      o(i.current), n(i.error);
    });
    return () => {
      s.debug("useChatConnection(); cleaning up listener"), c();
    };
  }, [t.connection, s]), m(() => {
    if (!a) return;
    s.debug("useChatConnection(); applying client listener");
    const { off: c } = t.connection.onStatusChange(a);
    return () => {
      s.debug("useChatConnection(); cleaning up client listener"), c();
    };
  }, [t.connection, s, a]), {
    currentStatus: r,
    error: g
  };
};
class de {
  /**
   * Creates a new DefaultRoomPromise and starts the resolution of the promise.
   * @param room  The promise that resolves to a Room instance.
   * @param onResolve  The callback that is called when the promise resolves to a Room instance.
   * @param logger  The logger to use for logging.
   */
  constructor(t, s, r) {
    this._unmounted = !1, this._onResolve = s, this._logger = r, this.mount(t).catch((o) => {
      this._logger.trace("DefaultRoomPromise(); mount error", { error: o });
    });
  }
  /**
   * Wait for the room promise to resolve, then execute the onResolve callback, storing its response as an unmount function.
   * If the component is unmounted before the promise resolves, then this will do nothing.
   * @param promise The promise that resolves to a Room instance.
   * @returns A promise that we simply resolve when it's done.
   */
  async mount(t) {
    this._logger.debug("DefaultRoomPromise(); mount");
    try {
      const s = await t;
      if (this._unmounted)
        return;
      this._logger.debug("DefaultRoomPromise(); mount resolved"), this._onUnmount = this._onResolve(s);
    } catch (s) {
      this._logger.error("DefaultRoomPromise(); mount error", { error: s });
    }
  }
  /**
   * Returns a function to be called when the component is unmounted. If the room promise has resolved at the time
   * of calling, then the unmount function returned by the onResolve callback will be called.
   *
   * Multiple calls are no-op.
   *
   * Example usage:
   *
   * ```ts
   * useEffect(() => {
   * const roomPromise = wrapRoomPromise(...);
   * return roomPromise.unmount();
   * }, []);
   * ```
   * @returns A function that should be called when the component is unmounted.
   */
  unmount() {
    return this._unmounted ? () => {
    } : () => {
      this._logger.debug("DefaultRoomPromise(); unmount"), this._unmounted = !0, this._onUnmount?.();
    };
  }
}
const y = (e, t, s) => new de(e, t, s);
var L = /* @__PURE__ */ ((e) => (e.Initializing = "initializing", e.Initialized = "initialized", e.Attaching = "attaching", e.Attached = "attached", e.Detaching = "detaching", e.Detached = "detached", e.Suspended = "suspended", e.Failed = "failed", e.Releasing = "releasing", e.Released = "released", e))(L || {});
const F = (e) => {
  const t = T("useRoomStatus"), [s, r] = D(L.Initializing), [o, g] = D(), n = E(), a = _(e?.onRoomStatusChange);
  return m(() => y(
    t.room,
    (i) => {
      n.debug("useRoomStatus(); subscribing internal listener"), r(i.status), g(i.error);
      const { off: u } = i.onStatusChange((f) => {
        n.debug("useRoomStatus(); status change", f), r(f.current), g(f.error);
      });
      return () => {
        n.debug("useRoomStatus(); unsubscribing internal listener"), u();
      };
    },
    n
  ).unmount(), [t, n]), m(() => y(
    t.room,
    (i) => {
      let u;
      return a && (n.debug("useRoomStatus(); subscribing to status changes"), u = i.onStatusChange(a).off), n.debug("useRoomStatus(); setting initial status", { status: i.status }), a && (n.debug("useRoomStatus(); sending initial status event"), a({
        current: i.status,
        previous: L.Initializing,
        error: i.error
      })), () => {
        n.debug("useRoomStatus(); unmounting"), u && (n.debug("useRoomStatus(); unsubscribing from status changes"), u());
      };
    },
    n
  ).unmount(), [t, n, a]), {
    status: s,
    error: o
  };
}, Ce = (e) => {
  const { currentStatus: t, error: s } = k({
    onStatusChange: e?.onConnectionStatusChange
  }), r = T("useMessages"), { status: o, error: g } = F(e), n = E();
  n.trace("useMessages();", { params: e });
  const a = _(e?.listener), c = _(e?.reactionsListener), i = _(e?.rawReactionsListener), u = _(e?.onDiscontinuity), f = C(
    async (d) => (await r.room).messages.send(d),
    [r]
  ), b = C(
    async (d) => (await r.room).messages.get(d),
    [r]
  ), v = C(
    async (d, l) => (await r.room).messages.delete(d, l),
    [r]
  ), S = C(
    async (d) => (await r.room).messages.history(d),
    [r]
  ), h = C(
    async (d, l, p) => (await r.room).messages.update(d, l, p),
    [r]
  ), I = C(
    async (d, l) => (await r.room).messages.reactions.send(d, l),
    [r]
  ), P = C(
    async (d, l) => (await r.room).messages.reactions.delete(d, l),
    [r]
  ), [O, R] = D();
  return m(() => {
    if (a)
      return y(
        r.room,
        (d) => {
          let l = !1;
          n.debug("useMessages(); applying listener");
          const p = d.messages.subscribe(a);
          return R(() => {
            if (n.debug("useMessages(); setting historyBeforeSubscribe state", {
              status: d.status,
              unmounted: l
            }), !l)
              return async (x) => {
                if (n.debug("useMessages(); historyBeforeSubscribe called"), l)
                  throw new B.ErrorInfo(
                    "unable to query messages; component unmounted",
                    A.ReactComponentUnmounted,
                    400
                  );
                return p.historyBeforeSubscribe(x);
              };
          }), () => {
            n.debug("useMessages(); removing listener and historyBeforeSubscribe state"), l = !0, p.unsubscribe(), R(void 0);
          };
        },
        n
      ).unmount();
  }, [r, n, a]), m(() => {
    if (u)
      return y(
        r.room,
        (d) => {
          n.debug("useMessages(); applying onDiscontinuity listener");
          const { off: l } = d.onDiscontinuity(u);
          return () => {
            n.debug("useMessages(); removing onDiscontinuity listener"), l();
          };
        },
        n
      ).unmount();
  }, [r, n, u]), m(() => {
    if (c)
      return y(
        r.room,
        (d) => {
          n.debug("useMessages(); applying reactions listener");
          const { unsubscribe: l } = d.messages.reactions.subscribe(c);
          return () => {
            n.debug("useMessages(); removing reactions listener"), l();
          };
        },
        n
      ).unmount();
  }, [r, n, c]), m(() => {
    if (i)
      return y(
        r.room,
        (d) => {
          n.debug("useMessages(); applying raw reactions listener");
          const { unsubscribe: l } = d.messages.reactions.subscribeRaw(i);
          return () => {
            n.debug("useMessages(); removing raw reactions listener"), l();
          };
        },
        n
      ).unmount();
  }, [r, n, i]), {
    connectionStatus: t,
    connectionError: s,
    roomStatus: o,
    roomError: g,
    sendMessage: f,
    getMessage: b,
    updateMessage: h,
    history: S,
    deleteMessage: v,
    sendReaction: I,
    deleteReaction: P,
    historyBeforeSubscribe: O
  };
}, ve = (e) => {
  const { currentStatus: t, error: s } = k({
    onStatusChange: e?.onConnectionStatusChange
  }), r = T("useOccupancy"), { status: o, error: g } = F(e), n = E();
  n.trace("useOccupancy();", { params: e });
  const [a, c] = D({
    connections: 0,
    presenceMembers: 0
  }), i = _(e?.listener), u = _(e?.onDiscontinuity);
  return m(() => {
    if (u)
      return y(
        r.room,
        (f) => {
          n.debug("useOccupancy(); applying onDiscontinuity listener");
          const { off: b } = f.onDiscontinuity(u);
          return () => {
            n.debug("useOccupancy(); removing onDiscontinuity listener"), b();
          };
        },
        n
      ).unmount();
  }, [r, u, n]), m(() => y(
    r.room,
    (b) => {
      n.debug("useOccupancy(); applying internal listener");
      const v = b.occupancy.current;
      c({
        connections: v?.connections ?? 0,
        presenceMembers: v?.presenceMembers ?? 0
      });
      const { unsubscribe: S } = b.occupancy.subscribe((h) => {
        c({
          connections: h.occupancy.connections,
          presenceMembers: h.occupancy.presenceMembers
        });
      });
      return () => {
        n.debug("useOccupancy(); cleaning up internal listener"), S();
      };
    },
    n
  ).unmount(), [r, n]), m(() => {
    if (i)
      return y(
        r.room,
        (f) => {
          n.debug("useOccupancy(); applying listener");
          const { unsubscribe: b } = f.occupancy.subscribe(i);
          return () => {
            n.debug("useOccupancy(); cleaning up listener"), b();
          };
        },
        n
      ).unmount();
  }, [i, r, n]), {
    connectionStatus: t,
    connectionError: s,
    roomStatus: o,
    roomError: g,
    connections: a.connections,
    presenceMembers: a.presenceMembers
  };
}, N = /* @__PURE__ */ new Set([
  z.Suspended,
  z.Failed,
  z.Closing,
  z.Closed
]), _e = (e) => {
  const { currentStatus: t, error: s } = k({
    onStatusChange: e?.onConnectionStatusChange
  }), r = T("usePresence"), { status: o, error: g } = F(e), n = E();
  n.trace("usePresence();", { params: e });
  const a = Y(() => e?.autoEnterLeave !== !1, [e?.autoEnterLeave]), [c, i] = D({
    present: !1,
    error: void 0
  }), u = w({ roomStatus: o, connectionStatus: t }), f = _(e?.onDiscontinuity), b = w(e?.initialData), v = w(!1), S = w(!1), h = w(!1);
  m(() => {
    S.current = !1, h.current = !1;
  }, [r]), m(() => {
    u.current = { roomStatus: o, connectionStatus: t }, o === L.Detached && (h.current = !0);
  }, [o, t]), m(() => (n.debug("usePresence(); subscribing to presence state changes"), y(
    r.room,
    (R) => {
      const d = R.presence.onPresenceStateChange(
        (l) => {
          n.debug("usePresence(); presence state changed", { stateChange: l }), i({
            ...l.current,
            error: l.error
          });
        }
      );
      return () => {
        n.debug("usePresence(); unsubscribing from presence state changes"), d.unsubscribe();
      };
    },
    n
  ).unmount()), [r, n]), m(() => (n.debug("usePresence(); running auto-enter hook"), a ? y(
    r.room,
    (R) => {
      const d = R.status === L.Attached && !N.has(t), l = !S.current || h.current;
      return !d || v.current || !l ? (n.debug("usePresence(); skipping enter room", {
        roomStatus: o,
        connectionStatus: t,
        hasExplicitlyLeft: v.current,
        shouldAutoEnter: l,
        hasAutoEntered: S.current,
        roomWasDetached: h.current
      }), () => {
      }) : (n.debug("usePresence(); entering room"), R.presence.enter(b.current).then(() => {
        n.debug("usePresence(); entered room"), S.current = !0, h.current = !1;
      }).catch((p) => {
        n.error("usePresence(); error entering room", { error: p });
      }), () => {
        const p = R.status === L.Attached && !N.has(u.current.connectionStatus);
        n.debug("usePresence(); unmounting", {
          canLeavePresence: p,
          roomStatus: o,
          connectionStatus: t
        }), p && !v.current && R.presence.leave().then(() => {
          n.debug("usePresence(); left room");
        }).catch((x) => {
          n.error("usePresence(); error leaving room", { error: x });
        });
      });
    },
    n
  ).unmount() : (n.debug("usePresence(); auto enter/leave disabled"), () => {
  })), [r, t, o, n, a]), m(() => {
    if (f)
      return y(
        r.room,
        (R) => {
          const { off: d } = R.onDiscontinuity(f);
          return () => {
            n.debug("usePresence(); removing onDiscontinuity listener"), d();
          };
        },
        n
      ).unmount();
  }, [r, f, n]);
  const I = C(
    async (R) => {
      b.current = R, v.current = !1, await (await r.room).presence.update(R);
    },
    [r]
  ), P = C(
    async (R) => {
      b.current = R, v.current = !1, await (await r.room).presence.enter(R);
    },
    [r]
  ), O = C(
    async (R) => {
      v.current = !0, await (await r.room).presence.leave(R);
    },
    [r]
  );
  return {
    connectionStatus: t,
    connectionError: s,
    roomStatus: o,
    roomError: g,
    update: I,
    enter: P,
    leave: O,
    myPresenceState: c
  };
}, fe = 1500, he = 3e4, me = 5, Se = (e) => {
  const { currentStatus: t, error: s } = k({
    onStatusChange: e?.onConnectionStatusChange
  }), r = T("usePresenceListener"), { status: o, error: g } = F(e), n = E();
  n.trace("usePresenceListener();");
  const a = w(0), c = w(0), i = w(void 0), u = w(0), f = w([]), [b, v] = D([]), S = w(void 0), [h, I] = D(), P = _(e?.listener), O = _(e?.onDiscontinuity), R = C(
    (l) => {
      n.debug("usePresenceListener(); setting error state", { error: l }), S.current = l, I(l);
    },
    [n]
  ), d = C(() => {
    n.debug("usePresenceListener(); clearing error state"), S.current = void 0, I(void 0);
  }, [n]);
  return m(() => {
    const l = () => {
      a.current += 1, i.current && (clearTimeout(i.current), i.current = void 0, u.current = 0), p(a.current);
    }, p = (x) => {
      y(
        r.room,
        (j) => (j.presence.get({ waitForSync: !0 }).then((M) => {
          n.debug("usePresenceListener(); fetched presence data", { presenceMembers: M }), i.current && (clearTimeout(i.current), i.current = void 0, u.current = 0), !(c.current >= x) && (c.current = x, f.current = M, v(M), S.current && d());
        }).catch(() => {
          if (!(u.current < me)) {
            n.error("usePresenceListener(); failed to fetch presence data after max retries"), R(
              new B.ErrorInfo(
                "unable to fetch presence data; failed after max retries",
                A.PresenceFetchFailed,
                500
              )
            );
            return;
          }
          if (i.current) {
            n.debug("usePresenceListener(); waiting for retry but new event received");
            return;
          }
          const V = Math.min(
            he,
            fe * Math.pow(2, u.current)
          );
          u.current += 1, n.debug("usePresenceListener(); retrying to fetch presence data", {
            numRetries: u.current
          }), i.current = setTimeout(() => {
            i.current = void 0, a.current += 1, p(a.current);
          }, V);
        }), () => {
        }),
        n
      );
    };
    return y(
      r.room,
      (x) => {
        let j;
        return x.status === L.Attached ? x.presence.get({ waitForSync: !0 }).then((M) => {
          n.debug("usePresenceListener(); fetched initial presence data", {
            presenceMembers: M
          }), f.current = M, v(M), d();
        }).catch((M) => {
          const V = M;
          ce(V, A.RoomInInvalidState) || (n.error("usePresenceListener(); error fetching initial presence data", {
            error: M
          }), R(V));
        }).finally(() => {
          n.debug("usePresenceListener(); subscribing internal listener to presence events"), j = x.presence.subscribe(() => {
            l();
          }).unsubscribe;
        }) : (n.debug("usePresenceListener(); not yet attached, subscribing internal listener to presence events"), j = x.presence.subscribe(() => {
          l();
        }).unsubscribe), () => {
          j && (n.debug("usePresenceListener(); cleaning up internal listener"), j());
        };
      },
      n
    ).unmount();
  }, [r, R, d, n]), m(() => {
    if (P)
      return y(
        r.room,
        (l) => {
          n.debug("usePresenceListener(); applying external listener");
          const { unsubscribe: p } = l.presence.subscribe(P);
          return () => {
            n.debug("usePresenceListener(); cleaning up external listener"), p();
          };
        },
        n
      ).unmount();
  }, [r, P, n]), m(() => {
    if (O)
      return y(
        r.room,
        (l) => {
          n.debug("usePresenceListener(); applying onDiscontinuity listener");
          const { off: p } = l.onDiscontinuity(O);
          return () => {
            n.debug("usePresenceListener(); removing onDiscontinuity listener"), p();
          };
        },
        n
      ).unmount();
  }, [r, O, n]), {
    connectionStatus: t,
    connectionError: s,
    roomStatus: o,
    roomError: g,
    error: h,
    presenceData: b
  };
}, Pe = (e) => {
  const t = T("useRoom"), s = t.roomName;
  E().debug("useRoom();");
  const { currentStatus: o, error: g } = k({
    onStatusChange: e?.onConnectionStatusChange
  }), n = F({
    onRoomStatusChange: e?.onStatusChange
  }), a = C(async () => (await t.room).attach(), [t]), c = C(async () => (await t.room).detach(), [t]);
  return {
    roomName: s,
    attach: a,
    detach: c,
    roomStatus: n.status,
    roomError: n.error,
    connectionStatus: o,
    connectionError: g
  };
}, Me = (e) => {
  const { currentStatus: t, error: s } = k({
    onStatusChange: e?.onConnectionStatusChange
  }), r = T("useRoomReactions"), { status: o, error: g } = F(e), n = E();
  n.trace("useRoomReactions();", { params: e });
  const a = _(e?.listener), c = _(e?.onDiscontinuity);
  m(() => {
    if (c)
      return y(
        r.room,
        (u) => {
          n.debug("useRoomReactions(); applying onDiscontinuity listener");
          const { off: f } = u.onDiscontinuity(c);
          return () => {
            n.debug("useRoomReactions(); removing onDiscontinuity listener"), f();
          };
        },
        n
      ).unmount();
  }, [r, c, n]), m(() => {
    if (a)
      return y(
        r.room,
        (u) => {
          n.debug("useRoomReactions(); applying listener");
          const { unsubscribe: f } = u.reactions.subscribe(a);
          return () => {
            n.debug("useRoomReactions(); removing listener"), f();
          };
        },
        n
      ).unmount();
  }, [r, a, n]);
  const i = C(
    async (u) => (await r.room).reactions.send(u),
    [r]
  );
  return {
    connectionStatus: t,
    connectionError: s,
    roomStatus: o,
    roomError: g,
    sendRoomReaction: i
  };
}, we = (e) => {
  const { currentStatus: t, error: s } = k({
    onStatusChange: e?.onConnectionStatusChange
  }), r = T("useTyping"), { status: o, error: g } = F(e), n = E();
  n.trace("useTyping();");
  const [a, c] = D(/* @__PURE__ */ new Set()), [i, u] = D([]), f = _(e?.listener), b = _(e?.onDiscontinuity);
  m(() => (c((h) => h.size === 0 ? h : /* @__PURE__ */ new Set()), u((h) => h.length === 0 ? h : []), y(
    r.room,
    (h) => {
      n.debug("useTyping(); subscribing to typing events");
      const { unsubscribe: I } = h.typing.subscribe((P) => {
        c(P.currentlyTyping), u(P.currentTypers);
      });
      if (h.status === L.Attached) {
        const P = h.typing.current;
        n.debug("useTyping(); room attached, getting initial typers", { typing: P }), c(P), u(h.typing.currentTypers);
      }
      return () => {
        n.debug("useTyping(); unsubscribing from typing events"), I();
      };
    },
    n
  ).unmount()), [r, n]), m(() => {
    if (b)
      return y(
        r.room,
        (h) => {
          n.debug("useTyping(); applying onDiscontinuity listener");
          const { off: I } = h.onDiscontinuity(b);
          return () => {
            n.debug("useTyping(); removing onDiscontinuity listener"), I();
          };
        },
        n
      ).unmount();
  }, [r, b, n]), m(() => {
    if (f)
      return y(
        r.room,
        (h) => {
          n.debug("useTyping(); applying listener");
          const { unsubscribe: I } = h.typing.subscribe(f);
          return () => {
            n.debug("useTyping(); removing listener"), I();
          };
        },
        n
      ).unmount();
  }, [r, f, n]);
  const v = C(async () => (await r.room).typing.keystroke(), [r]), S = C(async () => (await r.room).typing.stop(), [r]);
  return {
    connectionStatus: t,
    connectionError: s,
    roomStatus: o,
    roomError: g,
    keystroke: v,
    stop: S,
    currentlyTyping: a,
    currentTypers: i
  };
}, De = ({ name: e, options: t, children: s }) => {
  const r = W(), o = X(), g = Y(() => o.withContext({ roomName: e }), [o, e]), n = le();
  g.debug("ChatRoomProvider();", { options: t });
  const [a, c] = D(() => {
    g.debug("ChatRoomProvider(); initializing value", { options: t });
    const i = r.rooms.get(e, t);
    return i.catch(() => {
    }), { room: i, roomName: e, options: t, client: r };
  });
  return m(() => {
    g.debug("ChatRoomProvider(); running lifecycle useEffect");
    let i = !1;
    const u = n.addReference(e, t);
    return c((f) => f.client === r && f.roomName === e && f.options === t ? (g.debug("ChatRoomProvider(); no change in room id or options", { options: t }), f) : (g.debug("ChatRoomProvider(); updating value", { options: t }), { room: u, roomName: e, options: t, client: r })), u.then(() => {
      if (i) {
        g.debug("ChatRoomProvider(); unmounted before room resolved");
        return;
      }
      g.debug("ChatRoomProvider(); room resolved");
    }).catch(() => {
    }), () => {
      i = !0, g.debug("ChatRoomProvider(); cleaning up lifecycle useEffect"), n.removeReference(e, t);
    };
  }, [e, t, g, r, n]), /* @__PURE__ */ te(ne.Provider, { value: a, children: s });
};
export {
  ye as ChatClientProvider,
  ne as ChatRoomContext,
  De as ChatRoomProvider,
  pe as useChatClient,
  k as useChatConnection,
  Ce as useMessages,
  ve as useOccupancy,
  _e as usePresence,
  Se as usePresenceListener,
  Pe as useRoom,
  Me as useRoomReactions,
  we as useTyping
};
//# sourceMappingURL=ably-chat-react.js.map
