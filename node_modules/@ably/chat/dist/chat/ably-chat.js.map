{"version":3,"file":"ably-chat.js","sources":["../../src/core/errors.ts","../../src/core/client-id.ts","../../src/core/logger.ts","../../src/core/config.ts","../../src/core/realtime-subscriptions.ts","../../src/core/utils/event-emitter.ts","../../src/core/connection.ts","../../src/core/id.ts","../../node_modules/dequal/dist/index.mjs","../../src/core/events.ts","../../node_modules/lodash.clonedeep/index.js","../../src/core/message.ts","../../src/core/realtime-extensions.ts","../../src/core/message-parser.ts","../../src/core/serial.ts","../../src/core/message-reactions.ts","../../src/core/rest-types.ts","../../src/core/messages.ts","../../src/core/chat-api.ts","../../src/core/channel.ts","../../src/core/version.ts","../../src/core/channel-manager.ts","../../src/core/occupancy-parser.ts","../../src/core/occupancy.ts","../../src/core/presence.ts","../../node_modules/async-mutex/index.mjs","../../src/core/room-status.ts","../../src/core/room-lifecycle-manager.ts","../../src/core/room-options.ts","../../src/core/realtime.ts","../../src/core/room-reaction.ts","../../src/core/room-reaction-parser.ts","../../src/core/room-reactions.ts","../../src/core/typing.ts","../../src/core/room.ts","../../src/core/rooms.ts","../../src/core/chat-client.ts"],"sourcesContent":["import * as Ably from 'ably';\n\n/**\n * Error codes for the Chat SDK.\n */\nexport enum ErrorCode {\n  /**\n   * The request was invalid.\n   */\n  BadRequest = 40000,\n\n  /**\n   * Invalid argument provided.\n   */\n  InvalidArgument = 40003,\n\n  /**\n   * Invalid client ID.\n   */\n  InvalidClientId = 40012,\n\n  /**\n   * Resource has been disposed.\n   */\n  ResourceDisposed = 40014,\n\n  /**\n   * The message was rejected before publishing by a rule on the chat room.\n   */\n  MessageRejectedByBeforePublishRule = 42211,\n\n  /**\n   * The message was rejected before publishing by a moderation rule on the chat room.\n   */\n  MessageRejectedByModeration = 42213,\n\n  /**\n   * The client is not connected to Ably.\n   */\n  Disconnected = 80003,\n\n  /**\n   * Could not re-enter presence automatically after a room re-attach occurred.\n   */\n  PresenceAutoReentryFailed = 91004,\n\n  /**\n   * The room has experienced a discontinuity.\n   */\n  RoomDiscontinuity = 102100,\n\n  // Unable to perform operation;\n\n  /**\n   * Cannot perform operation because the room is in an invalid state.\n   */\n  RoomInInvalidState = 102112,\n\n  /**\n   * Room was released before the operation could complete.\n   */\n  RoomReleasedBeforeOperationCompleted = 102106,\n\n  /**\n   * A room already exists with different options.\n   */\n  RoomExistsWithDifferentOptions = 102107,\n\n  /**\n   * Feature is not enabled in room options.\n   */\n  FeatureNotEnabledInRoom = 102108,\n\n  /**\n   * Listener has not been subscribed yet.\n   */\n  ListenerNotSubscribed = 102109,\n\n  /**\n   * Channel serial is not defined when expected.\n   */\n  ChannelSerialNotDefined = 102110,\n\n  /**\n   * Channel options cannot be modified after the channel has been requested.\n   */\n  ChannelOptionsCannotBeModified = 102111,\n\n  /**\n   * Failed to enforce sequential execution of the operation.\n   */\n  OperationSerializationFailed = 102113,\n\n  // 102200 - 102300 are reserved for React errors\n\n  /**\n   * React hook must be used within the appropriate provider.\n   */\n  ReactHookMustBeUsedWithinProvider = 102200,\n\n  /**\n   * React component has been unmounted.\n   */\n  ReactComponentUnmounted = 102201,\n\n  /**\n   * Failed to fetch presence data after maximum retries.\n   */\n  PresenceFetchFailed = 102202,\n}\n\n/**\n * Returns true if the {@link Ably.ErrorInfo} code matches the provided ErrorCode value.\n * @param errorInfo The error info to check.\n * @param error The error code to compare against.\n * @returns true if the error code matches, false otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\nexport const errorInfoIs = (errorInfo: Ably.ErrorInfo, error: ErrorCode): boolean => errorInfo.code === error;\n","import * as Ably from 'ably';\n\nimport { ErrorCode } from './errors.js';\nimport { Logger } from './logger.js';\n\n/**\n * Interface for a type that resolves the current clientId from the realtime client.\n */\nexport interface ClientIdResolver {\n  /**\n   * Return the current clientId, throwing an exception if one isn't set.\n   * @throws An {@link Ably.ErrorInfo} if no clientId is set.\n   * @returns string The resolved clientId\n   */\n  get(): string;\n}\n\nexport class DefaultClientIdResolver implements ClientIdResolver {\n  constructor(\n    private _realtime: Ably.Realtime,\n    private _logger: Logger,\n  ) {}\n\n  get(): string {\n    const clientId = this._realtime.auth.clientId;\n    if (!clientId) {\n      this._logger.error('unable to get client id; client id is not set', { clientId });\n      throw new Ably.ErrorInfo('unable to get client id; client id is not set', ErrorCode.InvalidClientId, 400);\n    }\n\n    return clientId;\n  }\n}\n","import * as Ably from 'ably';\n\nimport { NormalizedChatClientOptions } from './config.js';\nimport { ErrorCode } from './errors.js';\n\n/**\n * Interface for loggers.\n */\nexport interface Logger {\n  /**\n   * Log a message at the trace level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  trace(message: string, context?: LogContext): void;\n\n  /**\n   * Log a message at the debug level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  debug(message: string, context?: LogContext): void;\n\n  /**\n   * Log a message at the info level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  info(message: string, context?: LogContext): void;\n\n  /**\n   * Log a message at the warn level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  warn(message: string, context?: LogContext): void;\n\n  /**\n   * Log a message at the error level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  error(message: string, context?: LogContext): void;\n\n  /**\n   * Creates a new logger with a context that will be merged with any context provided to individual log calls.\n   * The context will be overridden by any matching keys in the individual log call's context.\n   * @param context The context to use for all log calls.\n   * @returns A new logger instance with the context.\n   */\n  withContext(context: LogContext): Logger;\n}\n\n/**\n * Represents the different levels of logging that can be used.\n */\nexport enum LogLevel {\n  /**\n   * Something routine and expected has occurred. This level will provide logs for the vast majority of operations\n   * and function calls.\n   */\n  Trace = 'trace',\n\n  /**\n   * Development information, messages that are useful when trying to debug library behavior,\n   * but superfluous to normal operation.\n   */\n  Debug = 'debug',\n\n  /**\n   * Informational messages. Operationally significant to the library but not out of the ordinary.\n   */\n  Info = 'info',\n\n  /**\n   * Anything that is not immediately an error, but could cause unexpected behavior in the future. For example,\n   * passing an invalid value to an option. Indicates that some action should be taken to prevent future errors.\n   */\n  Warn = 'warn',\n\n  /**\n   * A given operation has failed and cannot be automatically recovered. The error may threaten the continuity\n   * of operation.\n   */\n  Error = 'error',\n\n  /**\n   * No logging will be performed.\n   */\n  Silent = 'silent',\n}\n\n/**\n * Represents the context of a log message.\n * It is an object of key-value pairs that can be used to provide additional context to a log message.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type LogContext = Record<string, any>;\n\n/**\n * A function that can be used to handle log messages.\n * @param message The message to log.\n * @param level The log level of the message.\n * @param context The context of the log message as key-value pairs.\n */\nexport type LogHandler = (message: string, level: LogLevel, context?: LogContext) => void;\n\n/**\n * A simple console logger that logs messages to the console.\n * @param message The message to log.\n * @param level The log level of the message.\n * @param context - The context of the log message as key-value pairs.\n */\nexport const consoleLogger = (message: string, level: LogLevel, context?: LogContext) => {\n  const contextString = context ? `, context: ${JSON.stringify(context)}` : '';\n  const formattedMessage = `[${new Date().toISOString()}] ${level.valueOf().toUpperCase()} ably-chat: ${message}${contextString}`;\n\n  switch (level) {\n    case LogLevel.Trace:\n    case LogLevel.Debug: {\n      console.log(formattedMessage);\n      break;\n    }\n    case LogLevel.Info: {\n      console.info(formattedMessage);\n      break;\n    }\n    case LogLevel.Warn: {\n      console.warn(formattedMessage);\n      break;\n    }\n    case LogLevel.Error: {\n      console.error(formattedMessage);\n      break;\n    }\n    case LogLevel.Silent: {\n      break;\n    }\n  }\n};\n\nexport const makeLogger = (options: NormalizedChatClientOptions): Logger => {\n  const logHandler = options.logHandler ?? consoleLogger;\n\n  return new DefaultLogger(logHandler, options.logLevel);\n};\n\n/**\n * A convenient list of log levels as numbers that can be used for easier comparison.\n */\nenum LogLevelNumber {\n  Trace = 0,\n  Debug = 1,\n  Info = 2,\n  Warn = 3,\n  Error = 4,\n  Silent = 5,\n}\n\n/**\n * A mapping of log levels to their numeric equivalents.\n */\nconst logLevelNumberMap = new Map<LogLevel, LogLevelNumber>([\n  [LogLevel.Trace, LogLevelNumber.Trace],\n  [LogLevel.Debug, LogLevelNumber.Debug],\n  [LogLevel.Info, LogLevelNumber.Info],\n  [LogLevel.Warn, LogLevelNumber.Warn],\n  [LogLevel.Error, LogLevelNumber.Error],\n  [LogLevel.Silent, LogLevelNumber.Silent],\n]);\n\n/**\n * A default logger implementation.\n */\nclass DefaultLogger implements Logger {\n  private readonly _handler: LogHandler;\n  private readonly _levelNumber: LogLevelNumber;\n  private readonly _context?: LogContext;\n\n  constructor(handler: LogHandler, level: LogLevel, context?: LogContext) {\n    this._handler = handler;\n    this._context = context;\n\n    const levelNumber = logLevelNumberMap.get(level);\n    if (levelNumber === undefined) {\n      throw new Ably.ErrorInfo(`unable to create logger; invalid log level: ${level}`, ErrorCode.InvalidArgument, 400);\n    }\n\n    this._levelNumber = levelNumber;\n  }\n\n  trace(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Trace, LogLevelNumber.Trace, context);\n  }\n\n  debug(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Debug, LogLevelNumber.Debug, context);\n  }\n\n  info(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Info, LogLevelNumber.Info, context);\n  }\n\n  warn(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Warn, LogLevelNumber.Warn, context);\n  }\n\n  error(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Error, LogLevelNumber.Error, context);\n  }\n\n  withContext(context: LogContext): Logger {\n    // Get the original log level by finding the key in logLevelNumberMap that matches this._levelNumber\n    const originalLevel =\n      [...logLevelNumberMap.entries()].find(([, value]) => value === this._levelNumber)?.[0] ?? LogLevel.Error;\n\n    return new DefaultLogger(this._handler, originalLevel, this._mergeContext(context));\n  }\n\n  private _write(message: string, level: LogLevel, levelNumber: LogLevelNumber, context?: LogContext): void {\n    if (levelNumber >= this._levelNumber) {\n      this._handler(message, level, this._mergeContext(context));\n    }\n  }\n\n  private _mergeContext(context?: LogContext): LogContext | undefined {\n    if (!this._context) {\n      return context ?? undefined;\n    }\n\n    return context ? { ...this._context, ...context } : this._context;\n  }\n}\n","import { LogHandler, LogLevel } from './logger.js';\n\n/**\n * Configuration options for the chat client.\n */\nexport interface ChatClientOptions {\n  /**\n   * A custom log handler that will be used to log messages from the client.\n   * @defaultValue The client will log messages to the console.\n   */\n  logHandler?: LogHandler;\n\n  /**\n   * The minimum log level at which messages will be logged.\n   * @defaultValue LogLevel.error\n   */\n  logLevel?: LogLevel;\n}\n\n/**\n * Default configuration options for the chat client.\n */\nconst defaultClientOptions = {\n  logLevel: LogLevel.Error,\n};\n\n/**\n * This type is used to modify the properties of one type with the properties of another type and thus\n * can be used to turn client options into normalized client options.\n */\ntype Modify<T, R> = Omit<T, keyof R> & R;\n\n/**\n * These are the normalized client options, with default values filled in for any missing properties.\n */\nexport type NormalizedChatClientOptions = Modify<\n  ChatClientOptions,\n  {\n    logLevel: LogLevel;\n  }\n>;\n\nexport const normalizeClientOptions = (options?: ChatClientOptions): NormalizedChatClientOptions => {\n  options = options ?? {};\n\n  return {\n    ...options,\n    logLevel: options.logLevel ?? defaultClientOptions.logLevel,\n  };\n};\n","/**\n * Interface for objects that support listeners via the on/off pattern.\n */\nexport interface Onable<T> {\n  /**\n   * Subscribe to events with a callback.\n   * @param callback The callback function to be called when events occur.\n   */\n  on(callback: (data: T) => void): void;\n\n  /**\n   * Subscribe to specific events, with a callback.\n   * @param events The events to subscribe to.\n   * @param callback The callback function to be called when events occur.\n   */\n  on(events: string[] | string, callback: (data: T) => void): void;\n\n  /**\n   * Subscribe to all events, once.\n   */\n  once(callback: (data: T) => void): void;\n\n  /**\n   * Subscribe to specific events, once.\n   */\n  once(events: string[] | string, callback: (data: T) => void): void;\n\n  /**\n   * Unsubscribe from events with a callback.\n   * @param callback The callback function to remove from the subscription.\n   */\n  off(callback: (data: T) => void): void;\n}\n\n/**\n * Interface for objects that support listeners via the subscribe/unsubscribe pattern.\n */\nexport interface Subscribable<T> {\n  /**\n   * Subscribe to events with a callback.\n   * @param callback The callback function to be called when events occur.\n   */\n  subscribe(callback: (data: T) => void): Promise<unknown>;\n\n  /**\n   * Subscribe to specific events, with a callback.\n   * @param events The events to subscribe to.\n   * @param callback The callback function to be called when events occur.\n   */\n  subscribe(events: string[] | string, callback: (data: T) => void): Promise<unknown>;\n\n  /**\n   * Unsubscribe from events with a callback.\n   * @param callback The callback function to remove from the subscription.\n   */\n  unsubscribe(callback: (data: T) => void): void;\n}\n\n/**\n * Subscribe to events on an emitter and return a cleanup function.\n *\n * Overload 1: Subscribe to all events.\n * Overload 2: Subscribe to specific events (string or string[]).\n * @param emitter The event emitter object that has `on` and `off` methods.\n * @param callback The callback function to be called when events occur.\n * @returns A cleanup function that when called will unsubscribe the callback.\n */\nexport function on<T>(emitter: Onable<T>, callback: (data: T) => void): () => void;\nexport function on<T>(emitter: Onable<T>, events: string | string[], callback: (data: T) => void): () => void;\n\n/**\n * @param emitter The event emitter object that has `on` and `off` methods.\n * @param arg2 Either a callback function (for subscribing to all events) or event names (string or string[]) to subscribe to specific events.\n * @param arg3 The callback function to be called when events occur (only used when arg2 is event names).\n * @returns A cleanup function that when called will unsubscribe the callback.\n * @throws {TypeError} If the arguments passed are invalid.\n * @example\n * ```typescript\n * // Subscribe to all events\n * const cleanup = on(emitter, (data) => console.log(data));\n * // Subscribe to specific events\n * const cleanup = on(emitter, 'eventName', (data) => console.log(data));\n * const cleanup = on(emitter, ['event1', 'event2'], (data) => console.log(data));\n * ```\n */\nexport function on<T>(\n  emitter: Onable<T>,\n  arg2: ((data: T) => void) | string | string[],\n  arg3?: (data: T) => void,\n): () => void {\n  if ((Array.isArray(arg2) || typeof arg2 === 'string') && arg3) {\n    emitter.on(arg2, arg3);\n    return () => {\n      emitter.off(arg3);\n    };\n  } else if (typeof arg2 === 'function') {\n    emitter.on(arg2);\n    return () => {\n      emitter.off(arg2);\n    };\n  } else {\n    throw new TypeError('Invalid arguments passed to on()');\n  }\n}\n\n/**\n * Subscribe to events on an emitter and return a cleanup function.\n *\n * Overload 1: Subscribe to all events once.\n * Overload 2: Subscribe to specific events (string or string[]) once.\n * @param emitter The event emitter object that has `once` and `off` methods.\n * @param callback The callback function to be called when events occur.\n * @returns A cleanup function that when called will unsubscribe the callback.\n * @example\n * ```typescript\n * // Subscribe to all events once\n * const cleanup = once(emitter, (data) => console.log(data));\n * // Subscribe to specific events once\n * const cleanup = once(emitter, 'eventName', (data) => console.log(data));\n * const cleanup = once(emitter, ['event1', 'event2'], (data) => console.log(data));\n * ```\n */\nexport function once<T>(emitter: Onable<T>, callback: (data: T) => void): () => void;\nexport function once<T>(emitter: Onable<T>, events: string | string[], callback: (data: T) => void): () => void;\n/**\n * @param emitter The event emitter object that has `once` and `off` methods.\n * @param arg2 Either a callback function (for subscribing to all events) or event names (string or string[]) to subscribe to specific events.\n * @param arg3 The callback function to be called when events occur (only used when arg2 is event names).\n * @returns A cleanup function that when called will unsubscribe the callback.\n */\nexport function once<T>(\n  emitter: Onable<T>,\n  arg2: ((data: T) => void) | string | string[],\n  arg3?: (data: T) => void,\n): () => void {\n  if ((Array.isArray(arg2) || typeof arg2 === 'string') && arg3) {\n    emitter.once(arg2, arg3);\n    return () => {\n      emitter.off(arg3);\n    };\n  } else if (typeof arg2 === 'function') {\n    emitter.once(arg2);\n    return () => {\n      emitter.off(arg2);\n    };\n  } else {\n    throw new TypeError('Invalid arguments passed to once()');\n  }\n}\n\n/**\n * Subscribe to events on an emitter and return a cleanup function.\n *\n * Overload 1: Subscribe to all events.\n * Overload 2: Subscribe to specific events (string or string[]).\n * @param emitter The event emitter object that has `subscribe` and `unsubscribe` methods.\n * @param callback The callback function to be called when events occur (only used when first parameter is event names).\n * @returns A cleanup function that when called will unsubscribe the callback.\n * @example\n * ```typescript\n * // Subscribe to all events\n * const unsubscribe = subscribe(emitter, (data) => console.log(data));\n *\n * // Subscribe to specific events\n * const unsubscribe = subscribe(emitter, 'eventName', (data) => console.log(data));\n * const unsubscribe = subscribe(emitter, ['event1', 'event2'], (data) => console.log(data));\n * ```\n */\nexport function subscribe<T>(emitter: Subscribable<T>, callback: (data: T) => void): () => void;\nexport function subscribe<T>(\n  emitter: Subscribable<T>,\n  events: string | string[],\n  callback: (data: T) => void,\n): () => void;\n/**\n * Subscribe to events on an emitter and return a cleanup function.\n * This is the implementation function that handles both overloads.\n * @param emitter The event emitter object that has `subscribe` and `unsubscribe` methods.\n * @param arg2 Either a callback function (for subscribing to all events) or event names (string or string[]) to subscribe to specific events.\n * @param arg3 The callback function to be called when events occur (only used when arg2 is event names).\n * @returns A cleanup function that when called will unsubscribe the callback.\n */\nexport function subscribe<T>(\n  emitter: Subscribable<T>,\n  arg2: ((data: T) => void) | string | string[],\n  arg3?: (data: T) => void,\n): () => void {\n  if ((Array.isArray(arg2) || typeof arg2 === 'string') && arg3) {\n    const subscribePromise = emitter.subscribe(arg2, arg3);\n    return () => {\n      subscribePromise\n        .then(() => {\n          emitter.unsubscribe(arg3);\n        })\n        .catch((error: unknown) => {\n          console.error('Error subscribing to events:', error);\n        });\n    };\n  } else if (typeof arg2 === 'function') {\n    const subscribePromise = emitter.subscribe(arg2);\n    return () => {\n      subscribePromise\n        .then(() => {\n          emitter.unsubscribe(arg2);\n        })\n        .catch((error: unknown) => {\n          console.error('Error subscribing to events:', error);\n        });\n    };\n  } else {\n    throw new TypeError('Invalid arguments passed to subscribe()');\n  }\n}\n","import * as Ably from 'ably';\n\n/**\n * This type represents a callback that can be registered with an EventEmitter.\n *\n * The EventsMap is an interface of event names to the types of the payloads of\n * those events. For example:\n *\n *     interface MyEvents {\n *         reaction: {emoji: string}\n *     }\n *\n * There is no need to use this type directly, it is used for defining the\n * InterfaceEventEmitter.\n */\ntype Callback<EventsMap> = (arg: EventsMap[keyof EventsMap]) => void;\ntype CallbackSingle<K> = (arg: K) => void;\n\n/**\n * This interface extends the Ably.EventEmitter interface to add a type-safe\n * emit method as well as convert an EventsMap into the type parameters used by\n * Ably.EventEmitter.\n */\ninterface InterfaceEventEmitter<EventsMap> extends Ably.EventEmitter<Callback<EventsMap>, void, keyof EventsMap> {\n  emit<K extends keyof EventsMap>(event: K, arg: EventsMap[K]): void;\n\n  on<K extends keyof EventsMap>(event: K, callback: CallbackSingle<EventsMap[K]>): void;\n  on<K1 extends keyof EventsMap, K2 extends keyof EventsMap>(\n    events: [K1, K2],\n    callback: CallbackSingle<EventsMap[K1] | EventsMap[K2]>,\n  ): void;\n  on<K1 extends keyof EventsMap, K2 extends keyof EventsMap, K3 extends keyof EventsMap>(\n    events: [K1, K2, K3],\n    callback: CallbackSingle<EventsMap[K1] | EventsMap[K2] | EventsMap[K3]>,\n  ): void;\n  on(events: (keyof EventsMap)[], callback: Callback<EventsMap>): void;\n  on(callback: Callback<EventsMap>): void;\n\n  off<K extends keyof EventsMap>(event: K, listener: CallbackSingle<EventsMap[K]>): void;\n  off(listener?: Callback<EventsMap>): void;\n  off<K extends EventsMap[keyof EventsMap]>(listener: CallbackSingle<K>): void;\n}\n\n/**\n * This is a workaround for the fact that the EventEmitter constructor is only\n * exported from the ably-js package for internal use by other Ably SDKs (like\n * this one).\n *\n * It is a correctly-typed constructor for the ably-js EventEmitter.\n *\n * We do not export this directly because we prefer to export a class, which is\n * what we normally expect EventEmitter to be.\n */\nconst InternalEventEmitter: new <EventsMap>() => InterfaceEventEmitter<EventsMap> = (\n  Ably.Realtime as unknown as { EventEmitter: new <EventsMap>() => InterfaceEventEmitter<EventsMap> }\n).EventEmitter;\n\n/**\n * EventEmitter class based on the internal ably-js EventEmitter. It is\n * different from the ably-js EventEmitter because it takes an EventsMap type\n * parameter as opposed to the three type parameters required by\n * {@link Ably.EventEmitter}.\n *\n * We find the EventsMap type parameter to be more convenient to use in this\n * Chat SDK.\n *\n * The EventsMap is an interface of event names to the types of the payloads of\n * those events. For example:\n *\n *     interface MyEvents {\n *         reaction: {emoji: string}\n *     }\n *\n * There is no need to use this type directly, it is used for defining the\n * InterfaceEventEmitter.\n */\nclass EventEmitter<EventsMap> extends InternalEventEmitter<EventsMap> {}\n\nexport default EventEmitter;\n\n/**\n * Creates a wrapper function that forwards all arguments to the provided function.\n * @param fn The function to wrap\n * @returns A new function with the same signature as the input function\n */\nexport const wrap =\n  <Args extends unknown[], Return>(fn: (...args: Args) => Return): ((...args: Args) => Return) =>\n  (...args: Args) =>\n    fn(...args);\n\n/**\n * Checks if an EventEmitter has any listeners registered.\n * @param emitter The EventEmitter instance to check\n * @returns true if the emitter has listeners, false otherwise\n */\nexport const emitterHasListeners = <EventsMap>(emitter: EventEmitter<EventsMap>): boolean => {\n  const destructured = emitter as unknown as {\n    events: Record<string, unknown[]>;\n    any: unknown[];\n    eventsOnce: Record<string, unknown[]>;\n    anyOnce: unknown[];\n  };\n\n  const numListeners =\n    Object.values(destructured.events).flat().length +\n    destructured.any.length +\n    Object.values(destructured.eventsOnce).flat().length +\n    destructured.anyOnce.length;\n\n  return numListeners ? numListeners > 0 : false;\n};\n","import * as Ably from 'ably';\n\nimport { Logger } from './logger.js';\nimport { on } from './realtime-subscriptions.js';\nimport { StatusSubscription } from './subscription.js';\nimport EventEmitter, { emitterHasListeners, wrap } from './utils/event-emitter.js';\n\n/**\n * The different states that the connection can be in through its lifecycle.\n */\nexport enum ConnectionStatus {\n  /**\n   * A temporary state for when the library is first initialized.\n   */\n  Initialized = 'initialized',\n\n  /**\n   * The library is currently connecting to Ably.\n   */\n  Connecting = 'connecting',\n\n  /**\n   * The library is currently connected to Ably.\n   */\n  Connected = 'connected',\n\n  /**\n   * The library is currently disconnected from Ably, but will attempt to reconnect.\n   */\n  Disconnected = 'disconnected',\n\n  /**\n   * The library is in an extended state of disconnection, but will attempt to reconnect.\n   */\n  Suspended = 'suspended',\n\n  /**\n   * The library is currently disconnected from Ably and will not attempt to reconnect.\n   */\n  Failed = 'failed',\n\n  /**\n   * An explicit request by the developer to close the connection has been sent to the Ably service.\n   * If a reply is not received from Ably within a short period of time, the connection is forcibly\n   * terminated and the connection status becomes Closed.\n   */\n  Closing = 'closing',\n\n  /**\n   * The connection has been explicitly closed by the client. In the closed state, no reconnection\n   * attempts are made automatically. No connection state is preserved by the service or the library.\n   */\n  Closed = 'closed',\n}\n\n/**\n * Represents a change in the status of the connection.\n */\nexport interface ConnectionStatusChange {\n  /**\n   * The new status of the connection.\n   */\n  current: ConnectionStatus;\n\n  /**\n   * The previous status of the connection.\n   */\n  previous: ConnectionStatus;\n\n  /**\n   * An error that provides a reason why the connection has\n   * entered the new status, if applicable.\n   */\n  error?: Ably.ErrorInfo;\n\n  /**\n   * The time in milliseconds that the client will wait before attempting to reconnect.\n   */\n  retryIn?: number;\n}\n\n/**\n * A function that can be called when the connection status changes.\n * @param change The change in status.\n */\nexport type ConnectionStatusListener = (change: ConnectionStatusChange) => void;\n\n/**\n * Represents a connection to Ably.\n */\nexport interface Connection {\n  /**\n   * The current status of the connection.\n   * @returns The current ConnectionStatus value\n   * @example\n   * ```typescript\n   * import { ChatClient, ConnectionStatus } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Check connection status\n   * if (chatClient.connection.status === ConnectionStatus.Connected) {\n   *   console.log('Connected to Ably');\n   * } else if (chatClient.connection.status === ConnectionStatus.Failed) {\n   *   console.error('Connection failed');\n   * }\n   *\n   * // Use status for conditional logic\n   * function canAttachToRoom(): boolean {\n   *   return chatClient.connection.status === ConnectionStatus.Connected;\n   * }\n   * ```\n   */\n  get status(): ConnectionStatus;\n\n  /**\n   * The error that caused the connection to enter its current status, if any.\n   * @returns ErrorInfo if an error caused the current status, undefined otherwise\n   * @example\n   * ```typescript\n   * import { ChatClient, ConnectionStatus } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Check for connection errors\n   * if (chatClient.connection.error) {\n   *   console.error('Connection error:', chatClient.connection.error.message);\n   *   console.error('Error code:', chatClient.connection.error.code);\n   * }\n   * // Monitor for errors during status changes\n   * chatClient.connection.onStatusChange((change) => {\n   *   if (change.error) {\n   *     reportErrorToMonitoring(change.error);\n   *   }\n   * });\n   * ```\n   */\n  get error(): Ably.ErrorInfo | undefined;\n\n  /**\n   * Registers a listener to be notified of connection status changes.\n   *\n   * Status changes indicate the connection lifecycle, including connecting,\n   * connected, disconnected, suspended, and failed states. Use this to monitor\n   * connection health and handle network issues.\n   * @param listener - Callback invoked when the connection status changes\n   * @returns Subscription object with an off method to unregister\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, ConnectionStatus } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Monitor connection status changes\n   * const { off } = chatClient.connection.onStatusChange((change) => {\n   *   console.log(`Connection: ${change.previous} -> ${change.current}`);\n   *\n   *   // Handle different connection states..\n   *   switch (change.current) {\n   *     case ConnectionStatus.Connected:\n   *       console.log('✅ Connected to Ably');\n   *       enableChatFeatures();\n   *       hideConnectionWarning();\n   *       break;\n   *\n   *     case ConnectionStatus.Failed:\n   *       console.error('❌ Connection failed permanently');\n   *       if (change.error) {\n   *         console.error('Failure reason:', change.error.message);\n   *         showErrorMessage(`Connection failed: ${change.error.message}`);\n   *       }\n   *       requireManualReconnection();\n   *       break;\n   *\n   *     // Other states: Connecting, Disconnected, Suspended\n   *   }\n   * });\n   *\n   * // Clean up when done\n   * off();\n   * ```\n   */\n  onStatusChange(listener: ConnectionStatusListener): StatusSubscription;\n}\n\n/**\n * An internal interface for the connection with additional methods.\n */\nexport interface InternalConnection extends Connection {\n  /**\n   * Disposes of the connection instance, cleaning up any registered listeners.\n   * This method should be called when the connection is no longer needed.\n   * @internal\n   */\n  dispose(): void;\n}\n\ntype ConnectionEventsMap = Record<ConnectionStatus, ConnectionStatusChange>;\n\n/**\n * An implementation of the `Connection` interface.\n * @internal\n */\nexport class DefaultConnection implements InternalConnection {\n  private _status: ConnectionStatus = ConnectionStatus.Initialized;\n  private _error?: Ably.ErrorInfo;\n  private readonly _logger: Logger;\n  private _emitter = new EventEmitter<ConnectionEventsMap>();\n  private readonly _clearAblyConnectionListener: () => void;\n\n  /**\n   * Constructs a new `DefaultConnection` instance.\n   * @param ably The Ably Realtime client.\n   * @param logger The logger to use.\n   */\n  constructor(ably: Ably.Realtime, logger: Logger) {\n    this._logger = logger;\n\n    // Set our initial status and error\n    // CHA-RS5\n    this._status = this._mapAblyStatusToChat(ably.connection.state);\n    this._error = ably.connection.errorReason;\n\n    // Store the listener function so we can dispose of it later\n    const connectionListener = (change: Ably.ConnectionStateChange) => {\n      const chatState = this._mapAblyStatusToChat(change.current);\n      if (chatState === this._status) {\n        return;\n      }\n\n      const stateChange: ConnectionStatusChange = {\n        current: chatState,\n        previous: this._status,\n        error: change.reason,\n        retryIn: change.retryIn,\n      };\n\n      this._applyStatusChange(stateChange);\n    };\n\n    // Use subscription helper to create cleanup function\n    this._clearAblyConnectionListener = on(ably.connection, connectionListener);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get status(): ConnectionStatus {\n    return this._status;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get error(): Ably.ErrorInfo | undefined {\n    return this._error;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  onStatusChange(listener: ConnectionStatusListener): StatusSubscription {\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      off: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * @inheritdoc\n   */\n  dispose(): void {\n    this._logger.trace('DefaultConnection.dispose();');\n    // Remove the connection state listener from the Ably connection\n    this._clearAblyConnectionListener();\n    // Clear all listeners from the internal emitter\n    this._emitter.off();\n  }\n\n  /**\n   * Checks if there are any listeners registered on the connection.\n   * @internal\n   * @returns true if there are listeners, false otherwise.\n   */\n  hasListeners(): boolean {\n    return emitterHasListeners(this._emitter);\n  }\n\n  private _applyStatusChange(change: ConnectionStatusChange): void {\n    this._status = change.current;\n    this._error = change.error;\n    this._logger.info(`Connection state changed`, change);\n    this._emitter.emit(change.current, change);\n  }\n\n  /**\n   * Maps an Ably connection state to a connection status.\n   * @param status The Ably connection state to map.\n   * @returns The corresponding connection status.\n   */\n  private _mapAblyStatusToChat(status: Ably.ConnectionState): ConnectionStatus {\n    switch (status) {\n      case 'initialized': {\n        return ConnectionStatus.Initialized;\n      }\n      case 'connecting': {\n        return ConnectionStatus.Connecting;\n      }\n      case 'connected': {\n        return ConnectionStatus.Connected;\n      }\n      case 'disconnected': {\n        return ConnectionStatus.Disconnected;\n      }\n      case 'suspended': {\n        return ConnectionStatus.Suspended;\n      }\n      case 'closing': {\n        return ConnectionStatus.Closing;\n      }\n      case 'closed': {\n        return ConnectionStatus.Closed;\n      }\n      case 'failed': {\n        return ConnectionStatus.Failed;\n      }\n      default: {\n        this._logger.error('DefaultConnection._mapAblyStatusToChat(); unknown connection state', {\n          status,\n        });\n        return ConnectionStatus.Failed;\n      }\n    }\n  }\n}\n","/**\n * Generates a random string that can be used as an identifier, for instance, in identifying specific room\n * objects.\n * @returns A random string that can be used as an identifier.\n */\nexport const randomId = (): string => Math.random().toString(36).slice(2);\n","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import type { Message, MessageReactionSummary } from './message.js';\nimport type { OccupancyData } from './occupancy-parser.js';\nimport type { RoomReaction } from './room-reaction.js';\nimport type { TypingMember } from './typing.js';\n\n/**\n * All chat message events.\n */\nexport enum ChatMessageEventType {\n  /** Fires when a new chat message is received. */\n  Created = 'message.created',\n\n  /** Fires when a chat message is updated. */\n  Updated = 'message.updated',\n\n  /** Fires when a chat message is deleted. */\n  Deleted = 'message.deleted',\n}\n\n/**\n * Realtime chat message names.\n */\nexport enum RealtimeMessageName {\n  /** Represents a regular chat message. */\n  ChatMessage = 'chat.message',\n}\n\n/**\n * Realtime meta event types.\n */\nexport enum RealtimeMetaEventType {\n  /** Represents a meta occupancy event. */\n  Occupancy = '[meta]occupancy',\n}\n\n/**\n * Chat Message Actions.\n */\nexport enum ChatMessageAction {\n  /** Action applied to a new message. */\n  MessageCreate = 'message.create',\n\n  /** Action applied to an updated message. */\n  MessageUpdate = 'message.update',\n\n  /** Action applied to a deleted message. */\n  MessageDelete = 'message.delete',\n}\n\n/**\n * Enum representing presence events.\n */\nexport enum PresenceEventType {\n  /**\n   * Event triggered when a user enters.\n   */\n  Enter = 'enter',\n\n  /**\n   * Event triggered when a user leaves.\n   */\n  Leave = 'leave',\n\n  /**\n   * Event triggered when a user updates their presence data.\n   */\n  Update = 'update',\n  /**\n   * Event triggered when a user initially subscribes to presence.\n   */\n  Present = 'present',\n}\n\n/**\n * Enum representing the typing event types.\n */\nexport enum TypingEventType {\n  /**\n   * Event triggered when a user is typing.\n   */\n  Started = 'typing.started',\n\n  /**\n   * Event triggered when a user stops typing.\n   */\n  Stopped = 'typing.stopped',\n}\n\n/**\n * Enum representing the typing set event types.\n */\nexport enum TypingSetEventType {\n  /**\n   * Event triggered when a change occurs in the set of typers.\n   */\n  SetChanged = 'typing.set.changed',\n}\n\n/**\n * Represents a change in the state of current typers.\n */\nexport interface TypingSetEvent {\n  /**\n   * The type of the event.\n   */\n  type: TypingSetEventType;\n\n  /**\n   * The set of clientIds that are currently typing.\n   * @deprecated Use {@link TypingSetEvent.currentTypers | currentTypers} instead, which includes metadata such as user claims.\n   */\n  currentlyTyping: Set<string>;\n\n  /**\n   * The set of users currently typing, with associated metadata.\n   */\n  currentTypers: TypingMember[];\n\n  /**\n   * Represents the change that resulted in the new set of typers.\n   */\n  change: {\n    /**\n     * The client ID of the user who stopped/started typing.\n     */\n    clientId: string;\n\n    /**\n     * Type of the change.\n     */\n    type: TypingEventType;\n\n    /**\n     * The user claim attached to this typing event by the server. This is set automatically\n     * by the server when a JWT contains a matching `ably.room.<roomName>` claim.\n     */\n    userClaim?: string;\n  };\n}\n\n/**\n * Room reaction events. This is used for the realtime system since room reactions\n * have only one event: \"roomReaction\".\n */\nexport enum RoomReactionRealtimeEventType {\n  /**\n   * Event triggered when a room reaction was received.\n   */\n  Reaction = 'roomReaction',\n}\n\n/**\n * The type of room reaction events.\n */\nexport enum RoomReactionEventType {\n  /**\n   * Event triggered when a room reaction was received.\n   */\n  Reaction = 'reaction',\n}\n\n/**\n * Event that is emitted when a room reaction is received.\n */\nexport interface RoomReactionEvent {\n  /**\n   * The type of the event.\n   */\n  readonly type: RoomReactionEventType;\n\n  /**\n   * The reaction that was received.\n   */\n  readonly reaction: RoomReaction;\n}\n\n/**\n * Payload for a message event.\n */\nexport interface ChatMessageEvent {\n  /**\n   * The type of the message event.\n   */\n  type: ChatMessageEventType;\n\n  /**\n   * The message that was received.\n   */\n  message: Message;\n}\n\n/**\n * All annotation types supported by Chat Message Reactions.\n */\nexport enum MessageReactionType {\n  /**\n   * Allows for at most one reaction per client per message. If a client reacts\n   * to a message a second time, only the second reaction is counted in the\n   * summary.\n   *\n   * This is similar to reactions on iMessage, Facebook Messenger or WhatsApp.\n   */\n  Unique = 'unique',\n\n  /**\n   * Allows for at most one reaction of each type per client per message. It is\n   * possible for a client to add multiple reactions to the same message as\n   * long as they are different (eg different emojis). Duplicates are not\n   * counted in the summary.\n   *\n   * This is similar to reactions on Slack.\n   */\n  Distinct = 'distinct',\n\n  /**\n   * Allows any number of reactions, including repeats, and they are counted in\n   * the summary. The reaction payload also includes a count of how many times\n   * each reaction should be counted (defaults to 1 if not set).\n   *\n   * This is similar to the clap feature on Medium or how room reactions work.\n   */\n  Multiple = 'multiple',\n}\n\n/**\n * Enum representing the different annotation types used for message reactions.\n */\nexport enum ReactionAnnotationType {\n  Unique = 'reaction:unique.v1',\n  Distinct = 'reaction:distinct.v1',\n  Multiple = 'reaction:multiple.v1',\n}\n\n/**\n * Maps Ably PubSub annotation types to Ably Chat message reaction types.\n *\n * The key type is string because we use it to lookup by PubSub event.type, which is a string.\n */\nexport const AnnotationTypeToReactionType: Record<string, MessageReactionType> = {\n  [ReactionAnnotationType.Unique]: MessageReactionType.Unique,\n  [ReactionAnnotationType.Distinct]: MessageReactionType.Distinct,\n  [ReactionAnnotationType.Multiple]: MessageReactionType.Multiple,\n} as const;\n\n/**\n * Enum representing different raw message reaction events in the chat system.\n */\nexport enum MessageReactionRawEventType {\n  /**\n   * A reaction was added to a message.\n   */\n  Create = 'reaction.create',\n  /**\n   * A reaction was removed from a message.\n   */\n  Delete = 'reaction.delete',\n}\n\n/**\n * Enum representing different message reaction summary events in the chat system.\n */\nexport enum MessageReactionSummaryEventType {\n  /**\n   * A reactions summary was updated for a message.\n   */\n  Summary = 'reaction.summary',\n}\n\n/**\n * Represents an individual message reaction event.\n */\nexport interface MessageReactionRawEvent {\n  /** Whether reaction was added or removed */\n  type: MessageReactionRawEventType;\n\n  /** The timestamp of this event */\n  timestamp: Date;\n\n  /** The message reaction that was received. */\n  reaction: {\n    /** Serial of the message this reaction is for */\n    messageSerial: string;\n\n    /** Type of reaction */\n    type: MessageReactionType;\n\n    /** The reaction name (typically an emoji) */\n    name: string;\n\n    /** Count of the reaction (only for type Multiple, if set) */\n    count?: number;\n\n    /** The client ID of the user who added/removed the reaction */\n    clientId: string;\n\n    /**\n     * The user claim attached to this reaction by the server. This is set automatically\n     * by the Ably server when a JWT contains a matching `ably.room.<roomName>` claim.\n     */\n    userClaim?: string;\n  };\n}\n\n/**\n * Event interface representing a summary of message reactions.\n * This event aggregates different types of reactions (single, distinct, counter) for a specific message.\n */\nexport interface MessageReactionSummaryEvent {\n  /** The type of the event */\n  type: MessageReactionSummaryEventType;\n\n  /** Reference to the original message's serial */\n  messageSerial: string;\n\n  /** The message reactions summary. */\n  reactions: MessageReactionSummary;\n}\n\n/**\n * Enum representing occupancy events.\n */\nexport enum OccupancyEventType {\n  /**\n   * Event triggered when occupancy is updated.\n   */\n  Updated = 'occupancy.updated',\n}\n\n/**\n * Represents an occupancy event.\n */\nexport interface OccupancyEvent {\n  /**\n   * The type of the occupancy event.\n   */\n  type: OccupancyEventType;\n\n  /**\n   * The occupancy data.\n   */\n  occupancy: OccupancyData;\n}\n\n/**\n * Room events.\n */\nexport enum RoomEventType {\n  /**\n   * Event triggered when a discontinuity is detected in the room's channel connection.\n   * A discontinuity occurs when an attached or update event comes from the channel with resume=false,\n   * except for the first attach or attaches after explicit detach calls.\n   */\n  Discontinuity = 'room.discontinuity',\n}\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","import * as Ably from 'ably';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport { ErrorCode } from './errors.js';\nimport {\n  ChatMessageAction,\n  ChatMessageEvent,\n  ChatMessageEventType,\n  MessageReactionSummaryEvent,\n  MessageReactionSummaryEventType,\n} from './events.js';\nimport { Headers } from './headers.js';\nimport { Metadata } from './metadata.js';\nimport { OperationMetadata } from './operation-metadata.js';\n\n/**\n * {@link Headers} type for chat messages.\n */\nexport type MessageHeaders = Headers;\n\n/**\n * {@link Metadata} type for chat messages.\n */\nexport type MessageMetadata = Metadata;\n\n/**\n * {@link OperationMetadata} type for a chat message. Contains information about an update or deletion operation.\n */\nexport type MessageOperationMetadata = OperationMetadata;\n\n/**\n * Represents the detail of a message deletion or update.\n */\nexport interface MessageVersion {\n  /**\n   * A unique identifier for the latest version of this message.\n   */\n  serial: string;\n\n  /**\n   * The timestamp at which this version was updated, deleted, or created.\n   */\n  timestamp: Date;\n\n  /**\n   * The optional clientId of the user who performed an update or deletion.\n   */\n  clientId?: string;\n\n  /**\n   * The optional description for an update or deletion.\n   */\n  description?: string;\n\n  /**\n   * The optional metadata associated with an update or deletion.\n   */\n  metadata?: MessageOperationMetadata;\n}\n\n/**\n * Represents a single message in a chat room.\n */\nexport interface Message {\n  /**\n   * The unique identifier of the message.\n   */\n  readonly serial: string;\n\n  /**\n   * The clientId of the user who created the message.\n   */\n  readonly clientId: string;\n\n  /**\n   * The text of the message.\n   */\n  readonly text: string;\n\n  /**\n   * The timestamp at which the message was created.\n   */\n  readonly timestamp: Date;\n\n  /**\n   * The metadata of a chat message. Allows for attaching extra info to a message,\n   * which can be used for various features such as animations, effects, or simply\n   * to link it to other resources such as images, relative points in time, etc.\n   *\n   * Metadata is part of the Ably Pub/sub message content and is not read by Ably.\n   *\n   * This value is always set. If there is no metadata, this is an empty object.\n   *\n   * Do not use metadata for authoritative information. There is no server-side\n   * validation. When reading the metadata treat it like user input.\n   *\n   * If you need per-room authoritative information on messages, consider using\n   * {@link userClaim} via JWT user claims instead.\n   */\n  readonly metadata: MessageMetadata;\n\n  /**\n   * The headers of a chat message. Headers enable attaching extra info to a message,\n   * which can be used for various features such as linking to a relative point in\n   * time of a livestream video or flagging this message as important or pinned.\n   *\n   * Headers are part of the Ably realtime message extras.headers and they can be used\n   * for Filtered Subscriptions and similar.\n   *\n   * This value is always set. If there are no headers, this is an empty object.\n   *\n   * Do not use the headers for authoritative information. There is no server-side\n   * validation. When reading the headers, treat them like user input.\n   *\n   * If you need per-room authoritative information on messages, consider using\n   * {@link userClaim} via JWT user claims instead.\n   */\n  readonly headers: MessageHeaders;\n\n  /**\n   * The user claim attached to this message by the server. This is set automatically\n   * by the Ably server when a JWT contains a matching `ably.room.<roomName>` claim.\n   *\n   * This value is only present if the publishing user's token contained a claim\n   * for the room in which this message was published.\n   */\n  readonly userClaim?: string;\n\n  /**\n   * The action type of the message. This can be used to determine if the message was created, updated, or deleted.\n   */\n  readonly action: ChatMessageAction;\n\n  /**\n   * Information about the latest version of this message.\n   */\n  readonly version: MessageVersion;\n\n  /**\n   * The reactions summary for this message.\n   */\n  readonly reactions: MessageReactionSummary;\n\n  /**\n   * Creates a new message instance with the event applied.\n   *\n   * **NOTE**: This method will not replace the message reactions if the event is of type `Message`.\n   * @param event The event to be applied to the returned message.\n   * @throws An {@link Ably.ErrorInfo} if the event is for a different message.\n   * @throws An {@link Ably.ErrorInfo} if the event is a {@link ChatMessageEventType.Created}.\n   * @returns A new message instance with the event applied. If the event is a no-op, such\n   *    as an event for an old version, the same message is returned (not a copy).\n   */\n  with(event: Message | ChatMessageEvent | MessageReactionSummaryEvent): Message;\n\n  /**\n   * Creates a copy of the message with fields replaced per the parameters.\n   * @param params The parameters to replace in the message.\n   * @returns The message copy.\n   */\n  copy(params?: MessageCopyParams): Message;\n}\n\n/**\n * Parameters for copying a message.\n */\nexport interface MessageCopyParams {\n  /**\n   * The text of the copied message.\n   */\n  text?: string;\n\n  /**\n   * The metadata of the copied message.\n   */\n  metadata?: MessageMetadata;\n\n  /**\n   * The headers of the copied message.\n   */\n  headers?: MessageHeaders;\n}\n\n/**\n * Represents a summary of all reactions on a message.\n */\nexport interface MessageReactionSummary {\n  /**\n   * Map of reaction to the summary (total and clients) for reactions of type {@link MessageReactionType.Unique}.\n   */\n  unique: Ably.SummaryUniqueValues;\n\n  /**\n   * Map of reaction to the summary (total and clients) for reactions of type {@link MessageReactionType.Distinct}.\n   */\n  distinct: Ably.SummaryDistinctValues;\n\n  /**\n   * Map of reaction to the summary (total and clients) for reactions of type {@link MessageReactionType.Multiple}.\n   */\n  multiple: Ably.SummaryMultipleValues;\n}\n\n/**\n * Parameters for creating a new DefaultMessage instance.\n */\nexport interface DefaultMessageParams {\n  serial: string;\n  clientId: string;\n  text: string;\n  metadata: MessageMetadata;\n  headers: MessageHeaders;\n  userClaim?: string;\n  action: ChatMessageAction;\n  version: MessageVersion;\n  timestamp: Date;\n  reactions: MessageReactionSummary;\n}\n\n/**\n * An implementation of the Message interface for chat messages.\n *\n * Allows for comparison of messages based on their serials.\n */\nexport class DefaultMessage implements Message {\n  public readonly serial: string;\n  public readonly clientId: string;\n  public readonly text: string;\n  public readonly metadata: MessageMetadata;\n  public readonly headers: MessageHeaders;\n  public readonly userClaim?: string;\n  public readonly action: ChatMessageAction;\n  public readonly version: MessageVersion;\n  public readonly timestamp: Date;\n  public readonly reactions: MessageReactionSummary;\n\n  constructor({\n    serial,\n    clientId,\n    text,\n    metadata,\n    headers,\n    userClaim,\n    action,\n    version,\n    timestamp,\n    reactions,\n  }: DefaultMessageParams) {\n    this.serial = serial;\n    this.clientId = clientId;\n    this.text = text;\n    this.metadata = metadata;\n    this.headers = headers;\n    this.userClaim = userClaim;\n    this.action = action;\n    this.version = version;\n    this.timestamp = timestamp;\n    this.reactions = reactions;\n    // The object is frozen after constructing to enforce readonly at runtime too\n    Object.freeze(this.version);\n    Object.freeze(this.reactions);\n    Object.freeze(this.reactions.multiple);\n    Object.freeze(this.reactions.distinct);\n    Object.freeze(this.reactions.unique);\n    Object.freeze(this);\n  }\n\n  with(event: Message | ChatMessageEvent | MessageReactionSummaryEvent): Message {\n    // If event has the property \"serial\", then it's a message\n    if ('serial' in event) {\n      return this._getLatestMessageVersion(event);\n    }\n\n    // If the event is a created event, throw an error\n    if (event.type === ChatMessageEventType.Created) {\n      throw new Ably.ErrorInfo(\n        'unable to apply message event; unable to apply created event to existing message',\n        ErrorCode.InvalidArgument,\n        400,\n      );\n    }\n\n    // reaction summary\n    if (event.type === MessageReactionSummaryEventType.Summary) {\n      if (event.messageSerial !== this.serial) {\n        throw new Ably.ErrorInfo(\n          'unable to apply message event; event is for a different message',\n          ErrorCode.InvalidArgument,\n          400,\n        );\n      }\n\n      const newReactions: MessageReactionSummary = {\n        unique: cloneDeep(event.reactions.unique),\n        distinct: cloneDeep(event.reactions.distinct),\n        multiple: cloneDeep(event.reactions.multiple),\n      };\n\n      return DefaultMessage._clone(this, { reactions: newReactions });\n    }\n\n    // Message event (update or delete)\n    return this._getLatestMessageVersion(event.message);\n  }\n\n  /**\n   * Get the latest message version, based on the event.\n   * If \"this\" is the latest version, return \"this\", otherwise clone the message and apply the reactions.\n   * @param message The message to get the latest version of\n   * @returns The latest message version\n   */\n  private _getLatestMessageVersion(message: Message): Message {\n    // message event (update or delete)\n    if (message.serial !== this.serial) {\n      throw new Ably.ErrorInfo(\n        'unable to apply message event; event is for a different message',\n        ErrorCode.InvalidArgument,\n        400,\n      );\n    }\n\n    // event is older, keep this instead\n    if (this.version.serial >= message.version.serial) {\n      return this;\n    }\n\n    // event is newer, copy reactions from this and make new message from event\n    // TODO: This ignores summaries being newer on the message passed in, and is something we need to address\n    return DefaultMessage._clone(message, { reactions: this.reactions });\n  }\n\n  // Clone a message, optionally replace the given fields\n  private static _clone(source: Message, replace?: Partial<Message>): DefaultMessage {\n    return new DefaultMessage({\n      serial: replace?.serial ?? source.serial,\n      clientId: replace?.clientId ?? source.clientId,\n      text: replace?.text ?? source.text,\n      metadata: replace?.metadata ?? cloneDeep(source.metadata),\n      headers: replace?.headers ?? cloneDeep(source.headers),\n      userClaim: replace?.userClaim ?? source.userClaim,\n      action: replace?.action ?? source.action,\n      version: replace?.version ?? cloneDeep(source.version),\n      timestamp: replace?.timestamp ?? source.timestamp,\n      reactions: replace?.reactions ?? cloneDeep(source.reactions),\n    });\n  }\n\n  copy(params: MessageCopyParams = {}): Message {\n    return DefaultMessage._clone(this, params);\n  }\n}\n\n/**\n * Creates an empty MessageReactionSummary object with empty unique and distinct reaction collections.\n * @returns An empty MessageReactionSummary object.\n */\nexport const emptyMessageReactions = (): MessageReactionSummary => ({\n  unique: {},\n  distinct: {},\n  multiple: {},\n});\n","import * as Ably from 'ably';\n\nimport { Headers } from './headers.js';\n\n/**\n * Exposes the agents option in the Ably Realtime client for typescript.\n * @internal\n */\nexport interface RealtimeWithOptions extends Ably.Realtime {\n  options: {\n    agents?: Record<string, string | undefined>;\n  };\n}\n\n/**\n * Exposes the channelOptions property in the Ably Realtime channel for typescript.\n * @internal\n */\nexport interface RealtimeChannelWithOptions extends Ably.RealtimeChannel {\n  channelOptions: Ably.ChannelOptions;\n}\n\n/**\n * Represents the typed shape of the `extras` object on Ably realtime messages,\n * presence messages, and annotations. Ably's types declare `extras` as `any`,\n * so this interface provides a concrete type for the fields we use.\n * @internal\n */\nexport interface RealtimeExtras {\n  headers?: Headers;\n  userClaim?: string;\n}\n\n/**\n * Safely extracts the `extras` object from an Ably message, presence message,\n * or annotation. Returns an empty object if `extras` is not a valid object.\n * @param extras The raw extras value from an Ably message.\n * @returns The typed extras object.\n * @internal\n */\nexport const realtimeExtras = (extras: unknown): RealtimeExtras => {\n  if (!extras || typeof extras !== 'object') {\n    return {};\n  }\n  const raw = extras as Record<string, unknown>;\n  const result: RealtimeExtras = {};\n  if (raw.headers && typeof raw.headers === 'object') {\n    result.headers = raw.headers as RealtimeExtras['headers'];\n  }\n  if (typeof raw.userClaim === 'string') {\n    result.userClaim = raw.userClaim;\n  }\n  return result;\n};\n","import * as Ably from 'ably';\n\nimport { ChatMessageAction } from './events.js';\nimport { DefaultMessage, emptyMessageReactions, Message, MessageMetadata } from './message.js';\nimport { realtimeExtras } from './realtime-extensions.js';\n\ninterface MessagePayload {\n  data?: {\n    text?: string;\n    metadata?: MessageMetadata;\n  };\n  clientId?: string;\n  timestamp: number;\n  serial: string;\n  action: Ably.MessageAction;\n  version: Ably.MessageVersion;\n  annotations: Ably.MessageAnnotations;\n}\n\n// Parse a realtime message to a chat message\nexport const parseMessage = (inboundMessage: Ably.InboundMessage): Message => {\n  const message = inboundMessage as MessagePayload;\n\n  // Provide default values for all fields\n  const data = message.data && typeof message.data === 'object' ? message.data : {};\n  const extras = realtimeExtras(inboundMessage.extras);\n  const clientId = message.clientId || '';\n  const text = data.text || '';\n  // Spec: CHA-M4k5\n  const timestamp = new Date(message.timestamp || 0);\n  const serial = message.serial || '';\n  const metadata = data.metadata && typeof data.metadata === 'object' ? data.metadata : {};\n  const headers = extras.headers || {};\n  const userClaim = extras.userClaim;\n\n  // Create the version, using defaults as required\n  const version = {\n    ...message.version,\n    // Spec: CHA-M4k6\n    serial: message.version.serial || serial,\n    // Spec: CHA-M4k7\n    timestamp: new Date(message.version.timestamp || timestamp),\n  };\n\n  // Convert the action to a ChatMessageAction enum, defaulting to MessageCreate if the action is not found.\n  const action = Object.values(ChatMessageAction).includes(message.action as ChatMessageAction)\n    ? (message.action as ChatMessageAction)\n    : ChatMessageAction.MessageCreate;\n\n  return new DefaultMessage({\n    serial,\n    clientId,\n    text,\n    metadata,\n    headers,\n    userClaim,\n    action,\n    version,\n    timestamp,\n    reactions: emptyMessageReactions(),\n  });\n};\n","import * as Ably from 'ably';\n\nimport { ErrorCode } from './errors.js';\n\n/**\n * Asserts that a serial parameter is valid (not undefined, null, or empty string).\n * @internal\n * @param serial The serial value to validate.\n * @param op The operation being performed (e.g., \"send message reaction\").\n * @param paramName The name of the parameter (e.g., \"messageSerial\").\n * @throws An {@link Ably.ErrorInfo} With InvalidArgument code if the serial is invalid.\n */\nexport const assertValidSerial = (serial: unknown, op: string, paramName: string): void => {\n  if (!serial) {\n    throw new Ably.ErrorInfo(\n      `unable to ${op}; ${paramName} must be a non-empty string`,\n      ErrorCode.InvalidArgument,\n      400,\n    );\n  }\n};\n","import * as Ably from 'ably';\n\nimport { ChannelOptionsMerger } from './channel-manager.js';\nimport {\n  ChatApi,\n  DeleteMessageReactionParams as APIDeleteMessageReactionParams,\n  SendMessageReactionParams as APISendMessageReactionParams,\n} from './chat-api.js';\nimport { ErrorCode } from './errors.js';\nimport {\n  AnnotationTypeToReactionType,\n  MessageReactionRawEvent,\n  MessageReactionRawEventType,\n  MessageReactionSummaryEvent,\n  MessageReactionSummaryEventType,\n  MessageReactionType,\n  ReactionAnnotationType,\n} from './events.js';\nimport { Logger } from './logger.js';\nimport { Message } from './message.js';\nimport { realtimeExtras } from './realtime-extensions.js';\nimport { subscribe } from './realtime-subscriptions.js';\nimport { InternalRoomOptions, MessagesOptions } from './room-options.js';\nimport { assertValidSerial } from './serial.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { emitterHasListeners, wrap } from './utils/event-emitter.js';\n\n/**\n * A listener for summary message reaction events.\n * @param event The message reaction summary event that was received. Use it\n *   with {@link Message.with} to keep an up-to-date reaction count.\n */\nexport type MessageReactionListener = (event: MessageReactionSummaryEvent) => void;\n\n/**\n * A listener for individual message reaction events.\n * @param event The message reaction event that was received.\n */\nexport type MessageRawReactionListener = (event: MessageReactionRawEvent) => void;\n\n/**\n * Parameters for sending a message reaction.\n */\nexport interface SendMessageReactionParams {\n  /**\n   * The reaction name to send; (e.g., emoji like \"👍\", \"❤️\", or custom names)\n   */\n  name: string;\n\n  /**\n   * The optional type of reaction, must be one of {@link MessageReactionType} if set.\n   * If not set, the default type will be used which is configured in the {@link MessagesOptions.defaultMessageReactionType} of the room.\n   */\n  type?: MessageReactionType;\n\n  /**\n   * The count of the reaction for type {@link MessageReactionType.Multiple}.\n   * Defaults to 1 if not set. Not supported for other reaction types.\n   * @defaultValue 1\n   */\n  count?: number;\n}\n\n/**\n * Parameters for deleting a message reaction.\n */\nexport interface DeleteMessageReactionParams {\n  /**\n   * The reaction name to delete; ie. the emoji. Required for all reaction types\n   * except {@link MessageReactionType.Unique}.\n   */\n  name?: string;\n\n  /**\n   * The type of reaction, must be one of {@link MessageReactionType}.\n   * If not set, the default type will be used which is configured in the {@link MessagesOptions.defaultMessageReactionType} of the room.\n   */\n  type?: MessageReactionType;\n}\n\n/**\n * Send, delete, and subscribe to message reactions.\n */\nexport interface MessageReactions {\n  /**\n   * Sends a reaction to a specific chat message.\n   *\n   * **Note**:\n   * - The behavior depends on the reaction type configured for the room.\n   * - This method uses the Ably Chat REST API and so does not require the room\n   * to be attached to be called.\n   * @param messageSerial - The unique identifier of the message to react to.\n   * @param params - The reaction parameters\n   * @returns Promise that resolves when the reaction has been sent, or rejects with:\n   * - {@link Ably.ErrorInfo} with code 40400 if the message does not exist.\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, MessageReactionType } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('sports-chat');\n   *\n   * const messageSerial = '01726585978590-001@abcdefghij:001';\n   *\n   * // Send a simple reaction to a message\n   * try {\n   *   await room.messages.reactions.send(messageSerial, {\n   *     name: '👍'\n   *   });\n   *   console.log('Reaction sent successfully');\n   * } catch (error) {\n   *   console.error('Failed to send reaction:', error);\n   * }\n   *\n   * // Send a distinct type reaction (can react with multiple different emojis)\n   * await room.messages.reactions.send(messageSerial, {\n   *   name: '❤️',\n   *   type: MessageReactionType.Distinct\n   * });\n   *\n   * // Send a multiple type reaction with count (for vote-style reactions)\n   * await room.messages.reactions.send(messageSerial, {\n   *   name: 'option-a',\n   *   type: MessageReactionType.Multiple,\n   *   count: 3  // User votes 3 times for option-a\n   * });\n   * ```\n   */\n  send(messageSerial: string, params: SendMessageReactionParams): Promise<void>;\n\n  /**\n   * Deletes a previously sent reaction from a chat message.\n   *\n   * The deletion behavior depends on the reaction type:\n   * - **Unique**: Removes the client's single reaction (name not required)\n   * - **Distinct**: Removes a specific reaction by name\n   * - **Multiple**: Removes all instances of a reaction by name\n   *\n   * **Note**: This method uses the Ably Chat REST API and so does not require the room\n   * to be attached to be called.\n   * @param messageSerial - The unique identifier of the message to remove the reaction from\n   * @param params - Optional deletion parameters\n   * @returns Promise that resolves when the reaction has been deleted, or rejects with:\n   * - {@link Ably.ErrorInfo} with code 40400 if the message does not exist.\n   * - {@link ErrorCode.InvalidArgument} if trying to delete a non-Unique reaction without a name.\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, MessageReactionType } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('team-chat');\n   *\n   * const messageSerial = '01726585978590-001@abcdefghij:001';\n   *\n   * // Delete a distinct reaction (specific emoji)\n   * try {\n   *   await room.messages.reactions.delete(messageSerial, {\n   *     name: '👍',\n   *     type: MessageReactionType.Distinct\n   *   });\n   *   console.log('Thumbs up reaction removed');\n   * } catch (error) {\n   *   console.error('Failed to delete reaction:', error);\n   * }\n   *\n   * // Delete a unique reaction (only one per user, name not needed)\n   * await room.messages.reactions.delete(messageSerial, {\n   *   type: MessageReactionType.Unique\n   * });\n   *\n   * // Delete all instances of a multiple reaction\n   * await room.messages.reactions.delete(messageSerial, {\n   *   name: 'option-b',\n   *   type: MessageReactionType.Multiple\n   * });\n   * ```\n   */\n  delete(messageSerial: string, params?: DeleteMessageReactionParams): Promise<void>;\n\n  /**\n   * Subscribes to chat message reaction summary events.\n   *\n   * Summary events provide aggregated reaction counts. Each summary event contains counts and\n   * client lists for all reaction types on a message.\n   *\n   * **Note**:\n   * - The room must be attached to receive reaction events.\n   * - When there are many reacting clients, the client list may be clipped. Check the `clipped` flag and use {@link clientReactions} for complete client information when needed.\n   * - When the rate of reactions is very high, multiple summaries may be rolled up into a single summary event, meaning the delta between sequential summaries is not guaranteed to be a single reaction change.\n   * @param listener - Callback invoked when reaction summaries are updated\n   * @returns Subscription object with an unsubscribe method\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, MessageReactionSummaryEvent } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('product-reviews');\n   *\n   * // Subscribe to reaction summaries\n   * const subscription = room.messages.reactions.subscribe((event: MessageReactionSummaryEvent) => {\n   *   const { reactions } = event;\n   *   // Handle distinct reactions\n   *   if (reactions.distinct) {\n   *     Object.entries(reactions.distinct).forEach(([reaction, data]) => {\n   *       console.log(`${reaction}: ${data.total} reactions from ${data.clientIds.length} users`);\n   *     });\n   *   }\n   *   // Handle unique reactions\n   *   if (reactions.unique) {\n   *     Object.entries(reactions.unique).forEach(([reaction, data]) => {\n   *       console.log(`${reaction}: ${data.total} users reacted`);\n   *     });\n   *   }\n   *   // Handle multiple reactions\n   *   if (reactions.multiple) {\n   *     Object.entries(reactions.multiple).forEach(([reaction, data]) => {\n   *       console.log(`${reaction}: ${data.total} total votes`);\n   *     });\n   *   }\n   * });\n   *\n   * // Attach to the room to start receiving events\n   * await room.attach();\n   *\n   * // Later, unsubscribe when done\n   * subscription.unsubscribe();\n   * ```\n   */\n  subscribe(listener: MessageReactionListener): Subscription;\n\n  /**\n   * Subscribes to individual chat message reaction events.\n   *\n   * Raw reaction events provide the individual updates for each reaction\n   * added or removed. This is most useful for analytics, but is not recommended\n   * for driving UI due to the high volume of events.\n   *\n   * **Note**: Requires {@link MessagesOptions.rawMessageReactions} to be enabled in room options.\n   * @param listener - Callback invoked for each individual reaction event\n   * @returns Subscription object with an unsubscribe method\n   * @throws An {@link Ably.ErrorInfo} with {@link ErrorCode.FeatureNotEnabledInRoom} if raw message reactions are not enabled\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, MessageReactionRawEvent, MessageReactionEventType } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Enable raw reactions in room options\n   * const room = await chatClient.rooms.get('live-stream', {\n   *   messages: {\n   *     rawMessageReactions: true\n   *   }\n   * });\n   *\n   * // Subscribe to individual reaction events\n   * const subscription = room.messages.reactions.subscribeRaw((event: MessageReactionRawEvent) => {\n   *   const { type, reaction, timestamp } = event;\n   *\n   *   switch (type) {\n   *     case MessageReactionEventType.Create:\n   *       console.log(`${reaction.clientId} added ${reaction.name} to message ${reaction.messageSerial} at ${timestamp}`);\n   *       break;\n   *\n   *     case MessageReactionEventType.Delete:\n   *       console.log(`${reaction.clientId} removed ${reaction.name} from message ${reaction.messageSerial} at ${timestamp}`);\n   *       break;\n   *   }\n   *\n   *   // Handle multiple type reactions with counts\n   *   if (reaction.count !== undefined) {\n   *     console.log(`Reaction has count: ${reaction.count}`);\n   *   }\n   * });\n   *\n   * // Attach to the room to start receiving events\n   * await room.attach();\n   *\n   * // Later, unsubscribe when done\n   * subscription.unsubscribe();\n   * ```\n   */\n  subscribeRaw(listener: MessageRawReactionListener): Subscription;\n\n  /**\n   * Retrieves reaction information for a specific client on a message.\n   *\n   * Use this method when reaction summaries are clipped (too many reacting clients)\n   * and you need to check if a specific client has reacted. This is particularly\n   * useful for determining if the current user has reacted when they're not in\n   * the summary's client list.\n   * **Note**: This method uses the Ably Chat REST API and so does not require the room\n   * to be attached to be called.\n   * @param messageSerial - The unique identifier of the message\n   * @param clientId - The client ID to check (defaults to current client)\n   * @returns Promise - That resolves to reaction data for the specified client.\n   * The promise **rejects** with:\n   * - {@link Ably.ErrorInfo} with code 40400 if the message does not exist.\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   * const room = await chatClient.rooms.get('large-event');\n   *\n   * const messageSerial = '01726585978590-001@abcdefghij:001';\n   *\n   * try {\n   *   // Get reactions for the current client\n   *   const myReactions = await room.messages.reactions.clientReactions(messageSerial);\n   *   if (myReactions.unique?.['👍']) {\n   *     console.log('I have reacted with 👍');\n   *   }\n   *   if (myReactions.distinct?.['❤️']) {\n   *     console.log('I have reacted with ❤️');\n   *   }\n   *   if (myReactions.multiple?.['vote-option-a'] && chatClient.clientId) {\n   *     console.log(`I voted for option A: ${myReactions.multiple['vote-option-a'].clientIds[chatClient.clientId]} times`);\n   *   }\n   *   // Check reactions for a specific client\n   *   const specificClientReactions = await room.messages.reactions.clientReactions(\n   *     messageSerial,\n   *     'specific-client-id'\n   *   );\n   *   console.log('Specific client reactions:', specificClientReactions);\n   * } catch (error) {\n   *   console.error('Failed to get client reactions:', error);\n   * }\n   * ```\n   */\n  clientReactions(messageSerial: string, clientId?: string): Promise<Message['reactions']>;\n}\n\n/**\n * Maps Ably PubSub annotation action to message reaction event type.\n */\nconst eventTypeMap: Record<string, MessageReactionRawEventType> = {\n  'annotation.create': MessageReactionRawEventType.Create,\n  'annotation.delete': MessageReactionRawEventType.Delete,\n};\n\n/**\n * @inheritDoc\n */\nexport class DefaultMessageReactions implements MessageReactions {\n  private _emitter = new EventEmitter<{\n    [MessageReactionRawEventType.Create]: MessageReactionRawEvent;\n    [MessageReactionRawEventType.Delete]: MessageReactionRawEvent;\n    [MessageReactionSummaryEventType.Summary]: MessageReactionSummaryEvent;\n  }>();\n\n  private readonly _defaultType: MessageReactionType;\n  private readonly _unsubscribeMessageEvents: () => void;\n  private readonly _unsubscribeAnnotationEvents?: () => void;\n\n  constructor(\n    private readonly _logger: Logger,\n    private readonly _options: MessagesOptions | undefined,\n    private readonly _api: ChatApi,\n    private readonly _roomName: string,\n    private readonly _channel: Ably.RealtimeChannel,\n  ) {\n    // Use subscription helper to create cleanup function\n    this._unsubscribeMessageEvents = subscribe(_channel, this._processMessageEvent.bind(this));\n\n    if (this._options?.rawMessageReactions) {\n      this._unsubscribeAnnotationEvents = subscribe(_channel.annotations, this._processAnnotationEvent.bind(this));\n    }\n    this._defaultType = this._options?.defaultMessageReactionType ?? MessageReactionType.Distinct;\n  }\n\n  private _processAnnotationEvent(event: Ably.Annotation) {\n    this._logger.trace('MessageReactions._processAnnotationEvent();', { event });\n\n    // If we don't know the reaction type, ignore it\n    const reactionType = AnnotationTypeToReactionType[event.type];\n    if (!reactionType) {\n      this._logger.info('MessageReactions._processAnnotationEvent(); ignoring unknown reaction type', { event });\n      return;\n    }\n\n    // If we don't know the event type, ignore it\n    const eventType = eventTypeMap[event.action];\n    if (!eventType) {\n      this._logger.info('MessageReactions._processAnnotationEvent(); ignoring unknown reaction event type', { event });\n      return;\n    }\n\n    const name = event.name ?? '';\n    const extras = realtimeExtras(event.extras);\n    const reactionEvent: MessageReactionRawEvent = {\n      type: eventType,\n      timestamp: new Date(event.timestamp),\n      reaction: {\n        messageSerial: event.messageSerial,\n        type: reactionType,\n        name: name,\n        clientId: event.clientId ?? '',\n        userClaim: extras.userClaim,\n      },\n    };\n\n    if (event.count) {\n      reactionEvent.reaction.count = event.count;\n    } else if (eventType === MessageReactionRawEventType.Create && reactionType === MessageReactionType.Multiple) {\n      reactionEvent.reaction.count = 1; // count defaults to 1 for multiple if not set\n    }\n\n    this._emitter.emit(eventType, reactionEvent);\n  }\n\n  private _processMessageEvent(event: Ably.InboundMessage) {\n    this._logger.trace('MessageReactions._processMessageEvent();', { event });\n\n    // only process summary events\n    if (event.action !== 'message.summary') {\n      return;\n    }\n\n    // As Chat uses mutable messages, we know that `serial` will be defined, so this cast is ok\n    const serial = event.serial as unknown as string;\n\n    // Set the reaction types from the summary\n    const summary = event.annotations.summary;\n\n    const unique = (summary[ReactionAnnotationType.Unique] ?? {}) as unknown as Ably.SummaryUniqueValues;\n    const distinct = (summary[ReactionAnnotationType.Distinct] ?? {}) as unknown as Ably.SummaryDistinctValues;\n    const multiple = (summary[ReactionAnnotationType.Multiple] ?? {}) as Ably.SummaryMultipleValues;\n\n    this._emitter.emit(MessageReactionSummaryEventType.Summary, {\n      type: MessageReactionSummaryEventType.Summary,\n      messageSerial: serial,\n      reactions: {\n        unique: unique,\n        distinct: distinct,\n        multiple: multiple,\n      },\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async send(messageSerial: string, params: SendMessageReactionParams): Promise<void> {\n    this._logger.trace('MessageReactions.send();', { messageSerial, params });\n    // Spec: CHA-MR4a2\n    assertValidSerial(messageSerial, 'send message reaction', 'messageSerial');\n\n    let { type, count } = params;\n    if (!type) {\n      type = this._defaultType;\n    }\n    if (type === MessageReactionType.Multiple && !count) {\n      count = 1;\n    }\n    const apiParams: APISendMessageReactionParams = { type, name: params.name };\n    if (count) {\n      apiParams.count = count;\n    }\n    return this._api.sendMessageReaction(this._roomName, messageSerial, apiParams);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async delete(messageSerial: string, params?: DeleteMessageReactionParams): Promise<void> {\n    this._logger.trace('MessageReactions.delete();', { messageSerial, params });\n    // Spec: CHA-MR11a2\n    assertValidSerial(messageSerial, 'delete message reaction', 'messageSerial');\n\n    let type = params?.type;\n    if (!type) {\n      type = this._defaultType;\n    }\n    if (type !== MessageReactionType.Unique && !params?.name) {\n      throw new Ably.ErrorInfo(\n        `unable to delete reaction of type ${type}; name not specified`,\n        ErrorCode.InvalidArgument,\n        400,\n      );\n    }\n    const apiParams: APIDeleteMessageReactionParams = { type };\n    if (type !== MessageReactionType.Unique) {\n      apiParams.name = params?.name;\n    }\n    return this._api.deleteMessageReaction(this._roomName, messageSerial, apiParams);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribe(listener: MessageReactionListener): Subscription {\n    this._logger.trace('MessageReactions.subscribe();');\n\n    const wrapped = wrap(listener);\n    this._emitter.on(MessageReactionSummaryEventType.Summary, wrapped);\n    return {\n      unsubscribe: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribeRaw(listener: MessageRawReactionListener): Subscription {\n    this._logger.trace('MessageReactions.subscribeRaw();');\n\n    if (!this._options?.rawMessageReactions) {\n      throw new Ably.ErrorInfo(\n        'unable to subscribe to message reactions; raw message reactions are not enabled',\n        ErrorCode.FeatureNotEnabledInRoom,\n        400,\n      );\n    }\n    const wrapped = wrap(listener);\n    this._emitter.on([MessageReactionRawEventType.Create, MessageReactionRawEventType.Delete], wrapped);\n    return {\n      unsubscribe: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * Merges the channel options to add support for message reactions.\n   * @param roomOptions The room options to merge for.\n   * @returns A function that merges the channel options for the room with the ones required for presence.\n   */\n  static channelOptionMerger(roomOptions: InternalRoomOptions): ChannelOptionsMerger {\n    return (options) => {\n      // annotation publish is always required for message reactions\n      if (!options.modes.includes('ANNOTATION_PUBLISH')) {\n        options.modes.push('ANNOTATION_PUBLISH');\n      }\n      // annotation subscribe is only required if the room has raw message reactions\n      if (roomOptions.messages.rawMessageReactions && !options.modes.includes('ANNOTATION_SUBSCRIBE')) {\n        options.modes.push('ANNOTATION_SUBSCRIBE');\n      }\n      return options;\n    };\n  }\n\n  async clientReactions(messageSerial: string, clientId?: string): Promise<Message['reactions']> {\n    this._logger.trace('MessageReactions.clientReactions();', { messageSerial, clientId });\n    assertValidSerial(messageSerial, 'get client reactions', 'messageSerial');\n    return this._api.getClientReactions(this._roomName, messageSerial, clientId);\n  }\n\n  /**\n   * Disposes of the message reactions instance, removing all listeners and subscriptions.\n   * This method should be called when the room is being released to ensure proper cleanup.\n   * @internal\n   */\n  dispose(): void {\n    this._logger.trace('DefaultMessageReactions.dispose();');\n\n    // Remove all user-level listeners from the emitter\n    this._emitter.off();\n\n    // Unsubscribe from channel events using stored unsubscribe functions\n    this._unsubscribeMessageEvents();\n\n    // Unsubscribe from annotations if they were enabled\n    this._unsubscribeAnnotationEvents?.();\n\n    this._logger.debug('DefaultMessageReactions.dispose(); disposed successfully');\n  }\n\n  /**\n   * Checks if there are any listeners registered by users.\n   * @internal\n   * @returns true if there are listeners, false otherwise.\n   */\n  hasListeners(): boolean {\n    return emitterHasListeners(this._emitter);\n  }\n}\n","import { ChatMessageAction } from './events.js';\nimport { JsonObject } from './json.js';\nimport { DefaultMessage, emptyMessageReactions, Message, MessageReactionSummary } from './message.js';\n\n// RestClientIdList represents a list of client IDs with aggregation data\nexport interface RestClientIdList {\n  total: number;\n  clientIds: string[];\n  clipped?: boolean;\n}\n\n// RestClientIdCounts represents client ID counts with aggregation data\nexport interface RestClientIdCounts {\n  total: number;\n  clientIds: Record<string, number>;\n  totalUnidentified: number;\n  clipped?: boolean;\n  totalClientIds?: number;\n}\n\n// RestVersion represents the version information of a message. (i.e. an update or delete)\nexport interface RestVersion {\n  serial: string;\n  timestamp: number;\n  clientId?: string;\n  description?: string;\n  metadata?: Record<string, string>;\n}\n\n// ChatMessageReactions represents reactions on a chat message\nexport interface RestChatMessageReactions {\n  unique?: Record<string, RestClientIdList>;\n  distinct?: Record<string, RestClientIdList>;\n  multiple?: Record<string, RestClientIdCounts>;\n}\n\n// RestMessage represents a message in V4 of the REST API.\nexport interface RestMessage {\n  serial: string;\n  version: RestVersion;\n  text: string;\n  clientId: string;\n  action: 'message.create' | 'message.update' | 'message.delete';\n  metadata: JsonObject;\n  headers: Record<string, string>;\n  userClaim?: string;\n  timestamp: number;\n  reactions?: RestChatMessageReactions;\n}\n\n/**\n * Converts a message object from its REST representation to the standard message object in the SDK.\n * @param message The message to convert from REST.\n * @returns The converted message.\n */\nexport const messageFromRest = (message: RestMessage): Message => {\n  const reactions = {\n    ...emptyMessageReactions(),\n    ...message.reactions,\n  };\n\n  // Iterate through all reaction types and normalize fields\n  // For unique and distinct reactions, ensure clipped is explicitly set to false if not present\n  for (const reactionType of ['unique', 'distinct']) {\n    const reactionTypeData = reactions[reactionType as keyof typeof reactions] as Record<string, RestClientIdList>;\n    for (const reactionName of Object.keys(reactionTypeData)) {\n      const reaction = reactionTypeData[reactionName];\n      if (reaction && !reaction.clipped) {\n        reaction.clipped = false;\n      }\n    }\n  }\n\n  // For multiple reactions, ensure clipped is explicitly set to false and totalClientIds is set to zero if not present\n  const multipleReactions = reactions.multiple;\n  for (const reactionName of Object.keys(multipleReactions)) {\n    const reaction = multipleReactions[reactionName];\n    if (reaction) {\n      if (!reaction.clipped) {\n        reaction.clipped = false;\n      }\n      if (!reaction.totalClientIds) {\n        reaction.totalClientIds = 0;\n      }\n    }\n  }\n\n  // Convert the action to a ChatMessageAction enum, defaulting to MessageCreate if the action is not found.\n  const action = Object.values(ChatMessageAction).includes(message.action as ChatMessageAction)\n    ? (message.action as ChatMessageAction)\n    : ChatMessageAction.MessageCreate;\n\n  // Create version information from the message\n  const version = {\n    serial: message.version.serial,\n    timestamp: new Date(message.version.timestamp),\n    clientId: message.version.clientId,\n    description: message.version.description,\n    metadata: message.version.metadata,\n  };\n\n  return new DefaultMessage({\n    serial: message.serial,\n    clientId: message.clientId,\n    text: message.text,\n    metadata: message.metadata,\n    headers: message.headers,\n    userClaim: message.userClaim,\n    action,\n    version,\n    timestamp: new Date(message.timestamp),\n    reactions: reactions as MessageReactionSummary,\n  });\n};\n","import * as Ably from 'ably';\n\nimport { ChatApi } from './chat-api.js';\nimport { ErrorCode } from './errors.js';\nimport { ChatMessageAction, ChatMessageEvent, ChatMessageEventType, RealtimeMessageName } from './events.js';\nimport { Logger } from './logger.js';\nimport { Message, MessageHeaders, MessageMetadata, MessageOperationMetadata } from './message.js';\nimport { parseMessage } from './message-parser.js';\nimport { DefaultMessageReactions, MessageReactions } from './message-reactions.js';\nimport { PaginatedResult } from './query.js';\nimport { on, once, subscribe } from './realtime-subscriptions.js';\nimport { messageFromRest } from './rest-types.js';\nimport { MessagesOptions } from './room-options.js';\nimport { assertValidSerial } from './serial.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { emitterHasListeners, wrap } from './utils/event-emitter.js';\n\n/**\n * Event names and their respective payloads emitted by the messages feature.\n */\ninterface MessageEventsMap {\n  [ChatMessageEventType.Created]: ChatMessageEvent;\n  [ChatMessageEventType.Updated]: ChatMessageEvent;\n  [ChatMessageEventType.Deleted]: ChatMessageEvent;\n}\n\n/**\n * Mapping of chat message actions to message events.\n */\nconst MessageActionsToEventsMap: Map<ChatMessageAction, ChatMessageEventType> = new Map<\n  ChatMessageAction,\n  ChatMessageEventType\n>([\n  [ChatMessageAction.MessageCreate, ChatMessageEventType.Created],\n  [ChatMessageAction.MessageUpdate, ChatMessageEventType.Updated],\n  [ChatMessageAction.MessageDelete, ChatMessageEventType.Deleted],\n]);\n\n/**\n * The order in which results should be returned when performing a paginated query (e.g. message history).\n */\nexport enum OrderBy {\n  /**\n   * Return results in ascending order (oldest first).\n   */\n  OldestFirst = 'oldestFirst',\n\n  /**\n   * Return results in descending order (newest first).\n   */\n  NewestFirst = 'newestFirst',\n}\n\n/**\n * Parameters for querying messages in a chat room.\n */\nexport interface HistoryParams {\n  /**\n   * The start of the time window to query from. If provided, the response will include\n   * messages with timestamps equal to or greater than this value.\n   * @defaultValue The beginning of time\n   */\n  start?: number;\n\n  /**\n   * The end of the time window to query from. If provided, the response will include\n   * messages with timestamps less than this value.\n   * @defaultValue Now\n   */\n  end?: number;\n\n  /**\n   * The maximum number of messages to return in the response.\n   * @defaultValue 100\n   */\n  limit?: number;\n\n  /**\n   * The direction to query messages in.\n   * If {@link OrderBy.OldestFirst}, the response will include messages from the start of the time window to the end.\n   * If {@link OrderBy.NewestFirst}, the response will include messages from the end of the time window to the start.\n   * If not provided, the default is {@link OrderBy.NewestFirst}.\n   * @defaultValue {@link OrderBy.NewestFirst}\n   */\n  orderBy?: OrderBy;\n}\n\n/**\n * The parameters supplied to a message action like delete or update.\n */\nexport interface OperationDetails {\n  /**\n   * Optional description for the message action.\n   */\n  description?: string;\n\n  /**\n   * Optional metadata that will be added to the action. Defaults to empty.\n   *\n   */\n  metadata?: MessageOperationMetadata;\n}\n\n/**\n * Parameters for updating a message.\n */\nexport interface UpdateMessageParams {\n  /**\n   * The new text of the message.\n   */\n  text: string;\n\n  /**\n   * Optional metadata of the message.\n   */\n  metadata?: MessageMetadata;\n\n  /**\n   * Optional headers of the message.\n   */\n  headers?: MessageHeaders;\n}\n\n/**\n * Params for sending a text message. Only `text` is mandatory.\n */\nexport interface SendMessageParams {\n  /**\n   * The text of the message.\n   */\n  text: string;\n\n  /**\n   * Optional metadata of the message.\n   *\n   * The metadata is a map of extra information that can be attached to chat\n   * messages. It is not used by Ably and is sent as part of the realtime\n   * message payload. Example use cases are setting custom styling like\n   * background or text colors or fonts, adding links to external images,\n   * emojis, etc.\n   *\n   * Do not use metadata for authoritative information. There is no server-side\n   * validation. When reading the metadata, treat it like user input.\n   *\n   */\n  metadata?: MessageMetadata;\n\n  /**\n   * Optional headers of the message.\n   *\n   * The headers are a flat key-value map and are sent as part of the realtime\n   * message's extras inside the `headers` property. They can serve similar\n   * purposes as the metadata, but they are read by Ably and can be used for\n   * features such as\n   * [subscription filters](https://faqs.ably.com/subscription-filters).\n   *\n   * Do not use the headers for authoritative information. There is no\n   * server-side validation. When reading the headers, treat them like user\n   * input.\n   *\n   */\n  headers?: MessageHeaders;\n}\n\n/**\n * A listener for message events in a chat room.\n * @param event The message event that was received.\n */\nexport type MessageListener = (event: ChatMessageEvent) => void;\n\n/**\n * A response object that allows you to control a message subscription.\n */\nexport interface MessageSubscriptionResponse extends Subscription {\n  /**\n   * Get the previous messages that were sent to the room before the listener was subscribed. This can be used to populate\n   * a room on initial subscription or to refresh local state after a discontinuity event.\n   *\n   * **NOTE**:\n   * - If the client experiences a discontinuity event (i.e. the connection was lost and could not be resumed), the starting point of\n   * `historyBeforeSubscribe` will be reset.\n   * - Calls to `historyBeforeSubscribe` will then wait for continuity to be restored before resolving.\n   * - Once continuity is restored, the subscription point will be set to the beginning of this new period of continuity. To\n   * ensure that no messages are missed (or updates/deletes), you should call `historyBeforeSubscribe` after any period of discontinuity to\n   * re-populate your local state.\n   * @example Populating messages on initial subscription\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, ChatMessageEventType } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   * const room = await chatClient.rooms.get('general-chat');\n   *\n   * // Local message state\n   * let localMessages: Message[] = [];\n   *\n   * const updateLocalMessageState = (messages: Message[], message:Message): void => {\n   *   // Find existing message in local state\n   *   const existingIndex = messages.findIndex(m => m.serial === message.serial);\n   *   if (existingIndex === -1) {\n   *     // New message, add to local state\n   *     messages.push(message);\n   *   } else {\n   *     // Existing message, update local state\n   *     messages[existingIndex] = messages[existingIndex].with(message);\n   *   }\n   *   // Messages should be ordered by serial\n   *   messages.sort((a, b) => a.serial < b.serial ? -1 : (b.serial < a.serial ? 1 : 0));\n   * };\n   *\n   *\n   * // Subscribe a listener to message events\n   * const subscription = room.messages.subscribe((event) => {\n   *   console.log(`Message ${event.type}:`, event.message.text);\n   *   updateLocalMessageState(localMessages, event.message);\n   * });\n   *\n   * // Attach to the room to start receiving message events\n   * await room.attach();\n   *\n   * // Get historical messages before subscription\n   * try {\n   *   const history = await subscription.historyBeforeSubscribe({ limit: 50 });\n   *   console.log(`Retrieved ${history.items.length} historical messages`);\n   *\n   *   // Process historical messages\n   *   history.items.forEach(message => {\n   *     console.log(`Historical: ${message.text} from ${message.clientId}`);\n   *     updateLocalMessageState(localMessages, message);\n   *   });\n   * } catch (error) {\n   *   console.error('Failed to retrieve message history:', error);\n   * }\n   * ```\n   * @example Handling discontinuities to refresh local state\n   * ```typescript\n   * // Subscribe a listener to message events as before\n   * const { historyBeforeSubscribe } = // subscribed listener response\n   *\n   * // Subscribe to discontinuity events on the room\n   * room.onDiscontinuity(async (reason) => {\n   *   console.warn('Discontinuity detected:', reason);\n   *   // Clear local state and re-fetch messages\n   *   localMessages = []\n   *   try {\n   *     // Fetch messages before the new subscription point\n   *     const history = await subscription.historyBeforeSubscribe({ limit: 100 });\n   *\n   *     // Merge each message into local state\n   *     history.items.forEach(message => {\n   *       updateLocalMessageState(localMessages, message);\n   *     });\n   *\n   *     console.log(`Refreshed local state with ${localMessages.length} messages`);\n   *   } catch (error) {\n   *     console.error('Failed to refresh messages after discontinuity:', error);\n   *   }\n   * });\n   *\n   * // Attach to the room to start receiving events\n   * await room.attach();\n   * ```\n   * @param params Parameters for the history query.\n   * @returns A promise that resolves with the paginated result of messages, in newest-to-oldest order.\n   */\n  historyBeforeSubscribe(params: Omit<HistoryParams, 'orderBy'>): Promise<PaginatedResult<Message>>;\n}\n\n/**\n * This interface is used to interact with messages in a chat room: subscribing\n * to new messages, fetching history, or sending messages.\n *\n * Get an instance via {@link Room.messages}.\n */\nexport interface Messages {\n  /**\n   * Subscribe to chat message events in this room.\n   *\n   * This method allows you to listen for chat message events and provides access to\n   * historical messages that occurred before the subscription was established.\n   *\n   * **Note**: The room must be attached for the listener to receive new message events.\n   * @param listener - A callback function that will be invoked when chat message events occur.\n   * @returns A {@link MessageSubscriptionResponse} object that provides:\n   *          - `unsubscribe()`: Method to stop listening for message events\n   *          - `historyBeforeSubscribe()`: Method to retrieve messages sent before subscription\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, ChatMessageEvent } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room and subscribe to messages\n   * const room = await chatClient.rooms.get('general-chat');\n   *\n   * const subscription = room.messages.subscribe((event: ChatMessageEvent) => {\n   *   console.log(`Message ${event.type}:`, event.message.text);\n   *   console.log('From:', event.message.clientId);\n   *   console.log('At:', event.message.timestamp);\n   *   // Handle different event types\n   * });\n   *\n   * // Attach to the room to start receiving events\n   * await room.attach();\n   *\n   * // Later, unsubscribe when done\n   * subscription.unsubscribe();\n   * ```\n   */\n  subscribe(listener: MessageListener): MessageSubscriptionResponse;\n\n  /**\n   * Get messages that have been previously sent to the chat room.\n   *\n   * This method retrieves historical messages based on the provided query options,\n   * allowing you to paginate through message history, filter by time ranges,\n   * and control the order of results.\n   *\n   * **NOTE**: This method uses the Ably Chat REST API and so does not require the room\n   * to be attached to be called.\n   * @param params - Query parameters to filter and control the message retrieval\n   * @returns A Promise that resolves to a {@link PaginatedResult} containing an array of {@link Message} objects\n   *          and methods for pagination control, or rejects with {@link ErrorCode.InvalidArgument} when the query fails due to invalid parameters\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, OrderBy } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('project-updates');\n   *\n   * // Retrieve message history with pagination\n   * try {\n   *   let result = await room.messages.history({\n   *     limit: 50,\n   *     orderBy: OrderBy.NewestFirst\n   *   });\n   *\n   *   console.log(`Retrieved ${result.items.length} messages`);\n   *   result.items.forEach(message => {\n   *     console.log(`${message.clientId}: ${message.text}`);\n   *   });\n   *\n   *   // Paginate through additional pages if available\n   *   while (result.hasNext()) {\n   *     const nextPage = await result.next();\n   *     if (nextPage) {\n   *       console.log(`Next page has ${nextPage.items.length} messages`);\n   *       nextPage.items.forEach(message => {\n   *         console.log(`${message.clientId}: ${message.text}`);\n   *       });\n   *       result = nextPage;\n   *     } else {\n   *     break; // No more pages\n   *     }\n   *   }\n   *   console.log('All message history retrieved');\n   * } catch (error) {\n   *   console.error('Failed to retrieve message history:', error);\n   * }\n   * ```\n   */\n  history(params: HistoryParams): Promise<PaginatedResult<Message>>;\n\n  /**\n   * Get a specific message by its unique serial identifier.\n   *\n   * This method retrieves a single message using its serial, which is a unique\n   * identifier assigned to each message when it's created.\n   *\n   * **NOTE**: This method uses the Ably Chat REST API and so does not require the room\n   * to be attached to be called.\n   * @param serial - The unique serial identifier of the message to retrieve.\n   * @returns A Promise that resolves to the {@link Message} object, or rejects with:\n   * - {@link Ably.ErrorInfo} when the message is not found or network/server errors occur\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('customer-support');\n   *\n   * // Get a specific message by its serial\n   * const messageSerial = '01726585978590-001@abcdefghij:001';\n   *\n   * try {\n   *   const message = await room.messages.get(messageSerial);\n   *\n   *   console.log(`Serial: ${message.serial}`);\n   *   console.log(`From: ${message.clientId}`);\n   *   console.log(`Text: ${message.text}`);\n   *\n   * } catch (error) {\n   *   if (error.code === 40400) {\n   *     console.error('Message not found:', messageSerial);\n   *   } else {\n   *     console.error('Failed to retrieve message:', error);\n   *   }\n   * }\n   * ```\n   */\n  get(serial: string): Promise<Message>;\n\n  /**\n   * Send a message to the chat room.\n   *\n   * This method publishes a new message to the chat room using the Ably Chat API.\n   * The message will be delivered to all subscribers in real-time.\n   *\n   * **Important**: The Promise may resolve before OR after the message is received\n   * from the realtime channel. This means subscribers may see the message before\n   * the send operation completes.\n   *\n   * **NOTE**: This method uses the Ably Chat REST API and so does not require the room\n   * to be attached to be called.\n   * @param params - Message parameters containing the text and optional metadata/headers\n   * @returns A Promise that resolves to the sent {@link Message} object, or rejects with:\n   * - {@link Ably.ErrorInfo} when the message fails to send due to network issues, authentication problems, or rate limiting\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('general-chat');\n   *\n   * // Send a message with metadata and headers\n   * try {\n   *   const message = await room.messages.send({\n   *     text: 'Hello, everyone! 👋',\n   *     metadata: {\n   *       priority: 'high',\n   *       category: 'greeting'\n   *     },\n   *     headers: {\n   *       'content-type': 'text',\n   *       'language': 'en'\n   *     }\n   *   });\n   *\n   *   console.log(`Message sent successfully: ${message.serial}`);\n   * } catch (error) {\n   *   console.error('Failed to send message:', error);\n   * }\n   * ```\n   */\n  send(params: SendMessageParams): Promise<Message>;\n\n  /**\n   * Delete a message in the chat room.\n   *\n   * This method performs a \"soft delete\" on a message, marking it as deleted rather\n   * than permanently removing it. The deleted message will still be visible in message\n   * history but will be flagged as deleted. Subscribers will receive a deletion event\n   * in real-time.\n   *\n   * **Important**: The Promise may resolve before OR after the deletion event is received\n   * from the realtime channel. Subscribers may see the deletion event before this method\n   * completes.\n   *\n   * **Note**:\n   * - The returned Message instance represents the state after deletion. If you\n   * have active subscriptions, use the event payloads from those subscriptions instead\n   * of the returned instance for consistency.\n   * - This method uses the Ably Chat REST API and so does not require the room\n   * to be attached to be called.\n   * @param serial - The unique identifier of the message to delete.\n   * @param details - Optional details to record about the delete action.\n   * @returns A Promise that resolves to the deleted {@link Message} object with\n   *          `isDeleted` set to true and deletion metadata populated, or rejects with:\n   * - {@link Ably.ErrorInfo} when the message is not found, user lacks permissions,\n   *            or network/server errors occur\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, Message } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('public-chat');\n   *\n   * // Serial of the message to delete\n   * const messageSerial = '01726585978590-001@abcdefghij:001';\n   *\n   * try {\n   *   const deletedMessage = await room.messages.delete(messageSerial, {\n   *     description: 'Inappropriate content removed by moderator',\n   *     metadata: {\n   *       reason: 'policy-violation',\n   *       timestamp: Date.now()\n   *     }\n   *   });\n   *\n   *   console.log(`Deleted message: ${deletedMessage.text}`);\n   * } catch (error) {\n   *   if (error.code === 40400) {\n   *     console.error('Message not found:', messageSerial);\n   *   } else if (error.code === 40300) {\n   *     console.error('Permission denied: Cannot delete this message');\n   *   } else {\n   *     console.error('Failed to delete message:', error);\n   *   }\n   * }\n   * ```\n   */\n  delete(serial: string, details?: OperationDetails): Promise<Message>;\n\n  /**\n   * Update a message in the chat room.\n   *\n   * This method modifies an existing message's content, metadata, or headers.\n   * The update creates a new version of the message while preserving the original\n   * serial identifier. Subscribers will receive an update event in real-time.\n   *\n   * **Important**: The Promise may resolve before OR after the update event is received\n   * from the realtime channel. Subscribers may see the update event before this method\n   * completes.\n   *\n   * **Note**:\n   * - This method uses PUT-like semantics. If metadata or headers are omitted\n   * from updateParams, they will be replaced with empty objects, not merged with existing values.\n   * - The returned Message instance represents the state after the update. If you\n   * have active subscriptions, use the event payloads from those subscriptions instead\n   * of the returned instance for consistency.\n   * - This method uses the Ably Chat REST API and so does not require the room\n   * to be attached to be called.\n   * @param serial - The unique identifier of the message to update.\n   * @param updateParams - The new message content and properties.\n   * @param details - Optional details to record about the delete action.\n   * @returns A Promise that resolves to the updated {@link Message} object with\n   *          `isUpdated` set to true and update metadata populated, or rejects with:\n   * - {@link Ably.ErrorInfo} when the message is not found, user lacks permissions,\n   *           or network/server errors occur.\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('team-updates');\n   *\n   * // Update a message with corrected text and tracking\n   * const messageSerial = '01726585978590-001@abcdefghij:001';\n   *\n   * try {\n   *   const updatedMessage = await room.messages.update(\n   *     messageSerial,\n   *     {\n   *       text: 'Meeting is scheduled for 3 PM (corrected time)',\n   *     },\n   *     {\n   *       description: 'Corrected meeting time',\n   *       metadata: {\n   *         editTimestamp: Date.now()\n   *       }\n   *     }\n   *   );\n   *\n   *   console.log(`Updated text: ${updatedMessage.text}`);\n   * } catch (error) {\n   *   if (error.code === 40400) {\n   *     console.error('Message not found:', messageSerial);\n   *   } else if (error.code === 40300) {\n   *     console.error('Permission denied: Cannot update this message');\n   *   } else {\n   *     console.error('Failed to update message:', error);\n   *   }\n   * }\n   * ```\n   */\n  update(serial: string, updateParams: UpdateMessageParams, details?: OperationDetails): Promise<Message>;\n\n  /**\n   * Send, delete, and subscribe to message reactions.\n   *\n   * This property provides access to the message reactions functionality, allowing you to\n   * add reactions to specific messages, remove reactions, and subscribe to reaction events\n   * in real-time.\n   */\n  reactions: MessageReactions;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultMessages implements Messages {\n  private readonly _roomName: string;\n  private readonly _options: MessagesOptions;\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _chatApi: ChatApi;\n  private readonly _listenerSubscriptionPoints: Map<\n    MessageListener,\n    Promise<{\n      fromSerial: string;\n    }>\n  >;\n  private readonly _pendingPromiseRejecters = new Set<(error: Error) => void>();\n  private readonly _pendingAttachListeners = new Set<() => void>();\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<MessageEventsMap>();\n  private readonly _unsubscribeMessageEvents: () => void;\n  private readonly _offChannelAttached: () => void;\n  private readonly _offChannelUpdate: () => void;\n  private readonly _reactions: DefaultMessageReactions;\n\n  /**\n   * Constructs a new `DefaultMessages` instance.\n   * @param roomName The unique identifier of the room.\n   * @param options The room options for the messages.\n   * @param channel An instance of the Realtime channel for the room.\n   * @param chatApi An instance of the ChatApi.\n   * @param logger An instance of the Logger.\n   */\n  constructor(\n    roomName: string,\n    options: MessagesOptions,\n    channel: Ably.RealtimeChannel,\n    chatApi: ChatApi,\n    logger: Logger,\n  ) {\n    this._roomName = roomName;\n    this._options = options;\n    this._channel = channel;\n    this._chatApi = chatApi;\n    this._logger = logger;\n    this._listenerSubscriptionPoints = new Map<MessageListener, Promise<{ fromSerial: string }>>();\n\n    this._reactions = new DefaultMessageReactions(this._logger, options, this._chatApi, this._roomName, this._channel);\n\n    // Create bound listeners\n    const messageEventsListener = this._processEvent.bind(this);\n    const channelAttachedListener = (stateChange: Ably.ChannelStateChange) => {\n      this._handleAttach(stateChange.resumed);\n    };\n    const channelUpdateListener = (stateChange: Ably.ChannelStateChange) => {\n      if (stateChange.current === 'attached' && stateChange.previous === 'attached') {\n        this._handleAttach(stateChange.resumed);\n      }\n    };\n\n    // Use subscription helpers to create cleanup functions\n    this._unsubscribeMessageEvents = subscribe(this._channel, [RealtimeMessageName.ChatMessage], messageEventsListener);\n    this._offChannelAttached = on(this._channel, 'attached', channelAttachedListener);\n    this._offChannelUpdate = on(this._channel, 'update', channelUpdateListener);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get reactions(): MessageReactions {\n    return this._reactions;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  private async _getBeforeSubscriptionStart(\n    listener: MessageListener,\n    params: Omit<HistoryParams, 'orderBy'>,\n  ): Promise<PaginatedResult<Message>> {\n    this._logger.trace(`DefaultSubscriptionManager.getBeforeSubscriptionStart();`);\n\n    const subscriptionPoint = this._listenerSubscriptionPoints.get(listener);\n\n    if (subscriptionPoint === undefined) {\n      this._logger.error(`DefaultSubscriptionManager.getBeforeSubscriptionStart(); listener has not been subscribed`);\n      throw new Ably.ErrorInfo(\n        'unable to query history; listener has not been subscribed',\n        ErrorCode.ListenerNotSubscribed,\n        400,\n      ) as unknown as Error;\n    }\n\n    // Get the subscription point of the listener\n    const subscriptionPointParams = await subscriptionPoint;\n\n    // Query messages from the subscription point to the start of the time window\n    return this._chatApi.history(this._roomName, {\n      ...params,\n      orderBy: OrderBy.NewestFirst,\n      ...subscriptionPointParams,\n    });\n  }\n\n  /**\n   * Handle the case where the channel experiences a detach and reattaches.\n   * @param fromResume Whether the attach is from a resume operation.\n   */\n  private _handleAttach(fromResume: boolean) {\n    this._logger.trace(`DefaultSubscriptionManager.handleAttach();`);\n\n    // Do nothing if we have resumed as there is no discontinuity in the message stream\n    if (fromResume) return;\n\n    // Reset subscription points for all listeners\n    const newSubscriptionStartResolver = this._subscribeAtChannelAttach();\n    for (const [listener] of this._listenerSubscriptionPoints.entries()) {\n      this._listenerSubscriptionPoints.set(listener, newSubscriptionStartResolver);\n    }\n  }\n\n  /**\n   * Create a promise that resolves with the attachSerial of the channel or the serial of the latest message.\n   * @returns A promise that resolves to an object containing fromSerial and subscriptionPoint.\n   */\n  private async _resolveSubscriptionStart(): Promise<{\n    fromSerial: string;\n  }> {\n    const channelWithProperties = this._getChannelProperties();\n\n    // If we are attached, we can resolve with the channelSerial\n    if (channelWithProperties.state === 'attached') {\n      if (channelWithProperties.properties.channelSerial) {\n        return { fromSerial: channelWithProperties.properties.channelSerial };\n      }\n      this._logger.error(`DefaultSubscriptionManager.handleAttach(); channelSerial is undefined`);\n      throw new Ably.ErrorInfo(\n        'unable to query messages; channel is attached but channelSerial is not defined',\n        ErrorCode.ChannelSerialNotDefined,\n        500,\n      ) as unknown as Error;\n    }\n\n    return this._subscribeAtChannelAttach();\n  }\n\n  private _getChannelProperties(): Ably.RealtimeChannel & {\n    properties: { attachSerial: string | undefined; channelSerial: string | undefined };\n  } {\n    // Get the attachSerial from the channel properties\n    return this._channel as Ably.RealtimeChannel & {\n      properties: {\n        attachSerial: string | undefined;\n        channelSerial: string | undefined;\n      };\n    };\n  }\n\n  private async _subscribeAtChannelAttach(): Promise<{ fromSerial: string }> {\n    const channelWithProperties = this._getChannelProperties();\n    return new Promise((resolve, reject) => {\n      // Store the reject function so we can call it during disposal\n      this._pendingPromiseRejecters.add(reject);\n\n      const cleanup = () => {\n        this._pendingPromiseRejecters.delete(reject);\n      };\n\n      // Check if the state is now attached\n      if (channelWithProperties.state === 'attached') {\n        // Get the attachSerial from the channel properties\n        // AttachSerial should always be defined at this point, but we check just in case\n        this._logger.debug('Messages._subscribeAtChannelAttach(); channel is attached already, using attachSerial', {\n          attachSerial: channelWithProperties.properties.attachSerial,\n        });\n        cleanup();\n\n        if (channelWithProperties.properties.attachSerial) {\n          resolve({ fromSerial: channelWithProperties.properties.attachSerial });\n        } else {\n          this._logger.error(`DefaultSubscriptionManager.handleAttach(); attachSerial is undefined`);\n          cleanup();\n          reject(\n            new Ably.ErrorInfo(\n              'unable to query messages; channel is attached but attachSerial is not defined',\n              ErrorCode.ChannelSerialNotDefined,\n              500,\n            ) as unknown as Error,\n          );\n        }\n        return;\n      }\n\n      const offAttachedListener = once(channelWithProperties, 'attached', () => {\n        // Get the attachSerial from the channel properties\n        // AttachSerial should always be defined at this point, but we check just in case\n        this._logger.debug('Messages._subscribeAtChannelAttach(); channel is now attached, using attachSerial', {\n          attachSerial: channelWithProperties.properties.attachSerial,\n        });\n        cleanup();\n        this._pendingAttachListeners.delete(offAttachedListener);\n\n        if (channelWithProperties.properties.attachSerial) {\n          resolve({ fromSerial: channelWithProperties.properties.attachSerial });\n        } else {\n          this._logger.error(`DefaultSubscriptionManager.handleAttach(); attachSerial is undefined`);\n          reject(\n            new Ably.ErrorInfo(\n              'unable to query messages; channel is attached but attachSerial is not defined',\n              ErrorCode.ChannelSerialNotDefined,\n              500,\n            ) as unknown as Error,\n          );\n        }\n      });\n\n      this._pendingAttachListeners.add(offAttachedListener);\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async history(options: HistoryParams): Promise<PaginatedResult<Message>> {\n    this._logger.trace('Messages.query();');\n    return this._chatApi.history(this._roomName, options);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async get(serial: string): Promise<Message> {\n    this._logger.trace('Messages.get();', { serial });\n    return this._chatApi.getMessage(this._roomName, serial);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async send(params: SendMessageParams): Promise<Message> {\n    this._logger.trace('Messages.send();', { params });\n\n    const { text, metadata, headers } = params;\n\n    const response = await this._chatApi.sendMessage(this._roomName, { text, headers, metadata });\n    return messageFromRest(response);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async delete(serial: string, details?: OperationDetails): Promise<Message> {\n    this._logger.trace('Messages.delete();', { serial, details });\n    // Spec: CHA-M9f\n    assertValidSerial(serial, 'delete message', 'serial');\n    const response = await this._chatApi.deleteMessage(this._roomName, serial, details);\n\n    return messageFromRest(response);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async update(serial: string, updateParams: UpdateMessageParams, details?: OperationDetails): Promise<Message> {\n    this._logger.trace('Messages.update();', { serial, updateParams, details });\n    // Spec: CHA-M8g\n    assertValidSerial(serial, 'update message', 'serial');\n    const response = await this._chatApi.updateMessage(this._roomName, serial, {\n      message: {\n        text: updateParams.text,\n        metadata: updateParams.metadata,\n        headers: updateParams.headers,\n      },\n      ...details,\n    });\n\n    this._logger.debug('Messages.update(); message update successfully', { updateParams });\n    return messageFromRest(response);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  subscribe(listener: MessageListener): MessageSubscriptionResponse {\n    this._logger.trace('Messages.subscribe();');\n    const wrapped = wrap(listener);\n    this._emitter.on(\n      [ChatMessageEventType.Created, ChatMessageEventType.Updated, ChatMessageEventType.Deleted],\n      wrapped,\n    );\n\n    // Set the subscription point to a promise that resolves when the channel attaches or with the latest message\n    const resolvedSubscriptionStart = this._resolveSubscriptionStart();\n\n    // Add a handler for unhandled rejections in case the room is released before the subscription point is resolved\n    resolvedSubscriptionStart.catch(() => {\n      this._logger.debug('Messages.subscribe(); subscription point was not resolved before the room was released');\n    });\n\n    this._listenerSubscriptionPoints.set(wrapped, resolvedSubscriptionStart);\n\n    return {\n      unsubscribe: () => {\n        // Remove the wrapped listener from the subscription points\n        this._listenerSubscriptionPoints.delete(wrapped);\n        this._logger.trace('Messages.unsubscribe();');\n        this._emitter.off(wrapped);\n      },\n      historyBeforeSubscribe: async (params: Omit<HistoryParams, 'orderBy'>) =>\n        this._getBeforeSubscriptionStart(wrapped, params),\n    };\n  }\n\n  private _processEvent(channelEventMessage: Ably.InboundMessage) {\n    this._logger.trace('Messages._processEvent();', {\n      channelEventMessage,\n    });\n    const { action } = channelEventMessage;\n    const event = MessageActionsToEventsMap.get(action as ChatMessageAction);\n    if (!event) {\n      this._logger.debug('Messages._processEvent(); received unknown message action', { action });\n      return;\n    }\n    // Send the message to the listeners\n    const message = parseMessage(channelEventMessage);\n    this._emitter.emit(event, { type: event, message: message });\n  }\n\n  /**\n   * Disposes of the messages instance, removing all listeners and subscriptions.\n   * This method should be called when the room is being released to ensure proper cleanup.\n   * @internal\n   */\n  dispose(): void {\n    this._logger.trace('DefaultMessages.dispose();');\n\n    // Remove all user-level listeners from the emitter\n    this._emitter.off();\n\n    // Reject all pending subscription point promises to break circular references\n    const disposalError = new Ably.ErrorInfo(\n      'unable to query messages; room has been disposed',\n      ErrorCode.ResourceDisposed,\n      400,\n    ) as unknown as Error;\n    for (const rejectFn of this._pendingPromiseRejecters) {\n      try {\n        rejectFn(disposalError);\n      } catch {\n        // Ignore errors from already resolved/rejected promises\n      }\n    }\n    this._pendingPromiseRejecters.clear();\n\n    // Clear all subscription points\n    this._listenerSubscriptionPoints.clear();\n\n    // Remove all pending attach listeners\n    for (const offAttachedListener of this._pendingAttachListeners) {\n      offAttachedListener();\n    }\n    this._pendingAttachListeners.clear();\n\n    // Unsubscribe from channel events using stored unsubscribe functions\n    this._unsubscribeMessageEvents();\n\n    // Remove specific channel state listeners using stored unsubscribe functions\n    this._offChannelAttached();\n    this._offChannelUpdate();\n\n    // Dispose of the reactions instance\n    this._reactions.dispose();\n\n    this._logger.debug('DefaultMessages.dispose(); disposed successfully');\n  }\n\n  /**\n   * Checks if there are any listeners registered by users.\n   * @internal\n   * @returns true if there are listeners, false otherwise.\n   */\n  hasListeners(): boolean {\n    return emitterHasListeners(this._emitter);\n  }\n}\n","import * as Ably from 'ably';\n\nimport { ErrorCode } from './errors.js';\nimport { Logger } from './logger.js';\nimport { Message, MessageHeaders, MessageMetadata, MessageOperationMetadata } from './message.js';\nimport { OrderBy } from './messages.js';\nimport { OccupancyData } from './occupancy-parser.js';\nimport { PaginatedResult } from './query.js';\nimport { messageFromRest, RestMessage } from './rest-types.js';\n\n/**\n * Parameters for querying message history.\n */\nexport interface HistoryQueryParams {\n  start?: number;\n  end?: number;\n  orderBy?: OrderBy;\n  limit?: number;\n  /**\n   * Serial indicating the starting point for message retrieval.\n   * This serial is specific to the region of the channel the client is connected to. Messages published within\n   * the same region of the channel are guaranteed to be received in increasing serial order.\n   * @defaultValue undefined (not used if not specified)\n   */\n  fromSerial?: string;\n}\n\n/**\n * In the REST API, we currently use the `direction` query parameter to specify the order of messages instead\n * of orderBy. So define this type for conversion purposes.\n */\ntype ApiHistoryQueryParams = Omit<HistoryQueryParams, 'orderBy'> & {\n  direction?: 'forwards' | 'backwards';\n};\n\ninterface SendMessageParams {\n  text: string;\n  metadata?: MessageMetadata;\n  headers?: MessageHeaders;\n}\n\ntype UpdateMessageResponse = RestMessage;\n\ntype DeleteMessageResponse = RestMessage;\n\ninterface UpdateMessageParams {\n  /**\n   * Message data to update. All fields are updated and, if omitted, they are\n   * set to empty.\n   */\n  message: {\n    text: string;\n    metadata?: MessageMetadata;\n    headers?: MessageHeaders;\n  };\n\n  /** Description of the update action */\n  description?: string;\n\n  /** Metadata of the update action */\n  metadata?: MessageOperationMetadata;\n}\n\ninterface OperationDetails {\n  /** Description of the operation */\n  description?: string;\n\n  /** Metadata of the operation */\n  metadata?: MessageOperationMetadata;\n}\n\n/**\n * Parameters for sending a message reaction.\n */\nexport interface SendMessageReactionParams {\n  /**\n   * The type of reaction, must be one of {@link MessageReactionType}.\n   */\n  type: string;\n\n  /**\n   * The reaction name to add; ie. the emoji.\n   */\n  name: string;\n\n  /**\n   * The count of the reaction for type {@link MessageReactionType.Multiple}.\n   * Defaults to 1 if not set. Not supported for other reaction types.\n   * @defaultValue 1\n   */\n  count?: number;\n}\n\n/**\n * Parameters for deleting a message reaction.\n */\nexport interface DeleteMessageReactionParams {\n  /**\n   * The type of reaction, must be one of {@link MessageReactionType}.\n   */\n  type: string;\n\n  /**\n   * The reaction name to remove, ie. the emoji. Required for all reaction types\n   * except {@link MessageReactionType.Unique}.\n   */\n  name?: string;\n}\n\n/**\n * Bridge for the Chat REST API.\n * @internal\n */\nexport class ChatApi {\n  private readonly _realtime: Ably.Realtime;\n  private readonly _logger: Logger;\n  private readonly _apiProtocolVersion: number = 4;\n\n  constructor(realtime: Ably.Realtime, logger: Logger) {\n    this._realtime = realtime;\n    this._logger = logger;\n  }\n\n  async history(roomName: string, params: HistoryQueryParams): Promise<PaginatedResult<Message>> {\n    // convert the params into internal format\n    const apiParams: ApiHistoryQueryParams = { ...params };\n    if (params.orderBy) {\n      switch (params.orderBy) {\n        case OrderBy.NewestFirst: {\n          apiParams.direction = 'backwards';\n          break;\n        }\n        case OrderBy.OldestFirst: {\n          apiParams.direction = 'forwards';\n          break;\n        }\n        default: {\n          // in vanilla JS use-cases, without types, we need to check non-enum values\n          throw new Ably.ErrorInfo(\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            `unable to query messages; invalid orderBy value: ${params.orderBy}`,\n            ErrorCode.InvalidArgument,\n            400,\n          );\n        }\n      }\n    }\n\n    const data = await this._makeAuthorizedPaginatedRequest<RestMessage>(\n      this._roomUrl(roomName, '/messages'),\n      apiParams,\n    );\n    return this._recursivePaginateMessages(data);\n  }\n\n  private _recursivePaginateMessages(data: PaginatedResult<RestMessage>): PaginatedResult<Message> {\n    const result: PaginatedResult<Message> = {} as PaginatedResult<Message>;\n    result.items = data.items.map((payload) => messageFromRest(payload));\n\n    // Recursively map the next paginated data\n    result.next = async () => {\n      const nextData = await data.next();\n      // eslint-disable-next-line unicorn/no-null\n      return nextData ? this._recursivePaginateMessages(nextData) : null;\n    };\n\n    result.first = async () => {\n      const firstData = await data.first();\n      return this._recursivePaginateMessages(firstData);\n    };\n\n    result.current = async () => {\n      const currentData = await data.current();\n      return this._recursivePaginateMessages(currentData);\n    };\n\n    result.hasNext = () => data.hasNext();\n\n    result.isLast = () => data.isLast();\n\n    return { ...data, ...result };\n  }\n\n  async getMessage(roomName: string, serial: string): Promise<Message> {\n    const restMessage = await this._makeAuthorizedRequest<RestMessage>(this._messageUrl(roomName, serial), 'GET');\n    return messageFromRest(restMessage);\n  }\n\n  async deleteMessage(roomName: string, serial: string, details?: OperationDetails): Promise<DeleteMessageResponse> {\n    const body = {\n      ...(details?.description && { description: details.description }),\n      ...(details?.metadata && { metadata: details.metadata }),\n    };\n    return this._makeAuthorizedRequest<DeleteMessageResponse>(\n      this._messageUrl(roomName, serial, '/delete'),\n      'POST',\n      body,\n      {},\n    );\n  }\n\n  async sendMessage(roomName: string, params: SendMessageParams): Promise<RestMessage> {\n    const body = {\n      text: params.text,\n      ...(params.metadata && { metadata: params.metadata }),\n      ...(params.headers && { headers: params.headers }),\n    };\n    return this._makeAuthorizedRequest<RestMessage>(this._roomUrl(roomName, '/messages'), 'POST', body);\n  }\n\n  async updateMessage(roomName: string, serial: string, params: UpdateMessageParams): Promise<UpdateMessageResponse> {\n    return this._makeAuthorizedRequest<UpdateMessageResponse>(this._messageUrl(roomName, serial), 'PUT', params);\n  }\n\n  async sendMessageReaction(roomName: string, serial: string, data: SendMessageReactionParams): Promise<void> {\n    return this._makeAuthorizedRequest(this._messageUrl(roomName, serial, '/reactions'), 'POST', data);\n  }\n\n  async deleteMessageReaction(roomName: string, serial: string, data: DeleteMessageReactionParams): Promise<void> {\n    return this._makeAuthorizedRequest(this._messageUrl(roomName, serial, '/reactions'), 'DELETE', undefined, data);\n  }\n\n  async getClientReactions(roomName: string, serial: string, clientId?: string): Promise<Message['reactions']> {\n    const params = clientId ? { forClientId: clientId } : {};\n    return this._makeAuthorizedRequest<Message['reactions']>(\n      this._messageUrl(roomName, serial, '/client-reactions'),\n      'GET',\n      undefined,\n      params,\n    );\n  }\n\n  async getOccupancy(roomName: string): Promise<OccupancyData> {\n    return this._makeAuthorizedRequest<OccupancyData>(this._roomUrl(roomName, '/occupancy'), 'GET');\n  }\n\n  private async _makeAuthorizedRequest<RES = undefined>(\n    url: string,\n    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH',\n    body?: unknown,\n    params?: unknown,\n  ): Promise<RES> {\n    const response = await this._doRequest(url, method, params, body);\n    return response.items[0] as RES;\n  }\n\n  private async _makeAuthorizedPaginatedRequest<RES>(\n    url: string,\n    params?: unknown,\n    body?: unknown,\n  ): Promise<PaginatedResult<RES>> {\n    return this._doRequest(url, 'GET', params, body);\n  }\n\n  private async _doRequest<RES>(\n    url: string,\n    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH',\n    params?: unknown,\n    body?: unknown,\n  ): Promise<PaginatedResult<RES>> {\n    const response = await this._realtime.request(method, url, this._apiProtocolVersion, params, body);\n    if (!response.success) {\n      this._logger.error('ChatApi._doRequest(); failed to make request', {\n        url,\n        method,\n        statusCode: response.statusCode,\n        errorCode: response.errorCode,\n        errorMessage: response.errorMessage,\n      });\n      throw new Ably.ErrorInfo(response.errorMessage, response.errorCode, response.statusCode);\n    }\n\n    return response;\n  }\n\n  /**\n   * Returns a URL for a specific room.\n   * @param roomName Name of the room\n   * @param suffix The suffix to add to the room URL, prefixed with /\n   * @returns string The formatted URL\n   */\n  private _roomUrl(roomName: string, suffix = ''): string {\n    return `/chat/v4/rooms/${encodeURIComponent(roomName)}${suffix}`;\n  }\n\n  /**\n   * Returns a URL for a specific message in the room.\n   * @param roomName string Name of the room\n   * @param serial string The serial of the message\n   * @param suffix The suffix to add to the room URL, prefixed with /\n   * @returns string The formatted URL\n   */\n  private _messageUrl(roomName: string, serial: string, suffix = ''): string {\n    return `${this._roomUrl(roomName, '/messages')}/${encodeURIComponent(serial)}${suffix}`;\n  }\n}\n","/**\n * Gets the single main channel for the chat room.\n * @param roomName The room name.\n * @returns  The channel name.\n */\nexport const roomChannelName = (roomName: string): string => `${roomName}::$chat`;\n","import * as Ably from 'ably';\n\n// Update this when you release a new version\nexport const VERSION = '1.2.0';\nexport const CHANNEL_OPTIONS_AGENT_STRING = `chat-js/${VERSION}`;\nexport const CHANNEL_OPTIONS_AGENT_STRING_REACT = `chat-react/${VERSION}`;\n// Modes required for basic message functionality\nexport const DEFAULT_CHANNEL_MODES: Ably.ChannelMode[] = ['PUBLISH', 'SUBSCRIBE'];\nexport const DEFAULT_CHANNEL_OPTIONS: Ably.ChannelOptions = {\n  params: { agent: CHANNEL_OPTIONS_AGENT_STRING },\n  attachOnSubscribe: false,\n  modes: DEFAULT_CHANNEL_MODES,\n};\n\nexport const DEFAULT_CHANNEL_OPTIONS_REACT: Ably.ChannelOptions = {\n  // Spec: CHA-IN1b1\n  params: { agent: `${CHANNEL_OPTIONS_AGENT_STRING} ${CHANNEL_OPTIONS_AGENT_STRING_REACT}` },\n  attachOnSubscribe: false,\n  modes: DEFAULT_CHANNEL_MODES,\n};\n","import * as Ably from 'ably';\n\nimport { roomChannelName } from './channel.js';\nimport { ErrorCode } from './errors.js';\nimport { Logger } from './logger.js';\nimport { DEFAULT_CHANNEL_OPTIONS, DEFAULT_CHANNEL_OPTIONS_REACT } from './version.js';\n\nexport type ChannelOptionsWithModes = Omit<Ably.ChannelOptions, 'modes'> & Required<Pick<Ably.ChannelOptions, 'modes'>>;\n\nexport type ChannelOptionsMerger = (options: ChannelOptionsWithModes) => ChannelOptionsWithModes;\n\nexport class ChannelManager {\n  private readonly _realtime: Ably.Realtime;\n  private readonly _logger: Logger;\n  private _registeredOptions: ChannelOptionsWithModes;\n  private readonly _isReact: boolean;\n  private _resolvedChannel?: Ably.RealtimeChannel;\n  private readonly _channelId: string;\n\n  constructor(roomName: string, realtime: Ably.Realtime, logger: Logger, isReact: boolean) {\n    logger.trace('ChannelManager();', { isReact });\n    this._realtime = realtime;\n    this._logger = logger;\n    this._isReact = isReact;\n    this._registeredOptions = this._defaultChannelOptions();\n    this._channelId = roomChannelName(roomName);\n  }\n\n  mergeOptions(merger: ChannelOptionsMerger): void {\n    this._logger.trace('ChannelManager.mergeOptions();');\n    if (this._resolvedChannel) {\n      this._logger.error('unable to modify channel options; channel has already been requested');\n      throw new Ably.ErrorInfo(\n        'unable to modify channel options; channel has already been requested',\n        ErrorCode.ChannelOptionsCannotBeModified,\n        400,\n      );\n    }\n\n    this._registeredOptions = merger(this._registeredOptions);\n  }\n\n  get(): Ably.RealtimeChannel {\n    this._logger.trace('ChannelManager.get();');\n\n    this._resolvedChannel ??= this._realtime.channels.get(this._channelId, this._registeredOptions);\n\n    return this._resolvedChannel;\n  }\n\n  release(): void {\n    this._logger.trace('ChannelManager.release();', { channelId: this._channelId });\n    if (!this._resolvedChannel) {\n      return;\n    }\n\n    this._realtime.channels.release(this._channelId);\n  }\n\n  private _defaultChannelOptions(): ChannelOptionsWithModes {\n    this._logger.trace('ChannelManager._defaultChannelOptions();');\n\n    // Spec: CHA-IN1e\n    const baseOptions = this._isReact ? DEFAULT_CHANNEL_OPTIONS_REACT : DEFAULT_CHANNEL_OPTIONS;\n    this._logger.trace(this._isReact ? 'using react channel options' : 'using default channel options');\n\n    // Create a deep copy of the options, ensuring modes array is also copied\n    return { ...baseOptions, modes: [...(baseOptions.modes ?? [])] } as ChannelOptionsWithModes;\n  }\n}\n","import * as Ably from 'ably';\n\n/**\n * Represents the occupancy data of a chat room.\n */\nexport interface OccupancyData {\n  /**\n   * The number of connections to the chat room.\n   */\n  connections: number;\n\n  /**\n   * The number of presence members in the chat room - members who have entered presence.\n   */\n  presenceMembers: number;\n}\n\n/**\n * Represents the structure of an occupancy message payload.\n */\ninterface OccupancyPayload {\n  data?: {\n    metrics?: {\n      connections?: number;\n      presenceMembers?: number;\n    };\n  };\n}\n\n/**\n * Parses occupancy data from an Ably message, using fallback values of 0 for invalid data.\n * @param message The Ably message containing occupancy data\n * @returns Parsed occupancy data with fallback values for invalid fields\n */\nexport const parseOccupancyMessage = (message: Ably.InboundMessage): OccupancyData => {\n  const payload = message as OccupancyPayload;\n  let connections = 0;\n  let presenceMembers = 0;\n\n  // Check if data is a valid object\n  if (!payload.data || typeof payload.data !== 'object') {\n    return { connections, presenceMembers };\n  }\n\n  const { metrics } = payload.data;\n\n  // Check if metrics is undefined or null\n  if (!metrics || typeof metrics !== 'object') {\n    return { connections, presenceMembers };\n  }\n\n  // Parse connections\n  if (typeof metrics.connections === 'number' && Number.isInteger(metrics.connections)) {\n    connections = metrics.connections;\n  }\n\n  // Parse presenceMembers\n  if (typeof metrics.presenceMembers === 'number' && Number.isInteger(metrics.presenceMembers)) {\n    presenceMembers = metrics.presenceMembers;\n  }\n\n  return { connections, presenceMembers };\n};\n","import * as Ably from 'ably';\n\nimport { ChannelOptionsMerger } from './channel-manager.js';\nimport { ChatApi } from './chat-api.js';\nimport { ErrorCode } from './errors.js';\nimport { OccupancyEvent, OccupancyEventType, RealtimeMetaEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { OccupancyData, parseOccupancyMessage } from './occupancy-parser.js';\nimport { subscribe } from './realtime-subscriptions.js';\nimport { InternalRoomOptions } from './room-options.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { emitterHasListeners, wrap } from './utils/event-emitter.js';\n\n/**\n * This interface is used to interact with occupancy in a chat room: subscribing to occupancy updates and\n * fetching the current room occupancy metrics.\n *\n * Get an instance via {@link Room.occupancy}.\n */\nexport interface Occupancy {\n  /**\n   * Subscribes to occupancy updates for the chat room.\n   *\n   * Receives updates whenever the number of connections or present members in the room changes.\n   * This is useful for displaying active user counts, monitoring room capacity, or tracking\n   * engagement metrics.\n   *\n   * **Note**:\n   * - Requires {@link OccupancyOptions.enableEvents} to be true in the room's occupancy options.\n   * - The room should be attached to receive occupancy events.\n   * @param listener - Callback invoked when room occupancy changes\n   * @returns Subscription object with an unsubscribe method\n   * @throws An {@link Ably.ErrorInfo} with {@link ErrorCode.FeatureNotEnabledInRoom} if occupancy events are not enabled\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, OccupancyEvent } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Create room with occupancy events enabled\n   * const room = await chatClient.rooms.get('conference-room', {\n   *   occupancy: { enableEvents: true }\n   * });\n   *\n   *\n   * // Subscribe to occupancy updates\n   * const subscription = room.occupancy.subscribe((event: OccupancyEvent) => {\n   *   const { connections, presenceMembers } = event.occupancy;\n   *\n   *   console.log(`Room occupancy updated:`);\n   *   console.log(`Total connections: ${connections}`);\n   *   console.log(`Presence members: ${presenceMembers}`);\n   * });\n   *\n   * // Attach to the room to start receiving events\n   * await room.attach();\n   *\n   * // Later, unsubscribe when done\n   * subscription.unsubscribe();\n   * ```\n   */\n  subscribe(listener: OccupancyListener): Subscription;\n\n  /**\n   * Fetches the current occupancy of the chat room from the server.\n   *\n   * Retrieves the latest occupancy metrics, including the number\n   * of active connections and presence members. Use this for on-demand occupancy\n   * checks or when occupancy events are not enabled.\n   *\n   * **Note**: This method uses the Ably Chat REST API and so does not require the room\n   * to be attached to be called.\n   * @returns Promise resolving to current occupancy data\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, OccupancyData } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('webinar-room');\n   *\n   * // Get current occupancy on demand\n   * try {\n   *   const occupancy: OccupancyData = await room.occupancy.get();\n   *\n   *   console.log(`Current room statistics:`);\n   *   console.log(`Active connections: ${occupancy.connections}`);\n   *   console.log(`Presence members: ${occupancy.presenceMembers}`);\n   * } catch (error) {\n   *   console.error('Failed to fetch occupancy:', error);\n   * }\n   * ```\n   */\n  get(): Promise<OccupancyData>;\n\n  /**\n   * Gets the latest occupancy data cached from realtime events.\n   *\n   * Returns the most recent occupancy metrics received via subscription. Returns undefined\n   * if no occupancy events have been received yet since the room was attached.\n   *\n   * **Note**:\n   * - Requires `enableEvents` to be true in the room's occupancy options.\n   * - Returns undefined until the first occupancy event is received.\n   * @returns Latest cached occupancy data or undefined if no events received\n   * @throws An {@link Ably.ErrorInfo} with {@link ErrorCode.FeatureNotEnabledInRoom} if occupancy events are not enabled\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, OccupancyData } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Room with occupancy events enabled\n   * const room = await chatClient.rooms.get('gaming-lobby', {\n   *   occupancy: { enableEvents: true }\n   * });\n   *\n   * // Subscribe to occupancy events\n   * room.occupancy.subscribe((event) => {\n   *   console.log('Occupancy updated:', event.occupancy);\n   * });\n   *\n   * // Get cached occupancy instantly (after first event)\n   * function displayCurrentOccupancy() {\n   *   const occupancy = room.occupancy.current;\n   *\n   *   if (occupancy) {\n   *     console.log(`Current cached occupancy:`);\n   *     console.log(`Connections: ${occupancy.connections}`);\n   *     console.log(`Presence: ${occupancy.presenceMembers}`);\n   *   } else {\n   *     console.log('No occupancy data received yet, try fetching from server');\n   *   }\n   * }\n   *\n   * // Attach to the room to start receiving events\n   * await room.attach();\n   *\n   * ```\n   */\n  get current(): OccupancyData | undefined;\n}\n\n/**\n * A listener that is called when the occupancy of a chat room changes.\n * @param event The occupancy event.\n */\nexport type OccupancyListener = (event: OccupancyEvent) => void;\n\ninterface OccupancyEventsMap {\n  [OccupancyEventType.Updated]: OccupancyEvent;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultOccupancy implements Occupancy {\n  private readonly _roomName: string;\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _chatApi: ChatApi;\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<OccupancyEventsMap>();\n  private readonly _roomOptions: InternalRoomOptions;\n  private _latestOccupancyData?: OccupancyData;\n  private readonly _unsubscribeOccupancyEvents: () => void;\n\n  /**\n   * Constructs a new `DefaultOccupancy` instance.\n   * @param roomName The unique identifier of the room.\n   * @param channel An instance of the Realtime channel.\n   * @param chatApi An instance of the ChatApi.\n   * @param logger An instance of the Logger.\n   * @param roomOptions The room options.\n   */\n  constructor(\n    roomName: string,\n    channel: Ably.RealtimeChannel,\n    chatApi: ChatApi,\n    logger: Logger,\n    roomOptions: InternalRoomOptions,\n  ) {\n    this._roomName = roomName;\n    this._channel = channel;\n    this._chatApi = chatApi;\n    this._logger = logger;\n    this._roomOptions = roomOptions;\n\n    // Create bound listener\n    const occupancyEventsListener = this._internalOccupancyListener.bind(this);\n\n    // Use subscription helper to create cleanup function\n    if (this._roomOptions.occupancy.enableEvents) {\n      this._logger.debug('DefaultOccupancy(); subscribing to occupancy events');\n      this._unsubscribeOccupancyEvents = subscribe(\n        this._channel,\n        [RealtimeMetaEventType.Occupancy],\n        occupancyEventsListener,\n      );\n    } else {\n      this._unsubscribeOccupancyEvents = () => {\n        // No-op function when events are not enabled\n      };\n    }\n  }\n\n  /**\n   * @inheritdoc\n   */\n  subscribe(listener: OccupancyListener): Subscription {\n    this._logger.trace('Occupancy.subscribe();');\n\n    if (!this._roomOptions.occupancy.enableEvents) {\n      throw new Ably.ErrorInfo(\n        'unable to subscribe to occupancy; occupancy events are not enabled in room options',\n        ErrorCode.FeatureNotEnabledInRoom,\n        400,\n      ) as unknown as Error;\n    }\n\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      unsubscribe: () => {\n        this._logger.trace('Occupancy.unsubscribe();');\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async get(): Promise<OccupancyData> {\n    this._logger.trace('Occupancy.get();');\n    return this._chatApi.getOccupancy(this._roomName);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get current(): OccupancyData | undefined {\n    this._logger.trace('Occupancy.current();');\n\n    // CHA-O7c\n    if (!this._roomOptions.occupancy.enableEvents) {\n      throw new Ably.ErrorInfo(\n        'unable to get current occupancy; occupancy events are not enabled in room options',\n        ErrorCode.FeatureNotEnabledInRoom,\n        400,\n      ) as unknown as Error;\n    }\n\n    // CHA-07a\n    // CHA-07b\n    return this._latestOccupancyData;\n  }\n\n  /**\n   * An internal listener that listens for occupancy events from the underlying channel and translates them into\n   * occupancy events for the public API.\n   * @param message The inbound message containing occupancy data.\n   */\n  private _internalOccupancyListener(message: Ably.InboundMessage): void {\n    this._logger.trace('Occupancy._internalOccupancyListener();', message);\n\n    this._latestOccupancyData = parseOccupancyMessage(message);\n\n    this._emitter.emit(OccupancyEventType.Updated, {\n      type: OccupancyEventType.Updated,\n      occupancy: this._latestOccupancyData,\n    });\n  }\n\n  /**\n   * Merges the channel options for the room with the ones required for occupancy.\n   * @param roomOptions The internal room options.\n   * @returns A function that merges the channel options for the room with the ones required for occupancy.\n   */\n  static channelOptionMerger(roomOptions: InternalRoomOptions): ChannelOptionsMerger {\n    return (options) => {\n      // Occupancy not required, so we can skip this.\n      if (!roomOptions.occupancy.enableEvents) {\n        return options;\n      }\n\n      return { ...options, params: { ...options.params, occupancy: 'metrics' } };\n    };\n  }\n\n  /**\n   * Disposes of the occupancy instance, removing all listeners and subscriptions.\n   * This method should be called when the room is being released to ensure proper cleanup.\n   * @internal\n   */\n  dispose(): void {\n    this._logger.trace('DefaultOccupancy.dispose();');\n\n    // Remove occupancy event subscriptions using stored unsubscribe function\n    this._unsubscribeOccupancyEvents();\n\n    // Remove user-level listeners\n    this._emitter.off();\n\n    this._logger.debug('DefaultOccupancy.dispose(); disposed successfully');\n  }\n\n  /**\n   * Checks if there are any listeners registered by users.\n   * @internal\n   * @returns true if there are listeners, false otherwise.\n   */\n  hasListeners(): boolean {\n    return emitterHasListeners(this._emitter);\n  }\n}\n","import * as Ably from 'ably';\n\nimport { ChannelOptionsMerger } from './channel-manager.js';\nimport { ErrorCode } from './errors.js';\nimport { PresenceEventType } from './events.js';\nimport { JsonObject } from './json.js';\nimport { Logger } from './logger.js';\nimport { realtimeExtras } from './realtime-extensions.js';\nimport { on, subscribe } from './realtime-subscriptions.js';\nimport { InternalRoomOptions } from './room-options.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { emitterHasListeners, wrap } from './utils/event-emitter.js';\n\n/**\n * The state of presence in a room\n */\nexport interface PresenceState {\n  /**\n   * Whether the current user is present in the room\n   */\n  readonly present: boolean;\n}\n\n/**\n * A presence state change event\n */\nexport interface PresenceStateChange {\n  /**\n   * The presence state before this change\n   */\n  readonly previous: PresenceState;\n\n  /**\n   * The presence state after this change\n   */\n  readonly current: PresenceState;\n\n  /**\n   * Any error that occurred during this state change\n   * This will be set if there was an error fetching presence data or performing presence operations\n   */\n  readonly error?: Ably.ErrorInfo;\n}\n\n/**\n * Listener for presence state changes\n */\nexport type PresenceStateChangeListener = (change: PresenceStateChange) => void;\n\n/**\n * Interface for PresenceEventsMap\n */\ninterface PresenceEventsMap {\n  [PresenceEventType.Enter]: PresenceEvent;\n  [PresenceEventType.Leave]: PresenceEvent;\n  [PresenceEventType.Update]: PresenceEvent;\n  [PresenceEventType.Present]: PresenceEvent;\n}\n\n/**\n * Type for data that can be entered into presence as an object literal.\n * @example\n * ```ts\n * const foo: PresenceData = {\n *   bar: {\n *     baz: 1\n *   }\n * }\n * ```\n * @example\n * ```ts\n * // Defining a custom type for presence data. It must be a JSON serializable object.\n * interface MyPresenceData {\n *   [key: string]: JsonValue; // Type check for JSON compatibility.\n *   foo: string;\n *   bar: {\n *     baz: string;\n *   }\n *  }\n * ```\n */\nexport type PresenceData = JsonObject;\n\n/**\n * Type for PresenceEvent\n */\nexport interface PresenceEvent {\n  /**\n   * The type of the presence event.\n   */\n  type: PresenceEventType;\n\n  /**\n   * The presence member associated with this event.\n   */\n  member: PresenceMember;\n}\n\n/**\n * Type for PresenceMember.\n *\n * Presence members are unique based on their `connectionId` and `clientId`. It is possible for\n * multiple users to have the same `clientId` if they are connected to the room from different devices.\n */\nexport type PresenceMember = Omit<Ably.PresenceMessage, 'id' | 'action' | 'timestamp'> & {\n  /**\n   * The timestamp of when the last change in state occurred for this presence member.\n   */\n  updatedAt: Date;\n\n  /**\n   * The data associated with the presence member.\n   */\n  data: PresenceData | undefined;\n\n  /**\n   * The extras associated with the presence member.\n   */\n  extras: JsonObject | undefined;\n\n  /**\n   * The user claim attached to this presence event by the server. This is set automatically\n   * by the server when a JWT contains a matching `ably.room.<roomName>` claim.\n   */\n  userClaim?: string;\n};\n\n/**\n * Type for PresenceListener\n * @param event The presence event that was received.\n */\nexport type PresenceListener = (event: PresenceEvent) => void;\n\n/**\n * This interface is used to interact with presence in a chat room: subscribing to presence events,\n * fetching presence members, or sending presence events (join,update,leave).\n *\n * Get an instance via {@link Room.presence}.\n */\nexport interface Presence {\n  /**\n   * Retrieves the current members present in the chat room.\n   *\n   * **Note**: The room must be attached before calling this method.\n   * @param params - Optional parameters to filter the presence set\n   * @returns Promise that resolves with an array of presence members currently in the room,\n   *          or rejects with {@link ErrorCode.RoomInInvalidState} if the room is not attached\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options and attach to it\n   * const room = await chatClient.rooms.get('meeting-room');\n   * await room.attach();\n   *\n   * try {\n   *   // Get all currently present members\n   *   const members: PresenceMember[] = await room.presence.get();\n   *   console.log(`${members.length} users present in the room`);\n   *\n   *   members.forEach((member) => {\n   *     console.log(`User ${member.clientId} is present with data:`, member.data);\n   *   });\n   *\n   *   // Get members with a specific client ID\n   *   const specificUser = await room.presence.get({ clientId: 'user-456' });\n   *   if (specificUser.length > 0) {\n   *     console.log('User-456 is in the room');\n   *   }\n   * } catch (error) {\n   *   console.error('Failed to get presence members:', error);\n   * }\n   * ```\n   */\n  get(params?: Ably.RealtimePresenceParams): Promise<PresenceMember[]>;\n\n  /**\n   * Checks whether a specific user is currently present in the chat room.\n   * Useful if you just need a boolean check rather than the full presence member data.\n   *\n   * **Note**: The room must be attached before calling this method.\n   * @param clientId - The client ID of the user to check\n   * @returns Promise that resolves with true if the user is present, false otherwise, or rejects with:\n   * - {@link ErrorCode.RoomInInvalidState} if the room is not attached\n   * - {@link Ably.ErrorInfo} if the operation fails for any other reason\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options and attach to it\n   * const room = await chatClient.rooms.get('meeting-room');\n   * await room.attach();\n   *\n   * try {\n   *   // Check if a specific user is present\n   *   const isPresent: boolean = await room.presence.isUserPresent('user-456');\n   *\n   *   if (isPresent) {\n   *     console.log('User-456 is currently in the room');\n   *   } else {\n   *     console.log('User-456 is not in the room');\n   *   }\n   * } catch (error) {\n   *   console.error('Failed to check user presence:', error);\n   * }\n   * ```\n   */\n  isUserPresent(clientId: string): Promise<boolean>;\n\n  /**\n   * Enters the current user into the chat room presence set.\n   * Emits an 'enter' event to all presence subscribers. Multiple calls will emit additional `update` events if the\n   * user is already present.\n   *\n   * **Note**: The room must be attached before calling this method.\n   * @param data - Optional JSON-serializable data to associate with the user's presence\n   * @returns Promise that resolves when the user has successfully entered,\n   *          or rejects with {@link ErrorCode.RoomInInvalidState} if the room is not attached\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options and attach to it\n   * const room = await chatClient.rooms.get('meeting-room');\n   * await room.attach();\n   *\n   * try {\n   *   // Enter with user metadata\n   *   await room.presence.enter({\n   *     avatar: 'https://example.com/avatar.jpg',\n   *     status: 'online',\n   *     role: 'moderator'\n   *   });\n   *\n   *   console.log('Successfully entered the room');\n   * } catch (error) {\n   *   console.error('Failed to enter room:', error);\n   * }\n   *\n   * ```\n   */\n  enter(data?: PresenceData): Promise<void>;\n\n  /**\n   * Updates the presence data for the current user in the chat room.\n   * Emits an 'update' event to all subscribers. If the user is not already present, they will be entered automatically.\n   *\n   * **Note**:\n   * - The room must be attached before calling this method.\n   * - This method uses PUT-like semantics - the entire presence data is replaced with the new value.\n   * @param data - JSON-serializable data to replace the user's current presence data\n   * @returns Promise that resolves when the presence data has been updated,\n   *          or rejects with {@link ErrorCode.RoomInInvalidState} if the room is not attached\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options\n   * const room = await chatClient.rooms.get('meeting-room');\n   * await room.attach();\n   *\n   * try {\n   *   // Initial enter with status\n   *   await room.presence.enter({\n   *     username: 'John Doe',\n   *     status: 'online'\n   *   });\n   *\n   *   // Update status to busy (replaces entire data object)\n   *   await room.presence.update({\n   *     username: 'John Doe',\n   *     status: 'busy',\n   *     statusMessage: 'In a meeting'\n   *   });\n   *\n   *   console.log('Presence status updated');\n   * } catch (error) {\n   *   console.error('Failed to update presence:', error);\n   * }\n   * ```\n   */\n  update(data?: PresenceData): Promise<void>;\n\n  /**\n   * Removes the current user from the chat room presence set.\n   * Emits a 'leave' event to all subscribers. If the user is not present, this is a no-op.\n   *\n   * **Note**: The room must be attached before calling this method.\n   * @param data - Optional final presence data to include with the leave event\n   * @returns Promise that resolves when the user has left the presence set,\n   *          or rejects with {@link ErrorCode.RoomInInvalidState} if the room is not attached\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options\n   * const room = await chatClient.rooms.get('meeting-room');\n   * await room.attach();\n   *\n   * try {\n   *   // Enter the room\n   *   await room.presence.enter({\n   *     avatar: 'https://example.com/avatar.jpg',\n   *     status: 'online'\n   *   });\n   *\n   *   // Do some work in the room...\n   *\n   *   // Leave with a final status message\n   *   await room.presence.leave({\n   *     status: 'offline',\n   *     lastSeen: new Date().toISOString()\n   *   });\n   *\n   *   console.log('Successfully left the room');\n   * } catch (error) {\n   *   console.error('Failed to leave room:', error);\n   * }\n   * ```\n   */\n  leave(data?: PresenceData): Promise<void>;\n\n  /**\n   * Subscribes to all presence events in the chat room.\n   *\n   * **Note**:\n   * - Requires `enableEvents` to be true in the room's presence options.\n   * - The room must be attached to receive events in real-time.\n   * @param listener - Callback function invoked when any presence event occurs\n   * @returns Subscription object with an unsubscribe method\n   * @throws An {@link Ably.ErrorInfo} with {@link ErrorCode.FeatureNotEnabledInRoom} if presence events are not enabled\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, PresenceEvent, PresenceEventType } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options\n   * const room = await chatClient.rooms.get('meeting-room');\n   *\n   * // Subscribe to all presence events\n   * const subscription = room.presence.subscribe((event: PresenceEvent) => {\n   *   const { type, member } = event;\n   *   switch (type) {\n   *     case PresenceEventType.Enter:\n   *       console.log(`${member.clientId} entered at ${member.updatedAt}`);\n   *       break;\n   *     case PresenceEventType.Leave:\n   *       console.log(`${member.clientId} left at ${member.updatedAt}`);\n   *       break;\n   *     case PresenceEventType.Update:\n   *       console.log(`${member.clientId} updated their data:`, member.data);\n   *       break;\n   *     case PresenceEventType.Present:\n   *       console.log(`${member.clientId} is already present`);\n   *       break;\n   *   }\n   * });\n   *\n   * // Attach to the room to start receiving events\n   * await room.attach();\n   *\n   * // Later, unsubscribe when done\n   * subscription.unsubscribe();\n   * ```\n   */\n  subscribe(listener: PresenceListener): Subscription;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultPresence implements Presence {\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<PresenceEventsMap>();\n  private readonly _stateEmitter = new EventEmitter<{ 'presence.state.change': PresenceStateChange }>();\n  private readonly _options: InternalRoomOptions;\n  private _presenceState: PresenceState = {\n    present: false,\n  };\n  private readonly _unsubscribePresenceEvents: () => void;\n  private readonly _offChannelUpdate: () => void;\n  private readonly _offChannelDetach: () => void;\n\n  /**\n   * Constructs a new `DefaultPresence` instance.\n   * @param channel The Realtime channel instance.\n   * @param logger An instance of the Logger.\n   * @param options The room options.\n   */\n  constructor(channel: Ably.RealtimeChannel, logger: Logger, options: InternalRoomOptions) {\n    this._channel = channel;\n    this._logger = logger;\n    this._options = options;\n\n    // Create bound listener\n    const presenceEventsListener = this.subscribeToEvents.bind(this);\n\n    const channelUpdateListener = (stateChange: Ably.ChannelStateChange) => {\n      if (stateChange.reason?.code === 91004) {\n        // PresenceAutoReentryFailed\n        this._logger.debug('Presence auto-reentry failed', { reason: stateChange.reason });\n        this._emitPresenceStateChange(false, stateChange.reason);\n        return;\n      }\n\n      // Channel has been moved to detached, which means any members we have will be removed\n      if (stateChange.current === 'detached') {\n        this._emitPresenceStateChange(false);\n        return;\n      }\n    };\n\n    const channelDetachListener = (stateChange: Ably.ChannelStateChange) => {\n      this._emitPresenceStateChange(false, stateChange.reason);\n    };\n\n    this._offChannelUpdate = on(this._channel, 'update', channelUpdateListener);\n    this._offChannelDetach = on(this._channel, ['detached', 'failed'], channelDetachListener);\n\n    // Use subscription helper to create cleanup function\n    this._unsubscribePresenceEvents = subscribe(this._channel.presence, presenceEventsListener);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async get(params?: Ably.RealtimePresenceParams): Promise<PresenceMember[]> {\n    this._logger.trace('Presence.get()', { params });\n    this._assertChannelState();\n    const userOnPresence = await this._channel.presence.get(params);\n\n    // ably-js never emits the 'absent' event, so we can safely ignore it here.\n    return userOnPresence.map((user) => this._realtimeMemberToPresenceMember(user));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async isUserPresent(clientId: string): Promise<boolean> {\n    this._logger.trace(`Presence.isUserPresent()`, { clientId });\n    this._assertChannelState();\n    const presenceSet = await this._channel.presence.get({ clientId: clientId });\n    return presenceSet.length > 0;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async enter(data?: PresenceData): Promise<void> {\n    this._logger.trace(`Presence.enter()`, { data });\n    this._assertChannelState();\n    try {\n      await this._channel.presence.enter(data);\n      this._emitPresenceStateChange(true);\n    } catch (error) {\n      this._emitPresenceStateChange(false, error as Ably.ErrorInfo);\n      throw error;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async update(data?: PresenceData): Promise<void> {\n    this._logger.trace(`Presence.update()`, { data });\n    this._assertChannelState();\n    try {\n      await this._channel.presence.update(data);\n      this._emitPresenceStateChange(true);\n    } catch (error) {\n      this._emitPresenceStateChange(false, error as Ably.ErrorInfo);\n      throw error;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async leave(data?: PresenceData): Promise<void> {\n    this._logger.trace(`Presence.leave()`, { data });\n    this._assertChannelState();\n    try {\n      await this._channel.presence.leave(data);\n      this._emitPresenceStateChange(false);\n    } catch (error) {\n      this._emitPresenceStateChange(false, error as Ably.ErrorInfo);\n      throw error;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribe(listener: PresenceListener): Subscription {\n    this._logger.trace('Presence.subscribe()');\n\n    // Check if presence events are enabled\n    if (!this._options.presence.enableEvents) {\n      this._logger.error('unable to subscribe to presence; presence events are not enabled');\n      throw new Ably.ErrorInfo(\n        'unable to subscribe to presence; presence events are not enabled',\n        ErrorCode.FeatureNotEnabledInRoom,\n        400,\n      );\n    }\n\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n    return {\n      unsubscribe: () => {\n        this._logger.trace('Presence.unsubscribe();');\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * Method to handle and emit presence events\n   * @param member - PresenceMessage ably-js object\n   */\n  subscribeToEvents = (member: Ably.PresenceMessage) => {\n    this._emitter.emit(member.action as PresenceEventType, {\n      type: member.action as PresenceEventType,\n      member: this._realtimeMemberToPresenceMember(member),\n    });\n  };\n\n  /**\n   * Merges the channel options for the room with the ones required for presence.\n   * @param roomOptions The room options to merge for.\n   * @returns A function that merges the channel options for the room with the ones required for presence.\n   */\n  static channelOptionMerger(roomOptions: InternalRoomOptions): ChannelOptionsMerger {\n    return (options) => {\n      // Presence mode is always required\n      if (!options.modes.includes('PRESENCE')) {\n        options.modes.push('PRESENCE');\n      }\n      // If presence events are enabled, add the PRESENCE_SUBSCRIBE mode\n      if (roomOptions.presence.enableEvents && !options.modes.includes('PRESENCE_SUBSCRIBE')) {\n        options.modes.push('PRESENCE_SUBSCRIBE');\n      }\n      return options;\n    };\n  }\n\n  /**\n   * Disposes of the presence instance, removing all listeners and subscriptions.\n   * This method should be called when the room is being released to ensure proper cleanup.\n   * @internal\n   */\n  dispose(): void {\n    this._logger.trace('DefaultPresence.dispose();');\n\n    // Remove all user-level listeners from the emitter\n    this._emitter.off();\n\n    // Unsubscribe from presence events using stored unsubscribe function\n    this._unsubscribePresenceEvents();\n\n    // Remove the channel update listener\n    this._offChannelUpdate();\n\n    // Remove the channel detach listener\n    this._offChannelDetach();\n\n    this._logger.debug('DefaultPresence.dispose(); disposed successfully');\n  }\n\n  /**\n   * Checks if there are any listeners registered by users.\n   * @internal\n   * @returns true if there are listeners, false otherwise.\n   */\n  hasListeners(): boolean {\n    return emitterHasListeners(this._emitter);\n  }\n\n  /**\n   * Converts an Ably presence message to a presence member.\n   * @param member The Ably presence message to convert.\n   * @returns The presence member.\n   */\n  private _realtimeMemberToPresenceMember(member: Ably.PresenceMessage): PresenceMember {\n    const extras = realtimeExtras(member.extras);\n    return {\n      // Note that we're casting `extras` from ably-js's `any` to our `JsonObject | undefined`; although ably-js's types don't express it we can assume this type per https://sdk.ably.com/builds/ably/specification/main/features/#TP3i.\n      ...member,\n      data: member.data as PresenceData,\n      updatedAt: new Date(member.timestamp),\n      userClaim: extras.userClaim,\n    };\n  }\n\n  private _assertChannelState(): void {\n    if (this._channel.state !== 'attaching' && this._channel.state !== 'attached') {\n      this._logger.error('unable to perform presence operation; room is not attached');\n      throw new Ably.ErrorInfo(\n        'unable to perform presence operation; room is not attached',\n        ErrorCode.RoomInInvalidState,\n        400,\n      );\n    }\n  }\n\n  /**\n   * Private method to emit the presence state change event.\n   * @param present - Whether the user is present\n   * @param error - Optional error information\n   */\n  private _emitPresenceStateChange(present: boolean, error?: Ably.ErrorInfo): void {\n    this._logger.trace('Presence._emitPresenceStateChange()', { present, error });\n    const previous: PresenceState = { ...this._presenceState };\n    this._presenceState = { present };\n    const stateChange: PresenceStateChange = {\n      previous,\n      current: this._presenceState,\n      error,\n    };\n    this._stateEmitter.emit('presence.state.change', stateChange);\n  }\n\n  /**\n   * @param listener The listener to subscribe to presence state changes.\n   * @returns A subscription that can be used to unsubscribe from presence state changes.\n   * @internal\n   */\n  onPresenceStateChange(listener: PresenceStateChangeListener): Subscription {\n    this._logger.trace('Presence.onPresenceStateChange()');\n    const wrapped = wrap(listener);\n    this._stateEmitter.on('presence.state.change', wrapped);\n    return {\n      unsubscribe: () => {\n        this._logger.trace('Presence.unsubscribeFromPresenceStateChanges()');\n        this._stateEmitter.off(wrapped);\n      },\n    };\n  }\n}\n","const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            const task = { resolve, reject, weight, priority };\n            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);\n            if (i === -1 && weight <= this._value) {\n                // Needs immediate dispatch, skip the queue\n                this._dispatchItem(task);\n            }\n            else {\n                this._queue.splice(i + 1, 0, task);\n            }\n        });\n    }\n    runExclusive(callback_1) {\n        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {\n            const [value, release] = yield this.acquire(weight, priority);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        if (this._couldLockImmediately(weight, priority)) {\n            return Promise.resolve();\n        }\n        else {\n            return new Promise((resolve) => {\n                if (!this._weightedWaiters[weight - 1])\n                    this._weightedWaiters[weight - 1] = [];\n                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });\n            });\n        }\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatchQueue();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatchQueue();\n    }\n    cancel() {\n        this._queue.forEach((entry) => entry.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatchQueue() {\n        this._drainUnlockWaiters();\n        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {\n            this._dispatchItem(this._queue.shift());\n            this._drainUnlockWaiters();\n        }\n    }\n    _dispatchItem(item) {\n        const previousValue = this._value;\n        this._value -= item.weight;\n        item.resolve([previousValue, this._newReleaser(item.weight)]);\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        if (this._queue.length === 0) {\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                waiters.forEach((waiter) => waiter.resolve());\n                this._weightedWaiters[weight - 1] = [];\n            }\n        }\n        else {\n            const queuedPriority = this._queue[0].priority;\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);\n                (i === -1 ? waiters : waiters.splice(0, i))\n                    .forEach((waiter => waiter.resolve()));\n            }\n        }\n    }\n    _couldLockImmediately(weight, priority) {\n        return (this._queue.length === 0 || this._queue[0].priority < priority) &&\n            weight <= this._value;\n    }\n}\nfunction insertSorted(a, v) {\n    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);\n    a.splice(i + 1, 0, v);\n}\nfunction findIndexFromEnd(a, predicate) {\n    for (let i = a.length - 1; i >= 0; i--) {\n        if (predicate(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {\n            const [, releaser] = yield this._semaphore.acquire(1, priority);\n            return releaser;\n        });\n    }\n    runExclusive(callback, priority = 0) {\n        return this._semaphore.runExclusive(() => callback(), 1, priority);\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock(priority = 0) {\n        return this._semaphore.waitForUnlock(1, priority);\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield (isSemaphore(sync)\n                        ? sync.acquire(weight, priority)\n                        : sync.acquire(priority));\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight, priority) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight, priority);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                (isSemaphore(sync)\n                    ? sync.waitForUnlock(weight, priority)\n                    : sync.waitForUnlock(priority)).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\nfunction isSemaphore(sync) {\n    return sync.getValue !== undefined;\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","import * as Ably from 'ably';\n\nimport { Logger } from './logger.js';\nimport { StatusSubscription } from './subscription.js';\nimport EventEmitter, { emitterHasListeners, wrap } from './utils/event-emitter.js';\n\n/**\n * The different states that a room can be in throughout its lifecycle.\n */\nexport enum RoomStatus {\n  /**\n   * The library is currently initializing the room. This state is a temporary state used in React prior\n   * to the room being resolved.\n   */\n  Initializing = 'initializing',\n\n  /**\n   * A temporary state for when the room object is first initialized.\n   */\n  Initialized = 'initialized',\n\n  /**\n   * The library is currently attempting to attach the room.\n   */\n  Attaching = 'attaching',\n\n  /**\n   * The room is currently attached and receiving events.\n   */\n  Attached = 'attached',\n\n  /**\n   * The room is currently detaching and will not receive events.\n   */\n  Detaching = 'detaching',\n\n  /**\n   * The room is currently detached and will not receive events.\n   */\n  Detached = 'detached',\n\n  /**\n   * The room is in an extended state of detachment, but will attempt to re-attach when able.\n   */\n  Suspended = 'suspended',\n\n  /**\n   * The room is currently detached and will not attempt to re-attach. User intervention is required.\n   */\n  Failed = 'failed',\n\n  /**\n   * The room is in the process of releasing. Attempting to use a room in this state may result in undefined behavior.\n   */\n  Releasing = 'releasing',\n\n  /**\n   * The room has been released and is no longer usable.\n   */\n  Released = 'released',\n}\n\n/**\n * Represents a change in the status of the room.\n */\nexport interface RoomStatusChange {\n  /**\n   * The new status of the room.\n   */\n  current: RoomStatus;\n\n  /**\n   * The previous status of the room.\n   */\n  previous: RoomStatus;\n\n  /**\n   * An error that provides a reason why the room has\n   * entered the new status, if applicable.\n   */\n  error?: Ably.ErrorInfo;\n}\n\n/**\n * A function that can be called when the room status changes.\n * @param change The change in status.\n */\nexport type RoomStatusListener = (change: RoomStatusChange) => void;\n\n/**\n * Represents the status of a Room.\n */\nexport interface RoomLifecycle {\n  /**\n   * The current status of the room.\n   */\n  get status(): RoomStatus;\n\n  /**\n   * The current error, if any, that caused the room to enter the current status.\n   */\n  get error(): Ably.ErrorInfo | undefined;\n\n  /**\n   * Registers a listener that will be called whenever the room status changes.\n   * @param listener The function to call when the status changes.\n   * @returns An object that can be used to unregister the listener.\n   */\n  onChange(listener: RoomStatusListener): StatusSubscription;\n}\n\n/**\n * An internal interface for the status of a room, which can be used to separate critical\n * internal functionality from user listeners.\n * @internal\n */\nexport interface InternalRoomLifecycle extends RoomLifecycle {\n  /**\n   * Sets the status of the room.\n   * @param params The new status of the room.\n   */\n  setStatus(params: NewRoomStatus): void;\n}\n\n/**\n * A new room status that can be set.\n */\nexport interface NewRoomStatus {\n  /**\n   * The new status of the room.\n   */\n  status: RoomStatus;\n\n  /**\n   * An error that provides a reason why the room has\n   * entered the new status, if applicable.\n   */\n  error?: Ably.ErrorInfo;\n}\n\ntype RoomStatusEventsMap = Record<RoomStatus, RoomStatusChange>;\n\n/**\n * An implementation of the `Status` interface.\n * @internal\n */\nexport class DefaultRoomLifecycle implements InternalRoomLifecycle {\n  private _status: RoomStatus = RoomStatus.Initialized;\n  private _error?: Ably.ErrorInfo;\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<RoomStatusEventsMap>();\n\n  /**\n   * Constructs a new DefaultRoomLifecycle instance.\n   * @param logger An instance of the Logger.\n   */\n  constructor(logger: Logger) {\n    this._logger = logger;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get status(): RoomStatus {\n    return this._status;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get error(): Ably.ErrorInfo | undefined {\n    return this._error;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  onChange(listener: RoomStatusListener): StatusSubscription {\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      off: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  setStatus(params: NewRoomStatus): void {\n    const change: RoomStatusChange = {\n      current: params.status,\n      error: params.error,\n      previous: this._status,\n    };\n\n    this._status = change.current;\n    this._error = change.error;\n    this._logger.info(`room status changed`, { ...change });\n    this._emitter.emit(change.current, change);\n  }\n\n  /**\n   * Disposes of the room lifecycle instance, removing all listeners.\n   * This method should be called when the room is being released to ensure proper cleanup.\n   * @internal\n   */\n  dispose(): void {\n    this._logger.trace('DefaultRoomLifecycle.dispose();');\n\n    // Remove all user-level listeners\n    this._emitter.off();\n\n    this._logger.debug('DefaultRoomLifecycle.dispose(); disposed successfully');\n  }\n\n  /**\n   * Checks if there are any listeners registered by users.\n   * @internal\n   * @returns true if there are listeners, false otherwise.\n   */\n  hasListeners(): boolean {\n    return emitterHasListeners(this._emitter);\n  }\n}\n","import * as Ably from 'ably';\nimport { Mutex } from 'async-mutex';\n\nimport { ChannelManager } from './channel-manager.js';\nimport { DiscontinuityListener } from './discontinuity.js';\nimport { ErrorCode } from './errors.js';\nimport { RoomEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { on } from './realtime-subscriptions.js';\nimport { InternalRoomLifecycle, RoomStatus } from './room-status.js';\nimport { StatusSubscription } from './subscription.js';\nimport EventEmitter, { emitterHasListeners, wrap } from './utils/event-emitter.js';\n\n/**\n * Events that can be emitted by the RoomLifecycleManager\n */\nexport interface RoomLifeCycleEvents {\n  [RoomEventType.Discontinuity]: Ably.ErrorInfo;\n}\n\n/**\n * Priority levels for operations, lower numbers are higher priority\n */\nenum OperationPriority {\n  Release = 0,\n  AttachDetach = 1,\n}\n\n/**\n * Manages the lifecycle of a room's underlying channel, handling attach, detach and release operations\n * while maintaining the room's status.\n */\nexport class RoomLifecycleManager {\n  private readonly _channelManager: ChannelManager;\n  private readonly _roomLifecycle: InternalRoomLifecycle;\n  private readonly _logger: Logger;\n  private readonly _eventEmitter: EventEmitter<RoomLifeCycleEvents>;\n  private _hasAttachedOnce: boolean; // CHA-RL13\n  private _isExplicitlyDetached: boolean; // CHA-RL14\n  private readonly _mutex: Mutex; // CHA-RL7\n  private readonly _unsubscribeChannelStateListener: () => void;\n  private readonly _offDiscontinuityAttached: () => void;\n  private readonly _offDiscontinuityUpdate: () => void;\n\n  constructor(channelManager: ChannelManager, roomLifecycle: InternalRoomLifecycle, logger: Logger) {\n    this._channelManager = channelManager;\n    this._roomLifecycle = roomLifecycle;\n    this._logger = logger;\n    this._eventEmitter = new EventEmitter();\n    this._hasAttachedOnce = false; // CHA-RL13\n    this._isExplicitlyDetached = false; // CHA-RL14\n    this._mutex = new Mutex(); // CHA-RL7\n\n    // Create bound listeners\n    const channelStateListener = this._channelStateListener.bind(this);\n    const discontinuityOnAttachedListener = this._discontinuityOnAttachedListener.bind(this);\n    const discontinuityOnUpdateListener = this._discontinuityOnUpdateListener.bind(this);\n\n    // Use subscription helpers to create cleanup functions\n    const channel = this._channelManager.get();\n    this._unsubscribeChannelStateListener = on(channel, channelStateListener);\n    this._offDiscontinuityAttached = on(channel, 'attached', discontinuityOnAttachedListener);\n    this._offDiscontinuityUpdate = on(channel, 'update', discontinuityOnUpdateListener);\n  }\n\n  /**\n   * Registers a handler for discontinuity events.\n   * @param handler The function to be called when a discontinuity is detected\n   * @returns An object with an off() method to deregister the handler\n   */\n  onDiscontinuity(handler: DiscontinuityListener): StatusSubscription {\n    this._logger.trace('RoomLifecycleManager.onDiscontinuity()');\n    const wrapped = wrap(handler);\n    this._eventEmitter.on(RoomEventType.Discontinuity, wrapped);\n    return {\n      off: () => {\n        this._eventEmitter.off(RoomEventType.Discontinuity, wrapped);\n      },\n    };\n  }\n\n  /**\n   * Attaches to the channel and updates room status accordingly.\n   * If the room is released/releasing, this operation fails.\n   * If already attached, this is a no-op.\n   */\n  async attach(): Promise<void> {\n    // CHA-RL1d, CHA-RL7a\n    await this._mutex.runExclusive(async () => {\n      this._logger.trace('RoomLifecycleManager.attach();');\n\n      // CHA-RL1b, CHA-RL1c\n      this._checkRoomNotReleasing('attach');\n\n      // CHA-RL1a\n      if (this._roomStatusIs(RoomStatus.Attached)) {\n        this._logger.debug('RoomLifecycleManager.attach(); room already attached, no-op');\n        return;\n      }\n\n      const channel = this._channelManager.get();\n      this._logger.debug('RoomLifecycleManager.attach(); attaching room', {\n        channelState: channel.state,\n      });\n\n      try {\n        // CHA-RL1e\n        this._setStatus(RoomStatus.Attaching);\n        // CHA-RL1k\n        await channel.attach();\n        this._setStatus(RoomStatus.Attached);\n        this._isExplicitlyDetached = false;\n        this._hasAttachedOnce = true;\n        this._logger.debug('RoomLifecycleManager.attach(); room attached successfully');\n      } catch (error) {\n        const errInfo = error as Ably.ErrorInfo;\n        const attachError = new Ably.ErrorInfo(\n          `failed to attach room: ${errInfo.message}`,\n          errInfo.code,\n          errInfo.statusCode,\n          errInfo,\n        );\n\n        const newStatus = this._mapChannelStateToRoomStatus(channel.state);\n        this._setStatus(newStatus, attachError);\n        throw attachError;\n      }\n    }, OperationPriority.AttachDetach);\n  }\n\n  /**\n   * Detaches from the channel and updates room status accordingly.\n   * If the room is released/releasing, this operation fails.\n   * If already detached, this is a no-op.\n   */\n  async detach(): Promise<void> {\n    // CHA-RL2i, CHA-RL7a\n    await this._mutex.runExclusive(async () => {\n      this._logger.trace('RoomLifecycleManager.detach();');\n\n      // CHA-RL2d\n      if (this._roomStatusIs(RoomStatus.Failed)) {\n        throw new Ably.ErrorInfo('unable to detach room; room is in failed state', ErrorCode.RoomInInvalidState, 400);\n      }\n\n      // CHA-RL2b, CHA-RL2c\n      this._checkRoomNotReleasing('detach');\n\n      // CHA-RL2a\n      if (this._roomStatusIs(RoomStatus.Detached)) {\n        this._logger.debug('RoomLifecycleManager.detach(); room already detached, no-op');\n        return;\n      }\n\n      const channel = this._channelManager.get();\n      this._logger.debug('RoomLifecycleManager.detach(); detaching room', {\n        channelState: channel.state,\n      });\n\n      try {\n        // CHA-RL2j\n        this._setStatus(RoomStatus.Detaching);\n        // CHA-RL2k\n        await channel.detach();\n        this._isExplicitlyDetached = true;\n        this._setStatus(RoomStatus.Detached);\n        this._logger.debug('RoomLifecycleManager.detach(); room detached successfully');\n      } catch (error) {\n        const errInfo = error as Ably.ErrorInfo;\n        const detachError = new Ably.ErrorInfo(\n          `failed to detach room: ${errInfo.message}`,\n          errInfo.code,\n          errInfo.statusCode,\n          errInfo,\n        );\n\n        const newStatus = this._mapChannelStateToRoomStatus(channel.state);\n        this._setStatus(newStatus, detachError);\n        throw detachError;\n      }\n    }, OperationPriority.AttachDetach);\n  }\n\n  /**\n   * Releases the room by detaching the channel and releasing it from the channel manager.\n   * If the channel is in a failed state, skips the detach operation.\n   * Will retry detach until successful unless in failed state.\n   */\n  async release(): Promise<void> {\n    // CHA-RL3k, CHA-RL7a\n    await this._mutex.runExclusive(async () => {\n      this._logger.trace('RoomLifecycleManager.release();');\n\n      // CHA-RL3a\n      if (this._roomStatusIs(RoomStatus.Released)) {\n        this._logger.debug('RoomLifecycleManager.release(); room already released, no-op');\n        return;\n      }\n\n      // CHA-RL3b, CHA-RL3j\n      if (this._roomStatusIs(RoomStatus.Initialized) || this._roomStatusIs(RoomStatus.Detached)) {\n        this._logger.debug('RoomLifecycleManager.release(); room is initialized or detached, releasing immediately', {\n          status: this._roomLifecycle.status,\n        });\n        this._releaseChannel();\n        return;\n      }\n\n      // CHA-RL3m\n      this._setStatus(RoomStatus.Releasing);\n      const channel = this._channelManager.get();\n\n      // CHA-RL3n\n      this._logger.debug('RoomLifecycleManager.release(); attempting channel detach before release', {\n        channelState: channel.state,\n      });\n      await this._channelDetachLoop(channel);\n\n      // CHA-RL3o, CHA-RL3h\n      this._releaseChannel();\n    }, OperationPriority.Release);\n  }\n\n  /**\n   * Maps an Ably channel state to a room status\n   * @param channelState The Ably channel state to map.\n   * @returns The corresponding room status.\n   */\n  private _mapChannelStateToRoomStatus(channelState: Ably.ChannelState): RoomStatus {\n    switch (channelState) {\n      case 'initialized': {\n        return RoomStatus.Initialized;\n      }\n      case 'attaching': {\n        return RoomStatus.Attaching;\n      }\n      case 'attached': {\n        return RoomStatus.Attached;\n      }\n      case 'detaching': {\n        return RoomStatus.Detaching;\n      }\n      case 'detached': {\n        return RoomStatus.Detached;\n      }\n      case 'suspended': {\n        return RoomStatus.Suspended;\n      }\n      case 'failed': {\n        return RoomStatus.Failed;\n      }\n      default: {\n        this._logger.error('RoomLifecycleManager._mapChannelStateToRoomStatus(); unknown channel state', {\n          channelState,\n        });\n        return RoomStatus.Failed;\n      }\n    }\n  }\n\n  private _checkRoomNotReleasing(op: string) {\n    switch (this._roomLifecycle.status) {\n      case RoomStatus.Released: {\n        throw new Ably.ErrorInfo(`unable to ${op} room; room is released`, ErrorCode.RoomInInvalidState, 400);\n      }\n      case RoomStatus.Releasing: {\n        throw new Ably.ErrorInfo(\n          `unable to ${op} room; room is currently releasing`,\n          ErrorCode.RoomInInvalidState,\n          400,\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns the current room status\n   * @param status The room status to check against.\n   * @returns true if the room status matches, false otherwise.\n   */\n  private _roomStatusIs(status: RoomStatus): boolean {\n    return this._roomLifecycle.status === status;\n  }\n\n  /**\n   * Disposes of the room lifecycle manager, removing all listeners and subscriptions.\n   * This method should be called when the room is being released to ensure proper cleanup.\n   * @internal\n   */\n  dispose(): void {\n    // Clean up channel listeners using stored unsubscribe functions\n    this._unsubscribeChannelStateListener();\n    this._offDiscontinuityAttached();\n    this._offDiscontinuityUpdate();\n\n    // Clean up user-level listeners\n    this._eventEmitter.off();\n  }\n\n  /**\n   * Checks if there are any listeners registered by users.\n   * @internal\n   * @returns true if there are listeners, false otherwise.\n   */\n  hasListeners(): boolean {\n    return emitterHasListeners(this._eventEmitter);\n  }\n\n  private _channelStateListener(stateChange: Ably.ChannelStateChange): void {\n    this._logger.debug('RoomLifecycleManager.channel state changed', {\n      oldState: stateChange.previous,\n      newState: stateChange.current,\n      reason: stateChange.reason,\n      resumed: stateChange.resumed,\n    });\n\n    // CHA-RL11b\n    if (this._operationInProgress()) {\n      this._logger.debug(\n        'RoomLifecycleManager._startMonitoringChannelState(); ignoring channel state change - operation in progress',\n        {\n          status: this._roomLifecycle.status,\n        },\n      );\n      return;\n    }\n\n    // CHA-RL11c\n    const newStatus = this._mapChannelStateToRoomStatus(stateChange.current);\n    this._setStatus(newStatus, stateChange.reason);\n  }\n\n  private _discontinuityOnAttachedListener(stateChange: Ably.ChannelStateChange): void {\n    if (!stateChange.resumed && this._hasAttachedOnce && !this._isExplicitlyDetached) {\n      const error = new Ably.ErrorInfo(\n        'discontinuity detected',\n        ErrorCode.RoomDiscontinuity,\n        stateChange.reason?.statusCode ?? 0,\n        stateChange.reason,\n      );\n\n      this._logger.warn('RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected', {\n        error,\n      });\n      this._eventEmitter.emit(RoomEventType.Discontinuity, error);\n    }\n  }\n\n  private _discontinuityOnUpdateListener(stateChange: Ably.ChannelStateChange): void {\n    if (\n      !stateChange.resumed &&\n      this._hasAttachedOnce &&\n      !this._isExplicitlyDetached &&\n      stateChange.current === 'attached' &&\n      stateChange.previous === 'attached'\n    ) {\n      const error = new Ably.ErrorInfo(\n        'discontinuity detected',\n        ErrorCode.RoomDiscontinuity,\n        stateChange.reason?.statusCode ?? 0,\n        stateChange.reason,\n      );\n\n      this._logger.warn('RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected', {\n        error,\n      });\n      this._eventEmitter.emit(RoomEventType.Discontinuity, error);\n    }\n  }\n\n  private async _channelDetachLoop(channel: Ably.RealtimeChannel) {\n    for (;;) {\n      // If channel is now failed, we can stop trying to detach\n      const currentState: Ably.ChannelState = channel.state;\n      if (currentState === 'failed') {\n        this._logger.debug('RoomLifecycleManager._channelDetachLoop(); channel is failed, skipping detach');\n        break;\n      }\n\n      try {\n        await channel.detach();\n        break;\n      } catch (error) {\n        // keep trying\n        this._logger.error('RoomLifecycleManager._channelDetachLoop(); failed to detach channel during release', {\n          error,\n        });\n        await new Promise((resolve) => setTimeout(resolve, 250)); // Wait 250ms before retry\n      }\n    }\n  }\n\n  private _setStatus(status: RoomStatus, error?: Ably.ErrorInfo) {\n    this._logger.debug('RoomLifecycleManager._setStatus(); updating room status', {\n      oldStatus: this._roomLifecycle.status,\n      newStatus: status,\n      hasError: !!error,\n    });\n    this._roomLifecycle.setStatus({ status, error });\n  }\n\n  private _releaseChannel() {\n    this._channelManager.release();\n    this._setStatus(RoomStatus.Released);\n    this._logger.debug('RoomLifecycleManager._releaseChannel(); room released successfully');\n  }\n\n  /**\n   * Returns whether there is currently an operation (attach/detach/release) in progress\n   * @returns True if an operation is in progress, false otherwise.\n   */\n  private _operationInProgress(): boolean {\n    return this._mutex.isLocked();\n  }\n\n  testForceHasAttachedOnce(firstAttach: boolean) {\n    this._logger.trace('RoomLifecycleManager.testForceHasAttachedOnce();', { firstAttach });\n    this._hasAttachedOnce = firstAttach;\n  }\n}\n","import * as Ably from 'ably';\n\nimport { ErrorCode } from './errors.js';\nimport { MessageReactionType } from './events.js';\n\n/**\n * The default values for RoomOptions.\n */\nconst DefaultRoomOptions: Omit<InternalRoomOptions, 'isReactClient'> = {\n  /**\n   * The default typing options for a chat room.\n   */\n  typing: {\n    /**\n     * The default time that a client will wait between sending one typing heartbeat and the next.\n     *\n     * Spec: CHA-T10.\n     */\n    heartbeatThrottleMs: 10000,\n  },\n\n  /**\n   * The default occupancy options for a chat room.\n   */\n  occupancy: {\n    /**\n     * Whether to enable occupancy events.\n     */\n    enableEvents: false,\n  },\n\n  /**\n   * The default presence options for the room.\n   */\n  presence: {\n    enableEvents: true,\n  },\n\n  /**\n   * The default options for messages.\n   */\n  messages: {\n    rawMessageReactions: false,\n    defaultMessageReactionType: MessageReactionType.Distinct,\n  },\n};\n\n/**\n * Represents the message options for a chat room.\n */\nexport interface MessagesOptions {\n  /**\n   * Whether to enable receiving raw individual message reactions from the\n   * realtime channel. Set to true if subscribing to raw message reactions.\n   *\n   * Note reaction summaries (aggregates) are always available regardless of\n   * this setting.\n   * @defaultValue false\n   */\n  rawMessageReactions?: boolean;\n\n  /**\n   * The default message reaction type to use for sending message reactions.\n   *\n   * Any message reaction type can be sent regardless of this setting by specifying the `type` parameter\n   * in the {@link MessageReactions.send} method.\n   * @defaultValue {@link MessageReactionType.Distinct}\n   */\n  defaultMessageReactionType?: MessageReactionType;\n}\n\n/**\n * Represents the typing options for a chat room.\n */\nexport interface TypingOptions {\n  /**\n   * A throttle, in milliseconds, that enforces the minimum time interval between consecutive `typing.started`\n   * events sent by the client to the server.\n   * If typing.start() is called, the first call will emit an event immediately.\n   * Later calls will no-op until the time has elapsed.\n   * Calling typing.stop() will immediately send a `typing.stopped` event to the server and reset the interval,\n   * allowing the client to send another `typing.started` event immediately.\n   * @defaultValue 10000\n   */\n  heartbeatThrottleMs?: number;\n}\n\n/**\n * Represents the occupancy options for a chat room.\n */\nexport interface OccupancyOptions {\n  /**\n   * Whether to enable occupancy events.\n   *\n   * Note that enabling this feature will increase the number of messages received by the client as additional\n   * messages will be sent by the server to indicate occupancy changes.\n   * @defaultValue false\n   */\n  enableEvents?: boolean;\n}\n\n/**\n * Represents the presence options for a chat room.\n */\nexport interface PresenceOptions {\n  /**\n   * Whether or not the client should receive presence events from the server. This setting\n   * can be disabled if you are using presence in your Chat Room, but this particular client does not\n   * need to receive the messages.\n   * @defaultValue true\n   */\n  enableEvents?: boolean;\n}\n\n/**\n * Represents the options for a given chat room.\n */\nexport interface RoomOptions {\n  /**\n   * The typing options for the room.\n   */\n  typing?: TypingOptions;\n\n  /**\n   * The occupancy options for the room.\n   */\n  occupancy?: OccupancyOptions;\n\n  /**\n   * The presence options for the room.\n   */\n  presence?: PresenceOptions;\n\n  /**\n   * The message options for the room.\n   */\n  messages?: MessagesOptions;\n}\n\n/**\n * Represents the normalized typing options for a chat room, which makes every property required.\n */\nexport type InternalTypingOptions = Required<TypingOptions>;\n\n/**\n * Represents the normalized occupancy options for a chat room. Everything becomes required.\n */\nexport type InternalOccupancyOptions = Required<OccupancyOptions>;\n\n/**\n * Represents the normalized presence options for a chat room. Everything becomes required.\n */\nexport type InternalPresenceOptions = Required<PresenceOptions>;\n\n/**\n * Represents the normalized message options for a chat room. Everything becomes required.\n */\nexport type InternalMessagesOptions = Required<MessagesOptions>;\n\n/**\n * Represents the normalized options for a chat room.\n */\nexport interface InternalRoomOptions {\n  /**\n   * Are we running the client in a React environment?\n   */\n  isReactClient: boolean;\n\n  /**\n   * Typing options with everything made mandatory.\n   */\n  typing: InternalTypingOptions;\n\n  /**\n   * Occupancy options with everything made mandatory.\n   */\n  occupancy: InternalOccupancyOptions;\n\n  /**\n   * Presence options with everything made mandatory.\n   */\n  presence: InternalPresenceOptions;\n\n  /**\n   * Message options with everything made mandatory.\n   */\n  messages: InternalMessagesOptions;\n}\n\n/**\n * Creates an {@link ErrorInfo} for invalid room configuration.\n * @param reason The reason for the invalid room configuration.\n * @returns An ErrorInfo.\n */\nconst invalidRoomConfiguration = (reason: string): Error =>\n  new Ably.ErrorInfo(`unable to create room; invalid room configuration: ${reason}`, ErrorCode.InvalidArgument, 400);\n\nexport const validateRoomOptions = (options: InternalRoomOptions): void => {\n  validateTypingOptions(options.typing);\n};\n\nconst validateTypingOptions = (options: InternalTypingOptions): void => {\n  if (options.heartbeatThrottleMs <= 0) {\n    throw invalidRoomConfiguration('typing heartbeat interval must be greater than 0');\n  }\n};\n\nconst normalizeTypingOptions = (options: RoomOptions | undefined): InternalTypingOptions => ({\n  ...DefaultRoomOptions.typing,\n  ...options?.typing,\n});\n\nconst normalizeOccupancyOptions = (options: RoomOptions | undefined): InternalOccupancyOptions => ({\n  ...DefaultRoomOptions.occupancy,\n  ...options?.occupancy,\n});\n\nconst normalizePresenceOptions = (options: RoomOptions | undefined): InternalPresenceOptions => ({\n  ...DefaultRoomOptions.presence,\n  ...options?.presence,\n});\n\nconst normalizeMessagesOptions = (options: RoomOptions | undefined): InternalMessagesOptions => ({\n  ...DefaultRoomOptions.messages,\n  ...options?.messages,\n});\n\nexport const normalizeRoomOptions = (options: RoomOptions | undefined, react: boolean): InternalRoomOptions => ({\n  typing: normalizeTypingOptions(options),\n  occupancy: normalizeOccupancyOptions(options),\n  presence: normalizePresenceOptions(options),\n  messages: normalizeMessagesOptions(options),\n  isReactClient: react,\n});\n","import * as Ably from 'ably';\n\n/**\n * Convenience function that takes an event name and optional data and turns it into a\n * message that the server will recognize as ephemeral.\n * @param name The name of the event.\n * @param data Optional data to send with the event.\n * @returns An Ably message.\n */\nexport const ephemeralMessage = (name: string, data?: unknown): Ably.Message => ({\n  name: name,\n  data: data,\n  extras: {\n    ephemeral: true,\n  },\n});\n\n/**\n * Takes an existing Ably message and converts it to an ephemeral message by adding\n * the ephemeral flag in the extras field.\n * @param message The Ably message to convert.\n * @returns A new Ably message with the ephemeral flag set.\n */\nexport const messageToEphemeral = (message: Ably.Message): Ably.Message => {\n  const extras = message.extras ? (message.extras as object) : {};\n\n  return {\n    ...message,\n    extras: {\n      ...extras,\n      ephemeral: true,\n    },\n  };\n};\n","import { Headers } from './headers.js';\nimport { Metadata } from './metadata.js';\n\n/**\n * {@link Headers} type for chat messages.\n */\nexport type RoomReactionHeaders = Headers;\n\n/**\n * {@link Metadata} type for chat messages.\n */\nexport type RoomReactionMetadata = Metadata;\n\n/**\n * Represents a room-level reaction.\n */\nexport interface RoomReaction {\n  /**\n   * The name of the reaction, for example \"like\" or \"love\".\n   */\n  readonly name: string;\n\n  /**\n   * Metadata of the reaction. If no metadata was set this is an empty object.\n   */\n  readonly metadata: RoomReactionMetadata;\n\n  /**\n   * Headers of the reaction. If no headers were set this is an empty object.\n   */\n  readonly headers: RoomReactionHeaders;\n\n  /**\n   * The timestamp at which the reaction was sent.\n   */\n  readonly createdAt: Date;\n\n  /**\n   * The clientId of the user who sent the reaction.\n   */\n  readonly clientId: string;\n\n  /**\n   * Whether the reaction was sent by the current user.\n   */\n  readonly isSelf: boolean;\n\n  /**\n   * The user claim attached to this reaction by the server. This is set automatically\n   * by the Ably server when a JWT contains a matching `ably.room.<roomName>` claim.\n   */\n  readonly userClaim?: string;\n}\n\n/**\n * An implementation of the RoomReaction interface for room-level reactions.\n */\nexport class DefaultRoomReaction implements RoomReaction {\n  constructor(\n    public readonly name: string,\n    public readonly clientId: string,\n    public readonly createdAt: Date,\n    public readonly isSelf: boolean,\n    public readonly metadata: RoomReactionMetadata,\n    public readonly headers: RoomReactionHeaders,\n    public readonly userClaim?: string,\n  ) {\n    // The object is frozen after constructing to enforce readonly at runtime too\n    Object.freeze(this);\n  }\n}\n","import * as Ably from 'ably';\n\nimport { realtimeExtras } from './realtime-extensions.js';\nimport { DefaultRoomReaction, RoomReaction, RoomReactionMetadata } from './room-reaction.js';\n\ninterface ReactionPayload {\n  data?: {\n    name?: string;\n    metadata?: RoomReactionMetadata;\n  };\n  clientId?: string;\n  timestamp: number;\n}\n\n/**\n * Parses a room reaction from an inbound message.\n * @param message The inbound message containing the reaction data.\n * @param clientId The client ID of the user.\n * @returns The parsed room reaction.\n */\nexport const parseRoomReaction = (message: Ably.InboundMessage, clientId?: string): RoomReaction => {\n  const reactionCreatedMessage = message as ReactionPayload;\n\n  // Use empty string if type is missing or invalid\n  const name =\n    reactionCreatedMessage.data?.name && typeof reactionCreatedMessage.data.name === 'string'\n      ? reactionCreatedMessage.data.name\n      : '';\n\n  // Use empty string if clientId is missing\n  const messageClientId = reactionCreatedMessage.clientId ?? '';\n\n  // Use current time if timestamp is missing\n  const timestamp = reactionCreatedMessage.timestamp ? new Date(reactionCreatedMessage.timestamp) : new Date();\n\n  const extras = realtimeExtras(message.extras);\n\n  return new DefaultRoomReaction(\n    name,\n    messageClientId,\n    timestamp,\n    clientId ? clientId === messageClientId : false,\n    reactionCreatedMessage.data?.metadata ?? {},\n    extras.headers ?? {},\n    extras.userClaim,\n  );\n};\n","import * as Ably from 'ably';\n\nimport { ClientIdResolver } from './client-id.js';\nimport { ErrorCode } from './errors.js';\nimport { RoomReactionEvent, RoomReactionEventType, RoomReactionRealtimeEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { messageToEphemeral } from './realtime.js';\nimport { subscribe } from './realtime-subscriptions.js';\nimport { RoomReactionHeaders, RoomReactionMetadata } from './room-reaction.js';\nimport { parseRoomReaction } from './room-reaction-parser.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { emitterHasListeners, wrap } from './utils/event-emitter.js';\n\n/**\n * Params for sending a room-level reactions. Only `name` is mandatory.\n */\nexport interface SendReactionParams {\n  /**\n   * The name of the reaction, for example an emoji or a short string (e.g., \"❤️\", \"👏\", \"confetti\", \"applause\").\n   *\n   * It is the only mandatory parameter to send a room-level reaction.\n   */\n  name: string;\n  /**\n   * Optional metadata of the reaction.\n   *\n   * The metadata is a map of extra information that can be attached to the\n   * room reaction. It is not used by Ably and is sent as part of the realtime\n   * message payload. Example use cases are custom animations or other effects.\n   *\n   * Do not use metadata for authoritative information. There is no server-side\n   * validation. When reading the metadata treat it like user input.\n   *\n   */\n  metadata?: RoomReactionMetadata;\n\n  /**\n   * Optional headers of the room reaction.\n   *\n   * The headers are a flat key-value map and are sent as part of the realtime\n   * message's `extras` inside the `headers` property. They can serve similar\n   * purposes as the metadata but they are read by Ably and can be used for\n   * features such as\n   * [subscription filters](https://faqs.ably.com/subscription-filters).\n   *\n   * Do not use the headers for authoritative information. There is no\n   * server-side validation. When reading the headers treat them like user\n   * input.\n   *\n   */\n  headers?: RoomReactionHeaders;\n}\n\n/**\n * The listener function type for room-level reactions.\n * @param event The reaction event that was received.\n */\nexport type RoomReactionListener = (event: RoomReactionEvent) => void;\n\n/**\n * This interface is used to interact with room-level reactions in a chat room: subscribing to reactions and sending them.\n *\n * Get an instance via {@link Room.reactions}.\n */\nexport interface RoomReactions {\n  /**\n   * Sends a room-level reaction.\n   *\n   * Room reactions are ephemeral events that are not associated with specific messages.\n   * They're commonly used for live interactions like floating emojis, applause, or other\n   * real-time feedback in chat rooms. Unlike message reactions, room reactions are not\n   * persisted and are only visible to users currently connected to the room.\n   *\n   * **Note**:\n   * - The room should be attached to send room reactions.\n   * - It is possible (though unlikely) to receive your own reaction via subscription before this promise resolves.\n   * @param params - The reaction parameters\n   * @returns Promise that resolves when the reaction has been sent, or rejects with:\n   * - {@link ErrorCode.InvalidArgument} if name is not provided\n   * - {@link ErrorCode.Disconnected} if not connected to Ably\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('live-event');\n   *\n   * // Attach to the room to send room reactions\n   * await room.attach();\n   *\n   * // Send a simple room reaction\n   * try {\n   *   await room.reactions.send({\n   *     name: '❤️'\n   *   });\n   *   console.log('Heart reaction sent to room');\n   * } catch (error) {\n   *    console.error('Failed to send reaction:', error);\n   * }\n   * ```\n   */\n  send(params: SendReactionParams): Promise<void>;\n\n  /**\n   * Subscribes to room-level reaction events.\n   *\n   * Receives all room reactions sent by any user in the room. This is useful for\n   * displaying floating reactions, triggering animations, or showing live audience\n   * engagement in real-time. Room reactions are ephemeral and not persisted.\n   *\n   * **Note**: The room should be attached to receive reaction events.\n   * @param listener - Callback invoked when a room reaction is received\n   * @returns Subscription object with an unsubscribe method\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, RoomReactionEvent } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('webinar-room');\n   *\n   * // Subscribe to room reactions for live animations\n   * const subscription = room.reactions.subscribe((event: RoomReactionEvent) => {\n   *   const { reaction } = event;\n   *\n   *   console.log(`${reaction.clientId} sent ${reaction.name}`);\n   *   console.log(`Sent at: ${reaction.createdAt.toISOString()}`);\n   *\n   *   // Handle different reaction types\n   *   switch (reaction.name) {\n   *     case '❤️':\n   *       // Show floating heart animation\n   *       showFloatingHeart(reaction.isSelf ? 'own' : 'other');\n   *       break;\n   *     case '👏':\n   *       // Show applause indicator\n   *       showApplauseAnimation(reaction.clientId);\n   *       break;\n   *     default:\n   *       // Handle generic reactions\n   *       showGenericReaction(reaction.name);\n   *   }\n   *\n   *   // Check if reaction is from current user\n   *   if (reaction.isSelf) {\n   *     console.log('You sent a reaction:', reaction.name);\n   *   }\n   * });\n   *\n   * // Attach to the room to start receiving events\n   * await room.attach();\n   *\n   * // Later, unsubscribe when done\n   * subscription.unsubscribe();\n   * ```\n   */\n  subscribe(listener: RoomReactionListener): Subscription;\n}\n\ninterface RoomReactionEventsMap {\n  [RoomReactionEventType.Reaction]: RoomReactionEvent;\n}\n\ninterface ReactionPayload {\n  name: string;\n  metadata?: RoomReactionMetadata;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultRoomReactions implements RoomReactions {\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _connection: Ably.Connection;\n  private readonly _clientIdResolver: ClientIdResolver;\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<RoomReactionEventsMap>();\n  private readonly _unsubscribeRoomReactionEvents: () => void;\n\n  /**\n   * Constructs a new `DefaultRoomReactions` instance.\n   * @param channel The Realtime channel instance.\n   * @param connection The connection instance.\n   * @param clientIdResolver The client ID resolver.\n   * @param logger An instance of the Logger.\n   */\n  constructor(\n    channel: Ably.RealtimeChannel,\n    connection: Ably.Connection,\n    clientIdResolver: ClientIdResolver,\n    logger: Logger,\n  ) {\n    this._channel = channel;\n    this._connection = connection;\n    this._clientIdResolver = clientIdResolver;\n    this._logger = logger;\n\n    // Create bound listener\n    const roomReactionEventsListener = this._forwarder.bind(this);\n\n    // Use subscription helper to create cleanup function\n    this._unsubscribeRoomReactionEvents = subscribe(\n      this._channel,\n      [RoomReactionRealtimeEventType.Reaction],\n      roomReactionEventsListener,\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async send(params: SendReactionParams): Promise<void> {\n    this._logger.trace('RoomReactions.send();', params);\n\n    const { name, metadata, headers } = params;\n\n    if (!name) {\n      throw new Ably.ErrorInfo(\n        'unable to send reaction; name not set and it is required',\n        ErrorCode.InvalidArgument,\n        400,\n      );\n    }\n\n    // CHA-ER3f\n    if (this._connection.state !== 'connected') {\n      throw new Ably.ErrorInfo('unable to send reaction; not connected to Ably', ErrorCode.Disconnected, 400);\n    }\n\n    const payload: ReactionPayload = {\n      name: name,\n      metadata: metadata ?? {},\n    };\n\n    const realtimeMessage: Ably.Message = {\n      name: RoomReactionRealtimeEventType.Reaction,\n      data: payload,\n      extras: {\n        headers: headers ?? {},\n      },\n    };\n\n    return this._channel.publish(messageToEphemeral(realtimeMessage));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribe(listener: RoomReactionListener): Subscription {\n    this._logger.trace(`RoomReactions.subscribe();`);\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      unsubscribe: () => {\n        this._logger.trace('RoomReactions.unsubscribe();');\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  // parses reactions from realtime channel into Reaction objects and forwards them to the EventEmitter\n  private _forwarder = (inbound: Ably.InboundMessage) => {\n    const reaction = parseRoomReaction(inbound, this._clientIdResolver.get());\n    this._emitter.emit(RoomReactionEventType.Reaction, {\n      type: RoomReactionEventType.Reaction,\n      reaction,\n    });\n  };\n\n  /**\n   * Disposes of the room reactions instance, removing all listeners and subscriptions.\n   * This method should be called when the room is being released to ensure proper cleanup.\n   * @internal\n   */\n  dispose(): void {\n    // Remove room reaction event subscriptions using stored unsubscribe function\n    this._unsubscribeRoomReactionEvents();\n\n    // Remove user-level listeners\n    this._emitter.off();\n  }\n\n  /**\n   * Checks if there are any listeners registered by users.\n   * @internal\n   * @returns true if there are listeners, false otherwise.\n   */\n  hasListeners(): boolean {\n    return emitterHasListeners(this._emitter);\n  }\n}\n","import * as Ably from 'ably';\nimport { E_CANCELED, Mutex } from 'async-mutex';\n\nimport { ErrorCode } from './errors.js';\nimport { TypingEventType, TypingSetEvent, TypingSetEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { ephemeralMessage } from './realtime.js';\nimport { realtimeExtras } from './realtime-extensions.js';\nimport { subscribe } from './realtime-subscriptions.js';\nimport { InternalTypingOptions } from './room-options.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * Represents a user in the set of currently typing users, with associated metadata.\n */\nexport interface TypingMember {\n  /** The client ID of the typing user. */\n  clientId: string;\n  /** The user claim attached to this user's typing event, if any. */\n  userClaim?: string;\n}\n\n/**\n * This interface is used to interact with typing in a chat room including subscribing to typing events and\n * fetching the current set of typing clients.\n *\n * Get an instance via {@link Room.typing}.\n */\nexport interface Typing {\n  /**\n   * Subscribes to typing events from users in the chat room.\n   *\n   * Receives updates whenever a user starts or stops typing, providing real-time\n   * feedback about who is currently composing messages. The subscription emits\n   * events containing the current set of typing users and details about what changed.\n   *\n   * **Note**: The room must be attached to receive typing events.\n   * @param listener - Callback invoked when the typing state changes\n   * @returns Subscription object with an unsubscribe method\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, TypingSetEvent } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options\n   * const room = await chatClient.rooms.get('team-chat');\n   *\n   * // Subscribe to typing events\n   * const subscription = room.typing.subscribe((event: TypingSetEvent) => {\n   *   const { currentlyTyping, change } = event;\n   *\n   *   // Display who is currently typing\n   *   if (currentlyTyping.size === 0) {\n   *     hideTypingIndicator();\n   *   } else if (currentlyTyping.size === 1) {\n   *     const [typingUser] = Array.from(currentlyTyping);\n   *     showTypingIndicator(`${typingUser} is typing...`);\n   *   } else if (currentlyTyping.size === 2) {\n   *     const users = Array.from(currentlyTyping);\n   *     showTypingIndicator(`${users[0]} and ${users[1]} are typing...`);\n   *   } else {\n   *     showTypingIndicator(`${currentlyTyping.size} people are typing...`);\n   *   }\n   * });\n   *\n   * // Attach to the room to start receiving events\n   * await room.attach();\n   *\n   * // Later, unsubscribe when done\n   * subscription.unsubscribe();\n   * ```\n   */\n  subscribe(listener: TypingListener): Subscription;\n\n  /**\n   * Gets the current set of users who are typing.\n   *\n   * Returns a Set containing the client IDs of all users currently typing in the room.\n   * This provides a snapshot of the typing state at the time of the call.\n   * @deprecated Use {@link Typing.currentTypers | currentTypers} instead, which includes metadata such as user claims.\n   * @returns Set of client IDs currently typing\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options\n   * const room = await chatClient.rooms.get('support-chat');\n   *\n   * // Attach to the room to start receiving events\n   * await room.attach();\n   *\n   * // Fetch the current cached set of typing users\n   * const typingUsers = room.typing.current;\n   *\n   * console.log(`${typingUsers.size} users are typing`);\n   *\n   * if (typingUsers.has('agent-001')) {\n   *   console.log('Support agent is typing a response...');\n   * }\n   * ```\n   */\n  get current(): Set<string>;\n\n  /**\n   * Gets the current set of users who are typing, with associated metadata.\n   *\n   * Returns an array of {@link TypingMember} objects containing the client IDs and\n   * user claims of all users currently typing in the room.\n   * @returns Array of {@link TypingMember} objects for users currently typing\n   */\n  get currentTypers(): TypingMember[];\n\n  /**\n   * Sends a typing started event to notify other users that the current user is typing.\n   *\n   * Events are throttled according to the `heartbeatThrottleMs` room option to prevent\n   * excessive network traffic. If called within the throttle interval, the operation\n   * becomes a no-op. Multiple rapid calls are serialized to maintain consistency.\n   *\n   * **Note**:\n   * - The connection must be in the `connected` state.\n   * - Calls to `keystroke()` and `stop()` are serialized and resolve in order.\n   * - The most recent operation always determines the final typing state.\n   * - The room must be attached to send typing events.\n   * @returns Promise that resolves when the typing event has been sent, or rejects with:\n   * - {@link ErrorCode.Disconnected} if not connected\n   * - {@link ErrorCode.OperationSerializationFailed} if mutex acquisition fails\n   * - {@link Ably.ErrorInfo} if the operation fails to send the event\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options and attach to it\n   * const room = await chatClient.rooms.get('project-discussion');\n   * await room.attach();\n   *\n   * try {\n   *     await room.typing.keystroke();\n   * } catch (error) {\n   *     console.error('Typing indicator error:', error);\n   *   }\n   * ```\n   */\n  keystroke(): Promise<void>;\n\n  /**\n   * Sends a typing stopped event to notify other users that the current user has stopped typing.\n   *\n   * If the user is not currently typing, this operation is a no-op. Multiple rapid calls\n   * are serialized to maintain consistency, with the most recent operation determining\n   * the final state.\n   *\n   * **Note**:\n   * - The connection must be in the `connected` state.\n   * - Calls to `keystroke()` and `stop()` are serialized and resolve in order.\n   * - The room must be attached to send typing events.\n   * @returns Promise that resolves when the stop event has been sent, or rejects with:\n   * - {@link ErrorCode.Disconnected} if not connected\n   * - {@link ErrorCode.OperationSerializationFailed} if mutex acquisition fails\n   * - {@link Ably.ErrorInfo} if the operation fails to send the event\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options and attach to it\n   * const room = await chatClient.rooms.get('customer-support');\n   * await room.attach();\n   *\n   * // Start typing in the room\n   * try {\n   *  await room.typing.keystroke();\n   *  } catch (error) {\n   *  console.error('Typing indicator error:', error);\n   *  }\n   *\n   *  // User sends a message, or deletes their draft, etc.\n   *\n   * // Stop typing in the room\n   * try {\n   * await room.typing.stop();\n   * } catch (error) {\n   * console.error('Failed to stop typing:', error);\n   * }\n   * ```\n   */\n  stop(): Promise<void>;\n}\n\n/**\n * A listener which listens for typing events.\n * @param event The typing event.\n */\nexport type TypingListener = (event: TypingSetEvent) => void;\n\n/**\n * Represents the typing events mapped to their respective event payloads.\n */\ninterface TypingEventsMap {\n  [TypingSetEventType.SetChanged]: TypingSetEvent;\n}\n\n/**\n * Represents a timer handle that can be undefined.\n */\ntype TypingTimerHandle = ReturnType<typeof setTimeout> | undefined;\n\n/**\n * Tracks the state of a currently typing client.\n */\ninterface TypingClientState {\n  /** The inactivity timer for this client. */\n  timer: TypingTimerHandle;\n  /** The user claim from the typing event, if any. */\n  userClaim?: string;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultTyping extends EventEmitter<TypingEventsMap> implements Typing {\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _connection: Ably.Connection;\n  private readonly _logger: Logger;\n\n  // Throttle for the heartbeat, how often we should emit a typing event with repeated calls to keystroke()\n  // CHA-T10\n  private readonly _heartbeatThrottleMs: number;\n\n  // Grace period for inactivity before another user is considered to have stopped typing\n  // CHA-T10a\n  private readonly _timeoutMs = 2000;\n  private _heartbeatTimerId: TypingTimerHandle;\n  private readonly _currentlyTyping: Map<string, TypingClientState>;\n\n  // Mutex for controlling `keystroke` and `stop` operations\n  private readonly _mutex = new Mutex();\n\n  // Cleanup function for the channel subscription\n  private readonly _unsubscribeTypingEvents: () => void;\n\n  /**\n   * Constructs a new `DefaultTyping` instance.\n   * @param options The options for typing in the room.\n   * @param connection The connection instance.\n   * @param channel The channel for the room.\n   * @param logger An instance of the Logger.\n   */\n  constructor(\n    options: InternalTypingOptions,\n    connection: Ably.Connection,\n    channel: Ably.RealtimeChannel,\n    logger: Logger,\n  ) {\n    super();\n    this._channel = channel;\n    this._connection = connection;\n\n    // Interval for the heartbeat, how often we should emit a typing event with repeated calls to start()\n    this._heartbeatThrottleMs = options.heartbeatThrottleMs;\n\n    // Map of clientIds to their typing state (timer + userClaim)\n    this._currentlyTyping = new Map<string, TypingClientState>();\n    this._logger = logger;\n\n    // Use subscription helper to create cleanup function\n    this._unsubscribeTypingEvents = subscribe(\n      this._channel,\n      [TypingEventType.Started, TypingEventType.Stopped],\n      this._internalSubscribeToEvents.bind(this),\n    );\n  }\n\n  /**\n   * Clears all typing states.\n   * This includes clearing all timeouts and the currently typing map.\n   */\n  private _clearAllTypingStates(): void {\n    this._logger.debug(`DefaultTyping._clearAllTypingStates(); clearing all typing states`);\n    this._clearHeartbeatTimer();\n    this._clearCurrentlyTyping();\n  }\n\n  /**\n   * Clears the heartbeat timer.\n   */\n  private _clearHeartbeatTimer(): void {\n    this._logger.trace(`DefaultTyping._clearHeartbeatTimer(); clearing heartbeat timer`);\n    if (this._heartbeatTimerId) {\n      clearTimeout(this._heartbeatTimerId);\n      this._heartbeatTimerId = undefined;\n    }\n  }\n\n  /**\n   * Clears the currently typing store and removes all timeouts for associated clients.\n   */\n  private _clearCurrentlyTyping(): void {\n    this._logger.trace('DefaultTyping._clearCurrentlyTyping(); clearing current store and timeouts');\n    // Clear all client typing timeouts\n    for (const [, state] of this._currentlyTyping.entries()) {\n      clearTimeout(state.timer);\n    }\n    // Clear the currently typing map\n    this._currentlyTyping.clear();\n  }\n\n  /**\n   * CHA-T16\n   * @inheritDoc\n   */\n  get current(): Set<string> {\n    this._logger.trace(`DefaultTyping.current();`);\n    return new Set<string>(this._currentlyTyping.keys());\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get currentTypers(): TypingMember[] {\n    this._logger.trace(`DefaultTyping.currentTypers();`);\n    return this._buildCurrentTypers();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get channel(): Ably.RealtimeChannel {\n    return this._channel;\n  }\n\n  /**\n   * Start the heartbeat timer. This will expire after the configured interval.\n   */\n  private _startHeartbeatTimer(): void {\n    if (!this._heartbeatTimerId) {\n      this._logger.trace(`DefaultTyping.startHeartbeatTimer();`);\n      const timer = (this._heartbeatTimerId = setTimeout(() => {\n        this._logger.debug(`DefaultTyping.startHeartbeatTimer(); heartbeat timer expired`);\n        // CHA-T2a\n        if (timer === this._heartbeatTimerId) {\n          this._heartbeatTimerId = undefined;\n        }\n      }, this._heartbeatThrottleMs));\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async keystroke(): Promise<void> {\n    this._logger.trace(`DefaultTyping.keystroke();`);\n    this._mutex.cancel();\n\n    // Acquire a mutex\n    try {\n      await this._mutex.acquire();\n    } catch (error: unknown) {\n      if (error === E_CANCELED) {\n        this._logger.debug(`DefaultTyping.keystroke(); mutex was canceled by a later operation`);\n        return;\n      }\n      throw new Ably.ErrorInfo(\n        'unable to send keystroke event; failed to enforce sequential execution of the operation',\n        ErrorCode.OperationSerializationFailed,\n        500,\n      );\n    }\n    try {\n      // Check if connection is connected\n      // CHA-T4e\n      if (this._connection.state !== 'connected') {\n        this._logger.error(`DefaultTyping.keystroke(); connection is not connected`, {\n          status: this._connection.state,\n        });\n        throw new Ably.ErrorInfo(\n          'unable to send typing keystroke event; disconnected from Ably',\n          ErrorCode.Disconnected,\n          400,\n        );\n      }\n\n      // Check whether user is already typing before publishing again\n      // CHA-T4c1, CHA-T4c2\n      if (this._heartbeatTimerId) {\n        this._logger.debug(`DefaultTyping.keystroke(); no-op, already typing and heartbeat timer has not expired`);\n        return;\n      }\n\n      // Perform the publish\n      // CHA-T4a3\n      await this._channel.publish(ephemeralMessage(TypingEventType.Started));\n\n      // Start the timer after publishing\n      // CHA-T4a5\n      this._startHeartbeatTimer();\n      this._logger.trace(`DefaultTyping.keystroke(); starting timers`);\n    } finally {\n      this._logger.trace(`DefaultTyping.keystroke(); releasing mutex`);\n      this._mutex.release();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async stop(): Promise<void> {\n    this._logger.trace(`DefaultTyping.stop();`);\n\n    this._mutex.cancel();\n    // Acquire a mutex\n    try {\n      await this._mutex.acquire();\n    } catch (error: unknown) {\n      if (error === E_CANCELED) {\n        this._logger.debug(`DefaultTyping.stop(); mutex was canceled by a later operation`);\n        return;\n      }\n      throw new Ably.ErrorInfo(\n        'unable to send typing stop event; failed to enforce sequential execution of the operation',\n        ErrorCode.OperationSerializationFailed,\n        500,\n      );\n    }\n    try {\n      // Check if connection is connected\n      if (this._connection.state !== 'connected') {\n        this._logger.error(`DefaultTyping.stop(); connection is not connected`, {\n          status: this._connection.state,\n        });\n        throw new Ably.ErrorInfo(\n          'unable to send typing stop event; disconnected from Ably',\n          ErrorCode.Disconnected,\n          400,\n        );\n      }\n\n      // If the user is not typing, do nothing.\n      // CHA-T5f\n      if (!this._heartbeatTimerId) {\n        this._logger.debug(`DefaultTyping.stop(); no-op, not currently typing`);\n        return;\n      }\n\n      // CHA-T5d\n      await this._channel.publish(ephemeralMessage(TypingEventType.Stopped));\n      this._logger.trace(`DefaultTyping.stop(); clearing timers`);\n\n      // CHA-T5e\n      // Clear the heartbeat timer\n      clearTimeout(this._heartbeatTimerId);\n      this._heartbeatTimerId = undefined;\n    } finally {\n      this._logger.trace(`DefaultTyping.stop(); releasing mutex`);\n      this._mutex.release();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribe(listener: TypingListener): Subscription {\n    this._logger.trace(`DefaultTyping.subscribe();`);\n    const wrapped = wrap(listener);\n    this.on(wrapped);\n\n    return {\n      unsubscribe: () => {\n        this._logger.trace('DefaultTyping.unsubscribe();');\n        this.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // CHA-RL3h\n  async dispose(): Promise<void> {\n    this._logger.trace(`DefaultTyping.dispose();`);\n\n    // Keep trying to acquire the mutex; wait 200 ms between attempts.\n    for (;;) {\n      try {\n        this._mutex.cancel();\n        await this._mutex.acquire();\n        break; // success – exit the loop\n      } catch (error: unknown) {\n        if (error === E_CANCELED) {\n          // In this case, the mutex was canceled by a later operation,\n          // but we are trying to release, so we should always take precedence here.\n          // Let's continue trying to acquire it until we win the acquisition lock.\n          this._logger.debug(`DefaultTyping.dispose(); mutex was canceled`);\n          await new Promise((resolve) => setTimeout(resolve, 200));\n          this._logger.debug(`DefaultTyping.dispose(); retrying mutex acquisition`);\n        } else {\n          // If we encounter any other error, we log it and exit the loop.\n          // This is to ensure that we don't get stuck in an infinite loop\n          // if the mutex acquisition fails for some other non-retryable reason.\n          this._logger.error(`DefaultTyping.dispose(); failed to acquire mutex; could not complete resource disposal`, {\n            error,\n          });\n          return;\n        }\n      }\n    }\n    this._clearAllTypingStates();\n    this._unsubscribeTypingEvents();\n    this.off();\n    this._mutex.release();\n  }\n\n  /**\n   * Update the currently typing users. This method is called when a typing event is received.\n   * It will also acquire a mutex to ensure that the currentlyTyping state is updated safely.\n   * @param clientId The client ID of the user.\n   * @param event The typing event.\n   * @param userClaim The user claim from the typing event, if any.\n   */\n  private _updateCurrentlyTyping(clientId: string, event: TypingEventType, userClaim?: string): void {\n    this._logger.trace(`DefaultTyping._updateCurrentlyTyping();`, { clientId, event });\n\n    if (event === TypingEventType.Started) {\n      this._handleTypingStart(clientId, userClaim);\n    } else {\n      this._handleTypingStop(clientId, userClaim);\n    }\n  }\n\n  /**\n   * Builds an array of TypingMember objects from the current typing state.\n   * @returns Array of {@link TypingMember} objects for users currently typing\n   */\n  private _buildCurrentTypers(): TypingMember[] {\n    return [...this._currentlyTyping.entries()].map(([clientId, state]) => ({\n      clientId,\n      userClaim: state.userClaim,\n    }));\n  }\n\n  /**\n   * Starts a new inactivity timer for the client.\n   * This timer will expire after the configured timeout,\n   * which is the sum of the heartbeat interval and the inactivity timeout.\n   * @param clientId The client ID for which to start the timer.\n   * @returns The timeout ID for the new timer.\n   */\n  private _startNewClientInactivityTimer(clientId: string): ReturnType<typeof setTimeout> {\n    this._logger.trace(`DefaultTyping._startNewClientInactivityTimer(); starting new inactivity timer`, {\n      clientId,\n    });\n    // Set or reset the typing timeout for this client\n    const timeoutId = setTimeout(() => {\n      this._logger.trace(`DefaultTyping._startNewClientInactivityTimer(); client typing timeout expired`, {\n        clientId,\n      });\n      // Verify the timer is still valid (it might have been reset)\n      const clientState = this._currentlyTyping.get(clientId);\n      if (clientState?.timer !== timeoutId) {\n        this._logger.debug(`DefaultTyping._startNewClientInactivityTimer(); timeout already cleared; ignoring`, {\n          clientId,\n        });\n        return;\n      }\n\n      // Remove client whose timeout has expired\n      const timedOutUserClaim = clientState.userClaim;\n      this._currentlyTyping.delete(clientId);\n      this.emit(TypingSetEventType.SetChanged, {\n        type: TypingSetEventType.SetChanged,\n        currentlyTyping: new Set<string>(this._currentlyTyping.keys()),\n        currentTypers: this._buildCurrentTypers(),\n        change: {\n          clientId,\n          type: TypingEventType.Stopped,\n          userClaim: timedOutUserClaim,\n        },\n      });\n    }, this._heartbeatThrottleMs + this._timeoutMs);\n    return timeoutId;\n  }\n\n  /**\n   * Handles logic for TypingEventType.Started, including starting a new timeout or resetting an existing one.\n   * @param clientId The client ID that started typing.\n   * @param userClaim The user claim from the typing event, if any.\n   */\n  private _handleTypingStart(clientId: string, userClaim?: string): void {\n    this._logger.debug(`DefaultTyping._handleTypingStart();`, { clientId });\n    // Start a new timeout for the client\n    const timeoutId = this._startNewClientInactivityTimer(clientId);\n\n    const existingState = this._currentlyTyping.get(clientId);\n\n    // Set the new state for the client, using the claim from the incoming event\n    this._currentlyTyping.set(clientId, { timer: timeoutId, userClaim });\n\n    if (existingState) {\n      // Heartbeat - User is already typing, we just need to clear the existing timeout\n      this._logger.debug(`DefaultTyping._handleTypingStart(); received heartbeat for currently typing client`, {\n        clientId,\n      });\n      clearTimeout(existingState.timer);\n    } else {\n      // Otherwise, we need to emit a new typing event\n      this._logger.debug(`DefaultTyping._handleTypingStart(); new client started typing`, {\n        clientId,\n      });\n      this.emit(TypingSetEventType.SetChanged, {\n        type: TypingSetEventType.SetChanged,\n        currentlyTyping: new Set<string>(this._currentlyTyping.keys()),\n        currentTypers: this._buildCurrentTypers(),\n        change: {\n          clientId,\n          type: TypingEventType.Started,\n          userClaim,\n        },\n      });\n    }\n  }\n\n  /**\n   * Handles logic for TypingEventType.Stopped, including clearing the timeout for the client.\n   * @param clientId The client ID that stopped typing.\n   * @param userClaim The user claim from the stop event, if any.\n   */\n  private _handleTypingStop(clientId: string, userClaim?: string): void {\n    const existingState = this._currentlyTyping.get(clientId);\n    if (!existingState) {\n      // Stop requested for a client that isn't currently typing\n      this._logger.trace(\n        `DefaultTyping._handleTypingStop(); received \"Stop\" event for client not in currentlyTyping list`,\n        { clientId },\n      );\n      return;\n    }\n\n    // Stop typing: clear their timeout and remove from the currently typing set\n    this._logger.debug(`DefaultTyping._handleTypingStop(); client stopped typing`, { clientId });\n    clearTimeout(existingState.timer);\n    this._currentlyTyping.delete(clientId);\n    // Emit stop event only when the client is removed\n    this.emit(TypingSetEventType.SetChanged, {\n      type: TypingSetEventType.SetChanged,\n      currentlyTyping: new Set<string>(this._currentlyTyping.keys()),\n      currentTypers: this._buildCurrentTypers(),\n      change: {\n        clientId,\n        type: TypingEventType.Stopped,\n        userClaim,\n      },\n    });\n  }\n\n  /**\n   * Subscribe to internal events. This listens to events and converts them into typing updates, with validation.\n   * @param inbound The inbound message containing typing event data.\n   */\n  private _internalSubscribeToEvents = (inbound: Ably.InboundMessage): void => {\n    const { name, clientId } = inbound;\n    this._logger.trace(`DefaultTyping._internalSubscribeToEvents(); received event`, {\n      name,\n      clientId,\n    });\n\n    if (!clientId) {\n      this._logger.error(`DefaultTyping._internalSubscribeToEvents(); invalid clientId in received event`, {\n        inbound,\n      });\n      return;\n    }\n\n    const extras = realtimeExtras(inbound.extras);\n    const userClaim = extras.userClaim;\n\n    // Safety check to ensure we are handling only typing events\n    if (name === TypingEventType.Started || name === TypingEventType.Stopped) {\n      this._updateCurrentlyTyping(clientId, name, userClaim);\n    } else {\n      this._logger.warn(`DefaultTyping._internalSubscribeToEvents(); unrecognized event`, {\n        name,\n      });\n    }\n  };\n\n  get heartbeatThrottleMs(): number {\n    return this._heartbeatThrottleMs;\n  }\n\n  get hasHeartbeatTimer(): boolean {\n    return !!this._heartbeatTimerId;\n  }\n}\n","import * as Ably from 'ably';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport { ChannelManager } from './channel-manager.js';\nimport { ChatApi } from './chat-api.js';\nimport { ClientIdResolver } from './client-id.js';\nimport { DiscontinuityListener } from './discontinuity.js';\nimport { Logger } from './logger.js';\nimport { DefaultMessageReactions } from './message-reactions.js';\nimport { DefaultMessages, Messages } from './messages.js';\nimport { DefaultOccupancy, Occupancy } from './occupancy.js';\nimport { DefaultPresence, Presence } from './presence.js';\nimport { RoomLifecycleManager } from './room-lifecycle-manager.js';\nimport { InternalRoomOptions, RoomOptions, validateRoomOptions } from './room-options.js';\nimport { DefaultRoomReactions, RoomReactions } from './room-reactions.js';\nimport { DefaultRoomLifecycle, InternalRoomLifecycle, RoomStatus, RoomStatusListener } from './room-status.js';\nimport { StatusSubscription } from './subscription.js';\nimport { DefaultTyping, Typing } from './typing.js';\n\n/**\n * Represents a chat room.\n */\nexport interface Room {\n  /**\n   * The unique identifier of the room.\n   * @returns The room name as provided when the room was created\n   * @example\n   * ```typescript\n   * const room = await chatClient.rooms.get('sports-discussion');\n   * console.log(`Connected to room: ${room.name}`);\n   *\n   * // Output: Connected to room: sports-discussion\n   * ```\n   */\n  get name(): string;\n\n  /**\n   * Provides access to the messages feature for sending, receiving, and querying chat messages.\n   * @returns The Messages instance for this room\n   * @example\n   * ```typescript\n   * const room = await chatClient.rooms.get('team-chat');\n   *\n   * // Access messages feature\n   * const { subscribe, send, update, ... } = room.messages;\n   *\n   * ```\n   */\n  get messages(): Messages;\n\n  /**\n   * Provides access to the presence feature for tracking user presence state.\n   * @returns The Presence instance for this room\n   * @example\n   * ```typescript\n   * const room = await chatClient.rooms.get('meeting-room');\n   *\n   * // Access presence feature\n   * const { enter, leave, get, ... } = room.presence;\n   * ```\n   */\n  get presence(): Presence;\n\n  /**\n   * Provides access to room-level reactions for sending ephemeral reactions.\n   * @returns The RoomReactions instance for this room\n   * @example\n   * ```typescript\n   * const room = await chatClient.rooms.get('live-stream');\n   *\n   * // Access room reactions feature\n   * const { send, ... } = room.reactions;\n   *\n   * ```\n   */\n  get reactions(): RoomReactions;\n\n  /**\n   * Provides access to the typing indicators feature for showing who is currently typing.\n   * @returns The Typing instance for this room\n   * @example\n   * ```typescript\n   * const room = await chatClient.rooms.get('support-chat');\n   *\n   * // Access typing feature\n   * const { keystroke, stop, ... } = room.typing;\n   *\n   * ```\n   */\n  get typing(): Typing;\n\n  /**\n   * Provides access to room occupancy metrics for tracking connection and presence counts.\n   * @returns The Occupancy instance for this room\n   * @example\n   * ```typescript\n   * const room = await chatClient.rooms.get('webinar-room');\n   *\n   * // Access occupancy feature\n   * const { get, ... } = room.occupancy;\n   * ```\n   */\n  get occupancy(): Occupancy;\n\n  /**\n   * The current lifecycle status of the room.\n   * @returns The current RoomStatus value\n   * @example\n   * ```typescript\n   * const room = await chatClient.rooms.get('game-lobby');\n   *\n   * // Check room status\n   * if (room.status === RoomStatus.Attached) {\n   *   console.log('Room is connected and ready');\n   * } else if (room.status === RoomStatus.Failed) {\n   *   console.error('Room connection failed');\n   * }\n   *\n   * ```\n   */\n  get status(): RoomStatus;\n\n  /**\n   * The error that caused the room to enter its current status, if any.\n   * @returns ErrorInfo if an error caused the current status, undefined otherwise\n   * @example\n   * ```typescript\n   * const room = await chatClient.rooms.get('private-chat');\n   *\n   * if (room.error) {\n   *   console.error('Room error:', room.error.message);\n   *   console.error('Error code:', room.error.code);\n   *\n   *   // Handle specific error codes\n   *   if (room.error.code === 40300) {\n   *     showMessage('Access denied to this room');\n   *   } else {\n   *     showMessage(`Connection failed: ${room.error.message}`);\n   *   }\n   * }\n   * ```\n   */\n  get error(): Ably.ErrorInfo | undefined;\n\n  /**\n   * Registers a listener to be notified of room status changes.\n   *\n   * Status changes indicate the room's connection lifecycle. Use this to\n   * monitor room health and handle connection issues over time.\n   * @param listener - Callback invoked when the room status changes\n   * @returns Subscription object with an unsubscribe method\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, RoomStatus } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('support-chat');\n   *\n   * // Monitor room status changes\n   * const statusSubscription = room.onStatusChange((change) => {\n   *   console.log(`Room status: ${change.previous} -> ${change.current}`);\n   *   console.log(`Timestamp: ${change.timestamp.toISOString()}`);\n   *\n   *   // Handle different status transitions\n   *   switch (change.current) {\n   *     case RoomStatus.Attached:\n   *       console.log('Room is now connected');\n   *       enableChatUI();\n   *       showOnlineIndicator();\n   *       break;\n   *\n   *     case RoomStatus.Attaching:\n   *       console.log('Connecting to room...');\n   *       showConnectingSpinner();\n   *       break;\n   *\n   *     // Handle other cases as needed\n   *   }\n   * });\n   *\n   * // Clean up when done\n   * statusSubscription.off();\n   * ```\n   */\n  onStatusChange(listener: RoomStatusListener): StatusSubscription;\n\n  /**\n   * Attaches to the room to begin receiving events.\n   *\n   * Establishes an attachment to the room, enabling message delivery,\n   * presence updates, typing, and other events. The room must be\n   * attached before non-REST-based operations (like `presence.enter()`) can be performed.\n   *\n   * **Note**:\n   * - If attachment fails, the room enters {@link RoomStatus.Suspended} or {@link RoomStatus.Failed} state.\n   * - Suspended rooms automatically retry; Failed rooms require manual intervention.\n   * - The promise rejects with an {@link ErrorInfo} for suspended states, but the room will retry attaching after a delay.\n   * @returns Promise that resolves when the room is successfully attached, or rejects with:\n   * - {@link Ably.ErrorInfo} if the room enters suspended state (auto-retry will occur)\n   * - {@link Ably.ErrorInfo} if the room enters failed state (manual intervention required)\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, RoomStatus } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('team-standup');\n   *\n   * // Attach to room with error handling\n   * try {\n   *   await room.attach();\n   *   console.log('Successfully attached to room');\n   *\n   *   // Now safe to use room features\n   *   await room.presence.enter();\n   *\n   *   // And subscriptions will start receiving events\n   *   room.messages.subscribe((event) => {\n   *     console.log('New message:', event.message);\n   *   });\n   * } catch (error) {\n   *   console.error('Failed to attach to room:', error);\n   *\n   *   // Check current room status\n   *   if (room.status === RoomStatus.Suspended) {\n   *     console.log('Room suspended, will retry automatically');\n   *   } else if (room.status === RoomStatus.Failed) {\n   *     console.error('Room failed, manual intervention needed');\n   *   }\n   * }\n   *\n   * ```\n   */\n  attach(): Promise<void>;\n\n  /**\n   * Detaches from the room to stop receiving chat events.\n   *\n   * Subscriptions remain registered but won't receive events until the room is\n   * reattached. Use this to gracefully detach when leaving a chat view. This command leaves all\n   * subscriptions intact, so they will resume receiving events when the room is reattached.\n   * @returns Promise that resolves when the room is successfully detached\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options and attach to it\n   * const room = await chatClient.rooms.get('customer-support');\n   * await room.attach();\n   *\n   * // Do chat operations...\n   *\n   * try {\n   *     // Detach from room\n   *     await room.detach();\n   *     console.log('Successfully detached from room');\n   *   } catch (error) {\n   *     console.error('Failed to detach from room:', error);\n   *   }\n   * ```\n   */\n  detach(): Promise<void>;\n\n  /**\n   * Returns a copy of the options used to configure the room.\n   *\n   * Provides access to all room configuration including presence, typing, reactions,\n   * and occupancy settings. The returned object is a deep copy to prevent external\n   * modifications to the room's configuration.\n   * @returns A deep copy of the room options\n   * @example\n   * ```typescript\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient = new ChatClient(realtime);\n   *\n   * // Create room with specific options\n   * const room = await chatClient.rooms.get('conference-hall', {\n   *   presence: {\n   *     enableEvents: true,\n   *     syncPresenceOnEntry: true\n   *   },\n   *   typing: {\n   *     heartbeatThrottleMs: 1500\n   *   },\n   *   occupancy: {\n   *     enableEvents: true\n   *   },\n   *   messages: {\n   *     rawMessageReactions: false\n   *   }\n   * });\n   *\n   * // Get room options to check configuration\n   * const options = room.options();\n   *\n   * console.log('Room configuration:');\n   * console.log('Presence events:', options.presence?.enableEvents);\n   * console.log('Typing throttle:', options.typing?.heartbeatThrottleMs);\n   * console.log('Occupancy events:', options.occupancy?.enableEvents);\n   * ```\n   */\n  options(): RoomOptions;\n\n  /**\n   * Registers a handler for discontinuity events in the room's connection.\n   *\n   * A discontinuity occurs when the connection is interrupted and cannot resume\n   * from its previous state, potentially resulting in missed messages or events.\n   * Use this to detect gaps in the event stream and take corrective action.\n   *\n   * **Note**:\n   * - Discontinuities require fetching missed messages via history.\n   * - Message subscriptions automatically reset their position on discontinuity, see {@link MessageSubscriptionResponse.historyBeforeSubscribe} for more information.\n   * - You should subscribe to discontinuities before attaching to the room.\n   * @param handler - Callback invoked when a discontinuity is detected\n   * @returns Subscription object with an unsubscribe method\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * const room = await chatClient.rooms.get('critical-updates');\n   *\n   * // Handle discontinuities to ensure no messages are missed\n   * const discontinuitySubscription = room.onDiscontinuity((reason) => {\n   *   console.warn('Discontinuity detected:', reason);\n   *\n   *   // Show warning to user\n   *   showDiscontinuityWarning('Connection interrupted - fetching missed messages...');\n   *\n   *   // You may also want to fetch missed messages to fill gaps during the discontinuity.\n   * });\n   *\n   * // Attach to the room to start receiving events\n   * await room.attach();\n   *\n   * // Clean up\n   * discontinuitySubscription.off();\n   * ```\n   */\n  onDiscontinuity(handler: DiscontinuityListener): StatusSubscription;\n\n  /**\n   * Provides direct access to the underlying Ably Realtime channel.\n   *\n   * Use this for advanced scenarios requiring direct access to the underlying channel. Directly interacting\n   * with the Ably channel can lead to unexpected behavior, and so is generally discouraged.\n   * @returns The underlying Ably RealtimeChannel instance\n   * @example\n   * ```typescript\n   * const room = await chatClient.rooms.get('advanced-room');\n   *\n   * // Access underlying channel for advanced operations\n   * const channel = room.channel;\n   * ```\n   */\n  get channel(): Ably.RealtimeChannel;\n}\n\nexport class DefaultRoom implements Room {\n  private readonly _name: string;\n  private readonly _options: RoomOptions;\n  private readonly _chatApi: ChatApi;\n  private readonly _messages: DefaultMessages;\n  private readonly _typing: DefaultTyping;\n  private readonly _presence: DefaultPresence;\n  private readonly _reactions: DefaultRoomReactions;\n  private readonly _occupancy: DefaultOccupancy;\n  private readonly _logger: Logger;\n  private readonly _lifecycle: DefaultRoomLifecycle;\n  private readonly _lifecycleManager: RoomLifecycleManager;\n  private readonly _finalizer: () => Promise<void>;\n  private readonly _channelManager: ChannelManager;\n\n  /**\n   * A random identifier for the room instance, useful in debugging and logging.\n   */\n  private readonly _nonce: string;\n\n  /**\n   * Constructs a new Room instance.\n   * @param name The unique identifier of the room.\n   * @param nonce A random identifier for the room instance, useful in debugging and logging.\n   * @param options The options for the room.\n   * @param realtime An instance of the Ably Realtime client.\n   * @param chatApi An instance of the ChatApi.\n   * @param clientIdResolver An instance of the ClientIdResolver.\n   * @param logger An instance of the Logger.\n   */\n  constructor(\n    name: string,\n    nonce: string,\n    options: InternalRoomOptions,\n    realtime: Ably.Realtime,\n    chatApi: ChatApi,\n    clientIdResolver: ClientIdResolver,\n    logger: Logger,\n  ) {\n    validateRoomOptions(options);\n    this._nonce = nonce;\n\n    // Create a logger with room context\n    this._logger = logger.withContext({ roomName: name, roomNonce: nonce });\n    this._logger.debug('Room();', { options });\n\n    this._name = name;\n    this._options = options;\n    this._chatApi = chatApi;\n    this._lifecycle = new DefaultRoomLifecycle(this._logger);\n\n    const channelManager = (this._channelManager = this._getChannelManager(options, realtime, this._logger));\n    const channel = channelManager.get();\n\n    // Setup features\n    this._messages = new DefaultMessages(name, options.messages, channel, this._chatApi, this._logger);\n    this._presence = new DefaultPresence(channel, this._logger, options);\n    this._typing = new DefaultTyping(options.typing, realtime.connection, channel, this._logger);\n    this._reactions = new DefaultRoomReactions(channel, realtime.connection, clientIdResolver, this._logger);\n    this._occupancy = new DefaultOccupancy(name, channel, this._chatApi, this._logger, options);\n\n    // Set the lifecycle manager last, so it becomes the last thing to find out about channel state changes\n    // This is to allow Messages to reset subscription points before users get told of a discontinuity\n    this._lifecycleManager = new RoomLifecycleManager(channelManager, this._lifecycle, this._logger);\n\n    // Setup a finalization function to clean up resources\n    let finalized = false;\n    this._finalizer = async () => {\n      // Cycle the channels in the feature and release them from the realtime client\n      if (finalized) {\n        this._logger.debug('Room.finalizer(); already finalized');\n        return;\n      }\n\n      // Release via the lifecycle manager\n      await this._lifecycleManager.release();\n\n      // Dispose of the lifecycle manager, removing all user-registered listeners from emitters\n      // and any listeners that have been registered to the realtime instance\n      this._lifecycleManager.dispose();\n\n      // Dispose of all features, removing any listeners that have been subscribed to the realtime instance\n      // and also removing any user-level listeners from the emitters\n      this._messages.dispose();\n      this._presence.dispose();\n      this._reactions.dispose();\n      this._occupancy.dispose();\n      await this._typing.dispose();\n\n      // Dispose of the RoomStatus instance\n      this._lifecycle.dispose();\n\n      finalized = true;\n    };\n  }\n\n  /**\n   * Gets the channel manager for the room, which handles merging channel options together and creating channels.\n   * @param options The room options.\n   * @param realtime  An instance of the Ably Realtime client.\n   * @param logger An instance of the Logger.\n   * @returns The channel manager instance.\n   */\n  private _getChannelManager(options: InternalRoomOptions, realtime: Ably.Realtime, logger: Logger): ChannelManager {\n    const manager = new ChannelManager(this._name, realtime, logger, options.isReactClient);\n\n    manager.mergeOptions(DefaultOccupancy.channelOptionMerger(options));\n    manager.mergeOptions(DefaultPresence.channelOptionMerger(options));\n    manager.mergeOptions(DefaultMessageReactions.channelOptionMerger(options));\n    return manager;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get name(): string {\n    return this._name;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  options(): RoomOptions {\n    return cloneDeep(this._options);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get messages(): Messages {\n    return this._messages;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get presence(): Presence {\n    return this._presence;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get reactions(): RoomReactions {\n    return this._reactions;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get typing(): Typing {\n    return this._typing;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get occupancy(): Occupancy {\n    return this._occupancy;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get status(): RoomStatus {\n    return this._lifecycle.status;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get error(): Ably.ErrorInfo | undefined {\n    return this._lifecycle.error;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  onStatusChange(listener: RoomStatusListener): StatusSubscription {\n    return this._lifecycle.onChange(listener);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async attach() {\n    this._logger.trace('Room.attach();');\n    return this._lifecycleManager.attach();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async detach(): Promise<void> {\n    this._logger.trace('Room.detach();');\n    return this._lifecycleManager.detach();\n  }\n\n  /**\n   * Releases resources associated with the room.\n   * @returns A promise that resolves when the room is released.\n   */\n  async release(): Promise<void> {\n    this._logger.trace('Room.release();');\n    return this._finalizer();\n  }\n\n  /**\n   * A random identifier for the room instance, useful in debugging and logging.\n   * @returns The nonce.\n   */\n  get nonce(): string {\n    return this._nonce;\n  }\n\n  /**\n   * @internal\n   * @returns The internal room lifecycle.\n   */\n  get lifecycle(): InternalRoomLifecycle {\n    return this._lifecycle;\n  }\n\n  /**\n   * @internal\n   * @returns The room lifecycle manager.\n   */\n  get lifecycleManager(): RoomLifecycleManager {\n    return this._lifecycleManager;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  onDiscontinuity(handler: DiscontinuityListener): StatusSubscription {\n    this._logger.trace('Room.onDiscontinuity();');\n    return this._lifecycleManager.onDiscontinuity(handler);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get channel(): Ably.RealtimeChannel {\n    return this._channelManager.get();\n  }\n}\n","import * as Ably from 'ably';\nimport { dequal } from 'dequal';\n\nimport { ChatApi } from './chat-api.js';\nimport { ClientIdResolver } from './client-id.js';\nimport { ErrorCode } from './errors.js';\nimport { randomId } from './id.js';\nimport { Logger } from './logger.js';\nimport { DefaultRoom, Room } from './room.js';\nimport { normalizeRoomOptions, RoomOptions } from './room-options.js';\n\n/**\n * Manages the lifecycle of chat rooms.\n */\nexport interface Rooms {\n  /**\n   * Gets a room reference by its unique identifier.\n   *\n   * Creates a new room instance or returns an existing one. The Rooms class ensures\n   * only one instance exists per room name. Always call `release()` when the room\n   * is no longer needed to free resources.\n   *\n   * **Note**:\n   * - If options differ from an existing room, an error is thrown.\n   * - If `get` is called during a release, it waits for release to complete.\n   * - If `release` is called before `get` resolves, the promise rejects.\n   * @param name - The unique identifier of the room\n   * @param options - Optional configuration for the room features\n   * @returns Promise resolving to the Room instance, or rejecting with:\n   * - {@link ErrorCode.RoomExistsWithDifferentOptions} if room exists with different options\n   * - {@link ErrorCode.ResourceDisposed} if the rooms instance has been disposed\n   * - {@link ErrorCode.RoomReleasedBeforeOperationCompleted} if room is released before get completes\n   * @example\n   * ```\n   * import * as Ably from 'ably';\n   * import { ChatClient, Room } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options\n   * const room = await chatClient.rooms.get('general-chat');\n   *\n   * // Always release when done\n   * await chatClient.rooms.release('general-chat');\n   *\n   * // Handle errors when options conflict\n   * try {\n   *   // This will throw if 'game-room' already exists with different options\n   *   const room1 = await chatClient.rooms.get('game-room', {\n   *     typing: { heartbeatThrottleMs: 1000 }\n   *   });\n   *\n   *   const room2 = await chatClient.rooms.get('game-room', {\n   *     typing: { heartbeatThrottleMs: 2000 } // Different options!\n   *   });\n   * } catch (error) {\n   *   if (error.code === 40000) {\n   *     console.error('Room already exists with different options');\n   *   }\n   * }\n   * ```\n   */\n  get(name: string, options?: RoomOptions): Promise<Room>;\n\n  /**\n   * Releases a room, freeing its resources and detaching it from Ably.\n   *\n   * After release, the room object is no longer usable. To use the room again,\n   * call `get()` to create a new instance. This method only releases the reference\n   * and detaches from Ably; it doesn't unsubscribe existing event listeners.\n   *\n   * **Note**:\n   * - Calling release aborts any in-progress `get` calls for the same room.\n   * - The room object becomes unusable after release.\n   * @param name - The unique identifier of the room to release\n   * @returns Promise that resolves when the room is fully released\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options and attach to it\n   * const room = await chatClient.rooms.get('temporary-chat');\n   * await room.attach();\n   *\n   * // Do chat operations...\n   *\n   * // When done, release the room\n   * await chatClient.rooms.release('temporary-chat');\n   *\n   * // The room object is now unusable\n   * try {\n   *   await room.messages.send({ text: 'This will fail' });\n   * } catch (error) {\n   *   console.error('Room has been released');\n   * }\n   *\n   * // To use the room again, get a new instance\n   * const newRoom = await chatClient.rooms.get('temporary-chat');\n   *\n   * // Handle release of non-existent rooms (no-op)\n   * await chatClient.rooms.release('non-existent-room'); // Safe, does nothing\n   * ```\n   */\n  release(name: string): Promise<void>;\n\n  /**\n   * Disposes all rooms that are currently in the rooms map.\n   * This method releases all rooms concurrently and clears the rooms map.\n   * @returns A promise that resolves when all rooms have been released.\n   */\n  dispose(): Promise<void>;\n}\n\n/**\n * An internal interface for Rooms.\n * @internal\n */\nexport interface InternalRooms extends Rooms {\n  /**\n   * Get the number of rooms currently in the rooms map.\n   * @returns The number of rooms currently in the rooms map.\n   */\n  get count(): number;\n}\n\n/**\n * Represents an entry in the chat room map.\n */\ninterface RoomMapEntry {\n  /**\n   * The promise that will eventually resolve to the room.\n   */\n  promise: Promise<DefaultRoom>;\n\n  /**\n   * A random, internal identifier useful for debugging and logging.\n   */\n  nonce: string;\n\n  /**\n   * The options for the room.\n   */\n  options: RoomOptions | undefined;\n\n  /**\n   * An abort controller to abort the get operation if the room is released before the get operation completes.\n   */\n  abort?: AbortController;\n}\n\n/**\n * Manages the chat rooms.\n */\nexport class DefaultRooms implements InternalRooms {\n  private readonly _realtime: Ably.Realtime;\n  private readonly _chatApi: ChatApi;\n  private readonly _rooms: Map<string, RoomMapEntry> = new Map<string, RoomMapEntry>();\n  private readonly _releasing = new Map<string, Promise<void>>();\n  private readonly _clientIdResolver: ClientIdResolver;\n  private readonly _logger: Logger;\n  private _isReact = false;\n  private _disposed = false;\n\n  /**\n   * Constructs a new Rooms instance.\n   * @param realtime An instance of the Ably Realtime client.\n   * @param clientIdResolver A resolver for the clientId.\n   * @param logger An instance of the Logger.\n   */\n  constructor(realtime: Ably.Realtime, clientIdResolver: ClientIdResolver, logger: Logger) {\n    this._realtime = realtime;\n    this._chatApi = new ChatApi(realtime, logger);\n    this._clientIdResolver = clientIdResolver;\n    this._logger = logger;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async get(name: string, options?: RoomOptions): Promise<Room> {\n    this._logger.trace('Rooms.get();', { roomName: name });\n\n    this._ensureNotDisposed();\n\n    const existingRoom = this._rooms.get(name);\n    if (existingRoom) {\n      return this._handleExistingRoom(existingRoom, name, options);\n    }\n\n    const ongoingRelease = this._releasing.get(name);\n    const nonce = randomId();\n\n    if (!ongoingRelease) {\n      return this._createNewRoom(name, nonce, options);\n    }\n\n    return this._waitForReleaseAndCreateRoom(name, nonce, options, ongoingRelease);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async release(name: string): Promise<void> {\n    this._logger.trace('Rooms.release();', { roomName: name });\n\n    const existingRoom = this._rooms.get(name);\n    const ongoingRelease = this._releasing.get(name);\n\n    if (!existingRoom) {\n      return this._handleNonExistentRoomRelease(name, ongoingRelease);\n    }\n\n    if (ongoingRelease) {\n      return this._handleConcurrentRelease(name, existingRoom, ongoingRelease);\n    }\n\n    return this._performRoomRelease(name, existingRoom);\n  }\n\n  /**\n   * Disposes all rooms that are currently in the rooms map and waits for any ongoing release operations to complete.\n   * This method releases all rooms concurrently, waits for any in-flight releases to finish, and clears the rooms map.\n   * After this method resolves, all rooms will have been fully released and cleaned up.\n   * @internal\n   * @returns A promise that resolves when all rooms have been released.\n   */\n  async dispose(): Promise<void> {\n    this._logger.trace('Rooms.dispose();');\n\n    // Mark this instance as disposed\n    this._disposed = true;\n\n    // Get all room names currently in the map\n    const roomNames = [...this._rooms.keys()];\n\n    if (roomNames.length === 0) {\n      this._logger.debug('Rooms.dispose(); no rooms to release');\n      return;\n    }\n\n    // Release all rooms concurrently\n    const releasePromises = roomNames.map(async (roomName) => this.release(roomName));\n\n    // Ensure we wait for all ongoing releases too, since we guarantee that all rooms are released after this call\n    // resolves.\n    const inFlight = [...this._releasing.values()];\n    const all = [...releasePromises, ...inFlight];\n\n    this._logger.debug('Rooms.dispose(); releasing rooms', { roomCount: roomNames.length, roomNames });\n\n    await Promise.all(all);\n    this._logger.debug('Rooms.dispose(); all rooms released successfully');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get count(): number {\n    return this._rooms.size;\n  }\n\n  /**\n   * Ensures the rooms instance has not been disposed.\n   */\n  private _ensureNotDisposed(): void {\n    if (this._disposed) {\n      throw new Ably.ErrorInfo('unable to get room; rooms instance has been disposed', ErrorCode.ResourceDisposed, 400);\n    }\n  }\n\n  /**\n   * Handles the case where a room already exists.\n   * @param existingRoom The existing room entry in the map.\n   * @param name The unique identifier of the room.\n   * @param options The options for the room.\n   * @returns A promise that resolves to the existing room.\n   */\n  private async _handleExistingRoom(existingRoom: RoomMapEntry, name: string, options?: RoomOptions): Promise<Room> {\n    if (!dequal(existingRoom.options, options)) {\n      throw new Ably.ErrorInfo(\n        'unable to get room; room already exists with different options',\n        ErrorCode.RoomExistsWithDifferentOptions,\n        400,\n      );\n    }\n\n    this._logger.debug('Rooms.get(); returning existing room', {\n      roomName: name,\n      nonce: existingRoom.nonce,\n      options,\n    });\n    return await existingRoom.promise;\n  }\n\n  /**\n   * Creates a new room when no existing room or ongoing release exists.\n   * @param name The unique identifier of the room.\n   * @param nonce A random, internal identifier useful for debugging and logging.\n   * @param options The options for the room.\n   * @returns A new room object.\n   */\n  private _createNewRoom(name: string, nonce: string, options?: RoomOptions): Room {\n    const room = this._makeRoom(name, nonce, options);\n    const entry: RoomMapEntry = {\n      promise: Promise.resolve(room),\n      nonce: nonce,\n      options: options,\n    };\n\n    this._rooms.set(name, entry);\n    this._logger.debug('Rooms.get(); returning new room', { roomName: name, nonce: room.nonce });\n    return room; // No need to await Promise.resolve(room)\n  }\n\n  /**\n   * Waits for an ongoing release to complete, then creates a new room.\n   * @param name The unique identifier of the room.\n   * @param nonce A random, internal identifier useful for debugging and logging.\n   * @param options The options for the room.\n   * @param ongoingRelease The promise of an ongoing release operation.\n   * @returns A promise that resolves to a room.\n   */\n  private async _waitForReleaseAndCreateRoom(\n    name: string,\n    nonce: string,\n    options: RoomOptions | undefined,\n    ongoingRelease: Promise<void>,\n  ): Promise<Room> {\n    const abortController = new AbortController();\n    const roomPromise = this._createAbortableRoomPromise(name, nonce, options, ongoingRelease, abortController);\n\n    this._rooms.set(name, {\n      promise: roomPromise,\n      options: options,\n      nonce: nonce,\n      abort: abortController,\n    });\n\n    this._logger.debug('Rooms.get(); creating new promise dependent on previous release', { roomName: name });\n    return await roomPromise;\n  }\n\n  /**\n   * Creates a promise that can be aborted if the room is released before completion.\n   * @param name The unique identifier of the room.\n   * @param nonce A random, internal identifier useful for debugging and logging.\n   * @param options The options for the room.\n   * @param ongoingRelease A promise that resolves when the previous release operation is complete.\n   * @param abortController An AbortController to manage the abort signal.\n   * @returns A promise that resolves to a new room or rejects if the operation is aborted.\n   */\n  private async _createAbortableRoomPromise(\n    name: string,\n    nonce: string,\n    options: RoomOptions | undefined,\n    ongoingRelease: Promise<void>,\n    abortController: AbortController,\n  ): Promise<DefaultRoom> {\n    // Create a promise that rejects when the abort signal fires\n    const abortPromise = new Promise<never>((_, reject) => {\n      const abortListener = () => {\n        this._logger.debug('Rooms.get(); aborted before init', { roomName: name });\n        reject(\n          new Ably.ErrorInfo(\n            'unable to get room; room released before operation could complete',\n            ErrorCode.RoomReleasedBeforeOperationCompleted,\n            400,\n          ),\n        );\n      };\n\n      abortController.signal.addEventListener('abort', abortListener, { once: true });\n    });\n\n    // Race between the ongoing release and the abort signal\n    await Promise.race([ongoingRelease, abortPromise]);\n\n    // If we get here, the release completed without being aborted\n    this._logger.debug('Rooms.get(); releasing finished', { roomName: name });\n    const room = this._makeRoom(name, nonce, options);\n    return room;\n  }\n\n  /**\n   * Handles release when no room exists.\n   * @param name The unique identifier of the room.\n   * @param ongoingRelease An ongoing release promise, if any.\n   * @returns A promise that resolves when the release operation is complete.\n   */\n  private async _handleNonExistentRoomRelease(name: string, ongoingRelease?: Promise<void>): Promise<void> {\n    if (ongoingRelease) {\n      this._logger.debug('Rooms.release(); waiting for previous release call', { roomName: name });\n      await ongoingRelease;\n      return;\n    }\n\n    this._logger.debug('Rooms.release(); room does not exist', { roomName: name });\n  }\n\n  /**\n   * Handles release when there's already a release in progress.\n   * @param name The unique identifier of the room.\n   * @param existingRoom The existing room entry in the map.\n   * @param ongoingRelease The promise of an ongoing release operation.\n   */\n  private async _handleConcurrentRelease(\n    name: string,\n    existingRoom: RoomMapEntry,\n    ongoingRelease: Promise<void>,\n  ): Promise<void> {\n    if (existingRoom.abort) {\n      this._logger.debug('Rooms.release(); aborting get call', {\n        roomName: name,\n        existingNonce: existingRoom.nonce,\n      });\n      existingRoom.abort.abort();\n      this._rooms.delete(name);\n    }\n\n    await ongoingRelease;\n  }\n\n  /**\n   * Performs the actual room release operation.\n   * @param name The unique identifier of the room.\n   * @param existingRoom The existing room entry in the map.\n   */\n  private async _performRoomRelease(name: string, existingRoom: RoomMapEntry): Promise<void> {\n    this._rooms.delete(name);\n\n    const releasePromise = this._executeRoomRelease(name, existingRoom);\n    this._releasing.set(name, releasePromise);\n\n    this._logger.debug('Rooms.release(); creating new release promise', {\n      roomName: name,\n      nonce: existingRoom.nonce,\n    });\n\n    await releasePromise;\n  }\n\n  /**\n   * Executes the room release and cleanup.\n   * @param name The unique identifier of the room.\n   * @param existingRoom The existing room entry in the map.\n   */\n  private async _executeRoomRelease(name: string, existingRoom: RoomMapEntry): Promise<void> {\n    const room = await existingRoom.promise;\n    this._logger.debug('Rooms.release(); releasing room', { roomName: name, nonce: existingRoom.nonce });\n    await room.release();\n    this._logger.debug('Rooms.release(); room released', { roomName: name, nonce: existingRoom.nonce });\n    this._releasing.delete(name);\n  }\n\n  /**\n   * makes a new room object\n   * @param name The unique identifier of the room.\n   * @param nonce A random, internal identifier useful for debugging and logging.\n   * @param options The options for the room.\n   * @returns DefaultRoom A new room object.\n   */\n  private _makeRoom(name: string, nonce: string, options: RoomOptions | undefined): DefaultRoom {\n    return new DefaultRoom(\n      name,\n      nonce,\n      normalizeRoomOptions(options, this._isReact),\n      this._realtime,\n      this._chatApi,\n      this._clientIdResolver,\n      this._logger,\n    );\n  }\n\n  /**\n   * Sets react JS mode.\n   */\n  useReact(): void {\n    this._logger.trace('Rooms.useReact();');\n    this._isReact = true;\n  }\n}\n","import * as Ably from 'ably';\n\nimport { DefaultClientIdResolver } from './client-id.js';\nimport { ChatClientOptions, normalizeClientOptions, NormalizedChatClientOptions } from './config.js';\nimport { Connection, DefaultConnection, InternalConnection } from './connection.js';\nimport { randomId } from './id.js';\nimport { Logger, makeLogger } from './logger.js';\nimport { RealtimeWithOptions } from './realtime-extensions.js';\nimport { DefaultRooms, Rooms } from './rooms.js';\nimport { VERSION } from './version.js';\n\n/**\n * This is the core client for Ably chat. It provides access to chat rooms.\n */\nexport class ChatClient {\n  /**\n   * @internal\n   */\n  private readonly _realtime: Ably.Realtime;\n\n  /**\n   * @internal\n   */\n  private readonly _rooms: DefaultRooms;\n\n  /**\n   * @internal\n   */\n  private readonly _clientOptions: NormalizedChatClientOptions;\n\n  /**\n   * @internal\n   */\n  private readonly _connection: InternalConnection;\n\n  /**\n   * @internal\n   */\n  private readonly _logger: Logger;\n\n  /**\n   * @internal\n   */\n  private readonly _nonce: string;\n\n  /**\n   * @internal\n   */\n  private readonly _clientIdResolver: DefaultClientIdResolver;\n\n  /**\n   * Creates a new ChatClient instance for interacting with Ably Chat.\n   *\n   * The ChatClient is the main entry point for the Ably Chat SDK. It requires a Realtime client\n   * and provides access to chat rooms through the rooms property.\n   *\n   * **Important**: The Ably Realtime client must have a clientId set. This identifies\n   * the user in chat rooms and is required for all chat operations.\n   *\n   * **NOTE**: You can provide optional overrides to the {@link ChatClient}, these will be merged\n   * with the default options. See {@link ChatClientOptions} for the available options.\n   * @param realtime - An initialized Ably Realtime client with a configured clientId\n   * @param clientOptions - Optional configuration for the chat client\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient, LogLevel } from '@ably/chat';\n   *\n   * // Preferred in production: Use auth URL that returns a JWT\n   * const realtimeClientWithJWT = new Ably.Realtime({\n   *   authUrl: '/api/ably-auth', // Your server endpoint that returns a JWT with clientId\n   *   authMethod: 'POST'\n   * });\n   *\n   * const chatClient = new ChatClient(realtimeClientWithJWT)\n   *```\n   * @example\n   *```typescript\n   * // Alternative for development and server-side operations: Set clientId directly (requires API key)\n   * const realtimeClientWithKey = new Ably.Realtime({\n   *   key: 'your-ably-api-key',\n   *   clientId: 'user-123'\n   * });\n   *\n   * const chatClient = new ChatClient(realtimeClientWithKey)\n   * ```\n   * @example\n   * ```typescript\n   * const realtimeClient = new Ably.Realtime({\n   *   authUrl: '/api/ably-auth',\n   *   authMethod: 'POST'\n   * });\n   *\n   * // With custom logging configuration: Defaults to LogLevel.Info and console logging\n   * const chatClientWithLogging = new ChatClient(realtimeClient, {\n   *   logLevel: LogLevel.Debug,\n   *   logHandler: (message, level, context) => {\n   *     // Send to your logging service\n   *     yourLoggerInstance.log({\n   *       level,\n   *       message,\n   *       context,\n   *       timestamp: new Date()\n   *     });\n   *   }\n   * });\n   * ```\n   */\n  constructor(realtime: Ably.Realtime, clientOptions?: ChatClientOptions) {\n    this._realtime = realtime;\n    this._clientOptions = normalizeClientOptions(clientOptions);\n    this._nonce = randomId();\n    this._logger = makeLogger(this._clientOptions).withContext({\n      chatClientNonce: this._nonce,\n    });\n\n    this._connection = new DefaultConnection(realtime, this._logger);\n    this._clientIdResolver = new DefaultClientIdResolver(realtime, this._logger);\n    this._rooms = new DefaultRooms(realtime, this._clientIdResolver, this._logger);\n    this._addAgent('chat-js');\n    this._logger.trace(`ably chat client version ${VERSION}; initialized`);\n  }\n\n  /**\n   * Provides access to the rooms instance for creating and managing chat rooms.\n   * @returns The Rooms instance for managing chat rooms\n   * @example\n   * ```typescript\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Get a room with default options\n   * const room = await chatClient.rooms.get('general-chat');\n   *\n   * // Get a room with custom options (merges with defaults)\n   * const configuredRoom = await chatClient.rooms.get('team-chat', {\n   *   typing: { heartbeatThrottleMs: 1000 }\n   * });\n   *\n   * // Release a room when done\n   * await chatClient.rooms.release('general-chat');\n   * ```\n   */\n  get rooms(): Rooms {\n    return this._rooms;\n  }\n\n  /**\n   * Provides access to the underlying connection to Ably for monitoring connectivity.\n   * @returns The Connection instance\n   * @example\n   * ```typescript\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Check current connection status\n   * console.log('Status:', chatClient.connection.status);\n   * console.log('Error:', chatClient.connection.error);\n   *\n   * // Monitor connection changes\n   * const { off } = chatClient.connection.onStatusChange((change) => {\n   *   console.log(`Connection: ${change.previous} -> ${change.current}`);\n   * });\n   * ```\n   */\n  get connection(): Connection {\n    return this._connection;\n  }\n\n  /**\n   * Returns the clientId of the current client, if known.\n   *\n   * **Important** When using an Ably key for authentication, this value is determined immediately. If using a token,\n   * the clientId is not known until the client has successfully connected to and authenticated with\n   * the server. Use the `chatClient.connection.status` to check the connection status.\n   * @returns The clientId, or undefined if unknown.\n   */\n  get clientId(): string | undefined {\n    return this._realtime.auth.clientId;\n  }\n\n  /**\n   * Provides direct access to the underlying Ably Realtime client.\n   *\n   * Use this for advanced scenarios requiring direct Ably access. Most chat\n   * operations should use the high-level chat SDK methods instead.\n   *\n   * **Note**: Directly interacting with the Ably Realtime client can lead to\n   * unexpected behavior.\n   * @returns The underlying Ably Realtime client instance\n   */\n  get realtime(): Ably.Realtime {\n    return this._realtime;\n  }\n\n  /**\n   * The configuration options used to initialize the chat client.\n   * @returns The resolved client options including defaults\n   */\n  get clientOptions(): ChatClientOptions {\n    return this._clientOptions;\n  }\n\n  /**\n   * Returns the logger instance for the client.\n   * @internal\n   * @returns The logger instance.\n   */\n  get logger(): Logger {\n    return this._logger;\n  }\n\n  /**\n   * Adds additional agent information to the client.\n   * Used internally to add React-specific agent information.\n   * @internal\n   */\n  public addReactAgent(): void {\n    this._addAgent('chat-react');\n    this._rooms.useReact();\n  }\n\n  /**\n   * Adds additional agent information to the client.\n   * This is used internally to add a specific agent with a version.\n   * @param agent - The agent to add.\n   * @param version - The version of the agent, defaults to the current client version.\n   * @internal\n   */\n  public addAgentWithVersion(agent: string, version: string): void {\n    this._addAgent(agent, version);\n    this._logger.trace(`Added agent ${agent} with version ${version}`);\n  }\n\n  /**\n   * Disposes of the ChatClient instance and releases all resources.\n   *\n   * Releases all chat rooms, removes event listeners, and cleans up connections.\n   * After calling dispose, the ChatClient instance is no longer usable. This should\n   * be called when you're completely done with the chat functionality.\n   *\n   * **Note**: This will release ALL rooms managed by this ChatClient and the ChatClient cannot be reused after disposal.\n   * @returns Promise that resolves when all resources are released\n   * @example\n   * ```typescript\n   * import * as Ably from 'ably';\n   * import { ChatClient } from '@ably/chat';\n   *\n   * const chatClient: ChatClient; // existing ChatClient instance\n   *\n   * // Use the chat client\n   * const roomOne = await chatClient.rooms.get('general-chat');\n   * const roomTwo = await chatClient.rooms.get('random-chat');\n   *\n   * // ... chat operations ...\n   *\n   * // Clean up when completely done\n   * try {\n   *   await chatClient.dispose();\n   *   console.log('Chat client disposed successfully');\n   * } catch (error) {\n   *   console.error('Failed to dispose chat client:', error);\n   * }\n   *\n   * ```\n   */\n  async dispose(): Promise<void> {\n    this._logger.trace('ChatClient.dispose();');\n\n    // Release all rooms before disposing\n    await this._rooms.dispose();\n\n    // Dispose of the connection instance\n    this._connection.dispose();\n\n    this._logger.debug('ChatClient.dispose(); client disposed successfully');\n  }\n\n  /**\n   * Sets the agent string for the client.\n   * @param agent - The agent to add.\n   * @param version - The version of the agent, defaults to the current client version.\n   * @internal\n   */\n  private _addAgent(agent: string, version?: string): void {\n    const realtime = this._realtime as RealtimeWithOptions;\n    realtime.options.agents = { ...(realtime.options.agents ?? realtime.options.agents), [agent]: version ?? VERSION };\n  }\n}\n"],"names":["ErrorCode","errorInfoIs","errorInfo","error","DefaultClientIdResolver","_realtime","_logger","clientId","Ably","LogLevel","consoleLogger","message","level","context","contextString","formattedMessage","makeLogger","options","logHandler","DefaultLogger","logLevelNumberMap","handler","levelNumber","originalLevel","value","defaultClientOptions","normalizeClientOptions","on","emitter","arg2","arg3","once","subscribe","subscribePromise","InternalEventEmitter","EventEmitter","wrap","fn","args","emitterHasListeners","destructured","numListeners","ConnectionStatus","DefaultConnection","ably","logger","connectionListener","change","chatState","stateChange","listener","wrapped","status","randomId","has","find","iter","tar","key","dequal","foo","bar","ctor","len","tmp","ChatMessageEventType","RealtimeMessageName","RealtimeMetaEventType","ChatMessageAction","PresenceEventType","TypingEventType","TypingSetEventType","RoomReactionRealtimeEventType","RoomReactionEventType","MessageReactionType","ReactionAnnotationType","AnnotationTypeToReactionType","MessageReactionRawEventType","MessageReactionSummaryEventType","OccupancyEventType","RoomEventType","LARGE_ARRAY_SIZE","HASH_UNDEFINED","MAX_SAFE_INTEGER","argsTag","arrayTag","boolTag","dateTag","errorTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reRegExpChar","reFlags","reIsHostCtor","reIsUint","cloneableTags","freeGlobal","global","freeSelf","root","freeExports","exports","freeModule","module","moduleExports","addMapEntry","map","pair","addSetEntry","set","arrayEach","array","iteratee","index","length","arrayPush","values","offset","arrayReduce","accumulator","initAccum","baseTimes","n","result","getValue","object","isHostObject","mapToArray","overArg","func","transform","arg","setToArray","arrayProto","funcProto","objectProto","coreJsData","maskSrcKey","uid","funcToString","hasOwnProperty","objectToString","reIsNative","Buffer","Symbol","Uint8Array","getPrototype","objectCreate","propertyIsEnumerable","splice","nativeGetSymbols","nativeIsBuffer","nativeKeys","DataView","getNative","Map","Promise","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","Hash","entries","entry","hashClear","hashDelete","hashGet","data","hashHas","hashSet","ListCache","listCacheClear","listCacheDelete","assocIndexOf","lastIndex","listCacheGet","listCacheHas","listCacheSet","MapCache","mapCacheClear","mapCacheDelete","getMapData","mapCacheGet","mapCacheHas","mapCacheSet","Stack","stackClear","stackDelete","stackGet","stackHas","stackSet","cache","pairs","arrayLikeKeys","inherited","isArray","isArguments","skipIndexes","isIndex","assignValue","objValue","eq","baseAssign","source","copyObject","keys","baseClone","isDeep","isFull","customizer","stack","isObject","isArr","initCloneArray","copyArray","tag","getTag","isFunc","isBuffer","cloneBuffer","initCloneObject","copySymbols","initCloneByTag","stacked","props","getAllKeys","subValue","baseCreate","proto","baseGetAllKeys","keysFunc","symbolsFunc","baseGetTag","baseIsNative","isMasked","pattern","isFunction","baseKeys","isPrototype","buffer","cloneArrayBuffer","arrayBuffer","cloneDataView","dataView","cloneMap","cloneFunc","cloneRegExp","regexp","cloneSet","cloneSymbol","symbol","cloneTypedArray","typedArray","newValue","getSymbols","isKeyable","stubArray","Ctor","ctorString","type","cloneDeep","other","isArrayLikeObject","isArrayLike","isLength","isObjectLike","stubFalse","DefaultMessage","serial","text","metadata","headers","userClaim","action","version","timestamp","reactions","event","newReactions","replace","params","emptyMessageReactions","realtimeExtras","extras","raw","parseMessage","inboundMessage","assertValidSerial","op","paramName","eventTypeMap","DefaultMessageReactions","_options","_api","_roomName","_channel","reactionType","eventType","name","reactionEvent","summary","unique","distinct","multiple","messageSerial","count","apiParams","roomOptions","messageFromRest","reactionTypeData","reactionName","reaction","multipleReactions","MessageActionsToEventsMap","OrderBy","DefaultMessages","roomName","channel","chatApi","messageEventsListener","channelAttachedListener","channelUpdateListener","subscriptionPoint","subscriptionPointParams","fromResume","newSubscriptionStartResolver","channelWithProperties","resolve","reject","cleanup","offAttachedListener","response","details","updateParams","resolvedSubscriptionStart","channelEventMessage","disposalError","rejectFn","ChatApi","realtime","payload","nextData","firstData","currentData","restMessage","body","url","method","suffix","roomChannelName","VERSION","CHANNEL_OPTIONS_AGENT_STRING","CHANNEL_OPTIONS_AGENT_STRING_REACT","DEFAULT_CHANNEL_MODES","DEFAULT_CHANNEL_OPTIONS","DEFAULT_CHANNEL_OPTIONS_REACT","ChannelManager","isReact","merger","baseOptions","parseOccupancyMessage","connections","presenceMembers","metrics","DefaultOccupancy","occupancyEventsListener","DefaultPresence","member","presenceEventsListener","channelDetachListener","user","present","previous","E_CANCELED","__awaiter$2","thisArg","_arguments","P","generator","adopt","fulfilled","step","e","rejected","Semaphore","_value","_cancelError","weight","priority","task","i","findIndexFromEnd","callback_1","callback","release","insertSorted","item","previousValue","called","waiters","waiter","queuedPriority","a","v","predicate","__awaiter$1","Mutex","cancelError","releaser","RoomStatus","DefaultRoomLifecycle","RoomLifecycleManager","channelManager","roomLifecycle","channelStateListener","discontinuityOnAttachedListener","discontinuityOnUpdateListener","errInfo","attachError","newStatus","detachError","channelState","firstAttach","DefaultRoomOptions","invalidRoomConfiguration","reason","validateRoomOptions","validateTypingOptions","normalizeTypingOptions","normalizeOccupancyOptions","normalizePresenceOptions","normalizeMessagesOptions","normalizeRoomOptions","react","ephemeralMessage","messageToEphemeral","DefaultRoomReaction","createdAt","isSelf","parseRoomReaction","reactionCreatedMessage","messageClientId","DefaultRoomReactions","connection","clientIdResolver","inbound","roomReactionEventsListener","realtimeMessage","DefaultTyping","state","timer","timeoutId","clientState","timedOutUserClaim","existingState","DefaultRoom","nonce","finalized","manager","DefaultRooms","existingRoom","ongoingRelease","roomNames","releasePromises","inFlight","all","room","abortController","roomPromise","abortPromise","_","abortListener","releasePromise","ChatClient","clientOptions","agent"],"mappings":"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","x_google_ignoreList":[8,10,25]}