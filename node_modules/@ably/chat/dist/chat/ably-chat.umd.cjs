(function(y,X){typeof exports=="object"&&typeof module<"u"?X(exports,require("ably")):typeof define=="function"&&define.amd?define(["exports","ably"],X):(y=typeof globalThis<"u"?globalThis:y||self,X(y.AblyChat={},y.Ably))})(this,(function(y,X){"use strict";function Ft(n){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(n){for(const t in n)if(t!=="default"){const r=Object.getOwnPropertyDescriptor(n,t);Object.defineProperty(e,t,r.get?r:{enumerable:!0,get:()=>n[t]})}}return e.default=n,Object.freeze(e)}const g=Ft(X);var d=(n=>(n[n.BadRequest=4e4]="BadRequest",n[n.InvalidArgument=40003]="InvalidArgument",n[n.InvalidClientId=40012]="InvalidClientId",n[n.ResourceDisposed=40014]="ResourceDisposed",n[n.MessageRejectedByBeforePublishRule=42211]="MessageRejectedByBeforePublishRule",n[n.MessageRejectedByModeration=42213]="MessageRejectedByModeration",n[n.Disconnected=80003]="Disconnected",n[n.PresenceAutoReentryFailed=91004]="PresenceAutoReentryFailed",n[n.RoomDiscontinuity=102100]="RoomDiscontinuity",n[n.RoomInInvalidState=102112]="RoomInInvalidState",n[n.RoomReleasedBeforeOperationCompleted=102106]="RoomReleasedBeforeOperationCompleted",n[n.RoomExistsWithDifferentOptions=102107]="RoomExistsWithDifferentOptions",n[n.FeatureNotEnabledInRoom=102108]="FeatureNotEnabledInRoom",n[n.ListenerNotSubscribed=102109]="ListenerNotSubscribed",n[n.ChannelSerialNotDefined=102110]="ChannelSerialNotDefined",n[n.ChannelOptionsCannotBeModified=102111]="ChannelOptionsCannotBeModified",n[n.OperationSerializationFailed=102113]="OperationSerializationFailed",n[n.ReactHookMustBeUsedWithinProvider=102200]="ReactHookMustBeUsedWithinProvider",n[n.ReactComponentUnmounted=102201]="ReactComponentUnmounted",n[n.PresenceFetchFailed=102202]="PresenceFetchFailed",n))(d||{});const Bt=(n,e)=>n.code===e;class $t{constructor(e,t){this._realtime=e,this._logger=t}get(){const e=this._realtime.auth.clientId;if(!e)throw this._logger.error("unable to get client id; client id is not set",{clientId:e}),new g.ErrorInfo("unable to get client id; client id is not set",d.InvalidClientId,400);return e}}var we=(n=>(n.Trace="trace",n.Debug="debug",n.Info="info",n.Warn="warn",n.Error="error",n.Silent="silent",n))(we||{});const Ht=(n,e,t)=>{const r=t?`, context: ${JSON.stringify(t)}`:"",i=`[${new Date().toISOString()}] ${e.valueOf().toUpperCase()} ably-chat: ${n}${r}`;switch(e){case"trace":case"debug":{console.log(i);break}case"info":{console.info(i);break}case"warn":{console.warn(i);break}case"error":{console.error(i);break}}},Wt=n=>{const e=n.logHandler??Ht;return new ve(e,n.logLevel)},ke=new Map([["trace",0],["debug",1],["info",2],["warn",3],["error",4],["silent",5]]);class ve{constructor(e,t,r){this._handler=e,this._context=r;const i=ke.get(t);if(i===void 0)throw new g.ErrorInfo(`unable to create logger; invalid log level: ${t}`,d.InvalidArgument,400);this._levelNumber=i}trace(e,t){this._write(e,"trace",0,t)}debug(e,t){this._write(e,"debug",1,t)}info(e,t){this._write(e,"info",2,t)}warn(e,t){this._write(e,"warn",3,t)}error(e,t){this._write(e,"error",4,t)}withContext(e){const t=[...ke.entries()].find(([,r])=>r===this._levelNumber)?.[0]??"error";return new ve(this._handler,t,this._mergeContext(e))}_write(e,t,r,i){r>=this._levelNumber&&this._handler(e,t,this._mergeContext(i))}_mergeContext(e){return this._context?e?{...this._context,...e}:this._context:e??void 0}}const Gt={logLevel:we.Error},Vt=n=>(n=n??{},{...n,logLevel:n.logLevel??Gt.logLevel});function L(n,e,t){if((Array.isArray(e)||typeof e=="string")&&t)return n.on(e,t),()=>{n.off(t)};if(typeof e=="function")return n.on(e),()=>{n.off(e)};throw new TypeError("Invalid arguments passed to on()")}function Kt(n,e,t){if(t)return n.once(e,t),()=>{n.off(t)};throw new TypeError("Invalid arguments passed to once()")}function U(n,e,t){if((Array.isArray(e)||typeof e=="string")&&t){const r=n.subscribe(e,t);return()=>{r.then(()=>{n.unsubscribe(t)}).catch(i=>{console.error("Error subscribing to events:",i)})}}else if(typeof e=="function"){const r=n.subscribe(e);return()=>{r.then(()=>{n.unsubscribe(e)}).catch(i=>{console.error("Error subscribing to events:",i)})}}else throw new TypeError("Invalid arguments passed to subscribe()")}const Qt=g.Realtime.EventEmitter;class M extends Qt{}const C=n=>(...e)=>n(...e),P=n=>{const e=n,t=Object.values(e.events).flat().length+e.any.length+Object.values(e.eventsOnce).flat().length+e.anyOnce.length;return t?t>0:!1};var Ue=(n=>(n.Initialized="initialized",n.Connecting="connecting",n.Connected="connected",n.Disconnected="disconnected",n.Suspended="suspended",n.Failed="failed",n.Closing="closing",n.Closed="closed",n))(Ue||{});class Jt{constructor(e,t){this._status="initialized",this._emitter=new M,this._logger=t,this._status=this._mapAblyStatusToChat(e.connection.state),this._error=e.connection.errorReason;const r=i=>{const c=this._mapAblyStatusToChat(i.current);if(c===this._status)return;const l={current:c,previous:this._status,error:i.reason,retryIn:i.retryIn};this._applyStatusChange(l)};this._clearAblyConnectionListener=L(e.connection,r)}get status(){return this._status}get error(){return this._error}onStatusChange(e){const t=C(e);return this._emitter.on(t),{off:()=>{this._emitter.off(t)}}}dispose(){this._logger.trace("DefaultConnection.dispose();"),this._clearAblyConnectionListener(),this._emitter.off()}hasListeners(){return P(this._emitter)}_applyStatusChange(e){this._status=e.current,this._error=e.error,this._logger.info("Connection state changed",e),this._emitter.emit(e.current,e)}_mapAblyStatusToChat(e){switch(e){case"initialized":return"initialized";case"connecting":return"connecting";case"connected":return"connected";case"disconnected":return"disconnected";case"suspended":return"suspended";case"closing":return"closing";case"closed":return"closed";case"failed":return"failed";default:return this._logger.error("DefaultConnection._mapAblyStatusToChat(); unknown connection state",{status:e}),"failed"}}}const qe=()=>Math.random().toString(36).slice(2);var ze=Object.prototype.hasOwnProperty;function Fe(n,e,t){for(t of n.keys())if(Y(t,e))return t}function Y(n,e){var t,r,i;if(n===e)return!0;if(n&&e&&(t=n.constructor)===e.constructor){if(t===Date)return n.getTime()===e.getTime();if(t===RegExp)return n.toString()===e.toString();if(t===Array){if((r=n.length)===e.length)for(;r--&&Y(n[r],e[r]););return r===-1}if(t===Set){if(n.size!==e.size)return!1;for(r of n)if(i=r,i&&typeof i=="object"&&(i=Fe(e,i),!i)||!e.has(i))return!1;return!0}if(t===Map){if(n.size!==e.size)return!1;for(r of n)if(i=r[0],i&&typeof i=="object"&&(i=Fe(e,i),!i)||!Y(r[1],e.get(i)))return!1;return!0}if(t===ArrayBuffer)n=new Uint8Array(n),e=new Uint8Array(e);else if(t===DataView){if((r=n.byteLength)===e.byteLength)for(;r--&&n.getInt8(r)===e.getInt8(r););return r===-1}if(ArrayBuffer.isView(n)){if((r=n.byteLength)===e.byteLength)for(;r--&&n[r]===e[r];);return r===-1}if(!t||typeof n=="object"){r=0;for(t in n)if(ze.call(n,t)&&++r&&!ze.call(e,t)||!(t in e)||!Y(n[t],e[t]))return!1;return Object.keys(e).length===r}}return n!==n&&e!==e}var A=(n=>(n.Created="message.created",n.Updated="message.updated",n.Deleted="message.deleted",n))(A||{}),Be=(n=>(n.ChatMessage="chat.message",n))(Be||{}),$e=(n=>(n.Occupancy="[meta]occupancy",n))($e||{}),I=(n=>(n.MessageCreate="message.create",n.MessageUpdate="message.update",n.MessageDelete="message.delete",n))(I||{}),He=(n=>(n.Enter="enter",n.Leave="leave",n.Update="update",n.Present="present",n))(He||{}),R=(n=>(n.Started="typing.started",n.Stopped="typing.stopped",n))(R||{}),x=(n=>(n.SetChanged="typing.set.changed",n))(x||{}),Se=(n=>(n.Reaction="roomReaction",n))(Se||{}),Re=(n=>(n.Reaction="reaction",n))(Re||{}),N=(n=>(n.Unique="unique",n.Distinct="distinct",n.Multiple="multiple",n))(N||{}),ie=(n=>(n.Unique="reaction:unique.v1",n.Distinct="reaction:distinct.v1",n.Multiple="reaction:multiple.v1",n))(ie||{});const Xt={"reaction:unique.v1":"unique","reaction:distinct.v1":"distinct","reaction:multiple.v1":"multiple"};var q=(n=>(n.Create="reaction.create",n.Delete="reaction.delete",n))(q||{}),H=(n=>(n.Summary="reaction.summary",n))(H||{}),ae=(n=>(n.Updated="occupancy.updated",n))(ae||{}),W=(n=>(n.Discontinuity="room.discontinuity",n))(W||{}),oe=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Yt(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var Z={exports:{}};Z.exports;var We;function Zt(){return We||(We=1,(function(n,e){var t=200,r="__lodash_hash_undefined__",i=9007199254740991,c="[object Arguments]",l="[object Array]",u="[object Boolean]",b="[object Date]",_="[object Error]",f="[object Function]",T="[object GeneratorFunction]",G="[object Map]",tt="[object Number]",Te="[object Object]",nt="[object Promise]",st="[object RegExp]",ge="[object Set]",rt="[object String]",it="[object Symbol]",Ce="[object WeakMap]",at="[object ArrayBuffer]",de="[object DataView]",ot="[object Float32Array]",ct="[object Float64Array]",lt="[object Int8Array]",ht="[object Int16Array]",ut="[object Int32Array]",gt="[object Uint8Array]",dt="[object Uint8ClampedArray]",_t="[object Uint16Array]",ft="[object Uint32Array]",Nn=/[\\^$.*+?()[\]{}|]/g,jn=/\w*$/,kn=/^\[object .+?Constructor\]$/,Un=/^(?:0|[1-9]\d*)$/,p={};p[c]=p[l]=p[at]=p[de]=p[u]=p[b]=p[ot]=p[ct]=p[lt]=p[ht]=p[ut]=p[G]=p[tt]=p[Te]=p[st]=p[ge]=p[rt]=p[it]=p[gt]=p[dt]=p[_t]=p[ft]=!0,p[_]=p[f]=p[Ce]=!1;var qn=typeof oe=="object"&&oe&&oe.Object===Object&&oe,zn=typeof self=="object"&&self&&self.Object===Object&&self,O=qn||zn||Function("return this")(),pt=e&&!e.nodeType&&e,mt=pt&&!0&&n&&!n.nodeType&&n,Fn=mt&&mt.exports===pt;function Bn(s,a){return s.set(a[0],a[1]),s}function $n(s,a){return s.add(a),s}function Hn(s,a){for(var o=-1,h=s?s.length:0;++o<h&&a(s[o],o,s)!==!1;);return s}function Wn(s,a){for(var o=-1,h=a.length,w=s.length;++o<h;)s[w+o]=a[o];return s}function yt(s,a,o,h){for(var w=-1,v=s?s.length:0;++w<v;)o=a(o,s[w],w,s);return o}function Gn(s,a){for(var o=-1,h=Array(s);++o<s;)h[o]=a(o);return h}function Vn(s,a){return s?.[a]}function bt(s){var a=!1;if(s!=null&&typeof s.toString!="function")try{a=!!(s+"")}catch{}return a}function wt(s){var a=-1,o=Array(s.size);return s.forEach(function(h,w){o[++a]=[w,h]}),o}function Me(s,a){return function(o){return s(a(o))}}function vt(s){var a=-1,o=Array(s.size);return s.forEach(function(h){o[++a]=h}),o}var Kn=Array.prototype,Qn=Function.prototype,_e=Object.prototype,Ae=O["__core-js_shared__"],St=(function(){var s=/[^.]+$/.exec(Ae&&Ae.keys&&Ae.keys.IE_PROTO||"");return s?"Symbol(src)_1."+s:""})(),Rt=Qn.toString,k=_e.hasOwnProperty,fe=_e.toString,Jn=RegExp("^"+Rt.call(k).replace(Nn,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Tt=Fn?O.Buffer:void 0,Ct=O.Symbol,Mt=O.Uint8Array,Xn=Me(Object.getPrototypeOf,Object),Yn=Object.create,Zn=_e.propertyIsEnumerable,es=Kn.splice,At=Object.getOwnPropertySymbols,ts=Tt?Tt.isBuffer:void 0,ns=Me(Object.keys,Object),Ie=Q(O,"DataView"),se=Q(O,"Map"),Oe=Q(O,"Promise"),Ee=Q(O,"Set"),De=Q(O,"WeakMap"),re=Q(Object,"create"),ss=$(Ie),rs=$(se),is=$(Oe),as=$(Ee),os=$(De),It=Ct?Ct.prototype:void 0,Ot=It?It.valueOf:void 0;function F(s){var a=-1,o=s?s.length:0;for(this.clear();++a<o;){var h=s[a];this.set(h[0],h[1])}}function cs(){this.__data__=re?re(null):{}}function ls(s){return this.has(s)&&delete this.__data__[s]}function hs(s){var a=this.__data__;if(re){var o=a[s];return o===r?void 0:o}return k.call(a,s)?a[s]:void 0}function us(s){var a=this.__data__;return re?a[s]!==void 0:k.call(a,s)}function gs(s,a){var o=this.__data__;return o[s]=re&&a===void 0?r:a,this}F.prototype.clear=cs,F.prototype.delete=ls,F.prototype.get=hs,F.prototype.has=us,F.prototype.set=gs;function E(s){var a=-1,o=s?s.length:0;for(this.clear();++a<o;){var h=s[a];this.set(h[0],h[1])}}function ds(){this.__data__=[]}function _s(s){var a=this.__data__,o=pe(a,s);if(o<0)return!1;var h=a.length-1;return o==h?a.pop():es.call(a,o,1),!0}function fs(s){var a=this.__data__,o=pe(a,s);return o<0?void 0:a[o][1]}function ps(s){return pe(this.__data__,s)>-1}function ms(s,a){var o=this.__data__,h=pe(o,s);return h<0?o.push([s,a]):o[h][1]=a,this}E.prototype.clear=ds,E.prototype.delete=_s,E.prototype.get=fs,E.prototype.has=ps,E.prototype.set=ms;function V(s){var a=-1,o=s?s.length:0;for(this.clear();++a<o;){var h=s[a];this.set(h[0],h[1])}}function ys(){this.__data__={hash:new F,map:new(se||E),string:new F}}function bs(s){return me(this,s).delete(s)}function ws(s){return me(this,s).get(s)}function vs(s){return me(this,s).has(s)}function Ss(s,a){return me(this,s).set(s,a),this}V.prototype.clear=ys,V.prototype.delete=bs,V.prototype.get=ws,V.prototype.has=vs,V.prototype.set=Ss;function K(s){this.__data__=new E(s)}function Rs(){this.__data__=new E}function Ts(s){return this.__data__.delete(s)}function Cs(s){return this.__data__.get(s)}function Ms(s){return this.__data__.has(s)}function As(s,a){var o=this.__data__;if(o instanceof E){var h=o.__data__;if(!se||h.length<t-1)return h.push([s,a]),this;o=this.__data__=new V(h)}return o.set(s,a),this}K.prototype.clear=Rs,K.prototype.delete=Ts,K.prototype.get=Cs,K.prototype.has=Ms,K.prototype.set=As;function Is(s,a){var o=xe(s)||Ys(s)?Gn(s.length,String):[],h=o.length,w=!!h;for(var v in s)k.call(s,v)&&!(w&&(v=="length"||Ks(v,h)))&&o.push(v);return o}function Et(s,a,o){var h=s[a];(!(k.call(s,a)&&xt(h,o))||o===void 0&&!(a in s))&&(s[a]=o)}function pe(s,a){for(var o=s.length;o--;)if(xt(s[o][0],a))return o;return-1}function Os(s,a){return s&&Dt(a,Ne(a),s)}function Le(s,a,o,h,w,v,D){var S;if(h&&(S=v?h(s,w,v,D):h(s)),S!==void 0)return S;if(!ye(s))return s;var kt=xe(s);if(kt){if(S=Ws(s),!a)return Bs(s,S)}else{var J=B(s),Ut=J==f||J==T;if(er(s))return Ns(s,a);if(J==Te||J==c||Ut&&!v){if(bt(s))return v?s:{};if(S=Gs(Ut?{}:s),!a)return $s(s,Os(S,s))}else{if(!p[J])return v?s:{};S=Vs(s,J,Le,a)}}D||(D=new K);var qt=D.get(s);if(qt)return qt;if(D.set(s,S),!kt)var zt=o?Hs(s):Ne(s);return Hn(zt||s,function(je,be){zt&&(be=je,je=s[be]),Et(S,be,Le(je,a,o,h,be,s,D))}),S}function Es(s){return ye(s)?Yn(s):{}}function Ds(s,a,o){var h=a(s);return xe(s)?h:Wn(h,o(s))}function Ls(s){return fe.call(s)}function Ps(s){if(!ye(s)||Js(s))return!1;var a=jt(s)||bt(s)?Jn:kn;return a.test($(s))}function xs(s){if(!Pt(s))return ns(s);var a=[];for(var o in Object(s))k.call(s,o)&&o!="constructor"&&a.push(o);return a}function Ns(s,a){if(a)return s.slice();var o=new s.constructor(s.length);return s.copy(o),o}function Pe(s){var a=new s.constructor(s.byteLength);return new Mt(a).set(new Mt(s)),a}function js(s,a){var o=a?Pe(s.buffer):s.buffer;return new s.constructor(o,s.byteOffset,s.byteLength)}function ks(s,a,o){var h=a?o(wt(s),!0):wt(s);return yt(h,Bn,new s.constructor)}function Us(s){var a=new s.constructor(s.source,jn.exec(s));return a.lastIndex=s.lastIndex,a}function qs(s,a,o){var h=a?o(vt(s),!0):vt(s);return yt(h,$n,new s.constructor)}function zs(s){return Ot?Object(Ot.call(s)):{}}function Fs(s,a){var o=a?Pe(s.buffer):s.buffer;return new s.constructor(o,s.byteOffset,s.length)}function Bs(s,a){var o=-1,h=s.length;for(a||(a=Array(h));++o<h;)a[o]=s[o];return a}function Dt(s,a,o,h){o||(o={});for(var w=-1,v=a.length;++w<v;){var D=a[w],S=void 0;Et(o,D,S===void 0?s[D]:S)}return o}function $s(s,a){return Dt(s,Lt(s),a)}function Hs(s){return Ds(s,Ne,Lt)}function me(s,a){var o=s.__data__;return Qs(a)?o[typeof a=="string"?"string":"hash"]:o.map}function Q(s,a){var o=Vn(s,a);return Ps(o)?o:void 0}var Lt=At?Me(At,Object):sr,B=Ls;(Ie&&B(new Ie(new ArrayBuffer(1)))!=de||se&&B(new se)!=G||Oe&&B(Oe.resolve())!=nt||Ee&&B(new Ee)!=ge||De&&B(new De)!=Ce)&&(B=function(s){var a=fe.call(s),o=a==Te?s.constructor:void 0,h=o?$(o):void 0;if(h)switch(h){case ss:return de;case rs:return G;case is:return nt;case as:return ge;case os:return Ce}return a});function Ws(s){var a=s.length,o=s.constructor(a);return a&&typeof s[0]=="string"&&k.call(s,"index")&&(o.index=s.index,o.input=s.input),o}function Gs(s){return typeof s.constructor=="function"&&!Pt(s)?Es(Xn(s)):{}}function Vs(s,a,o,h){var w=s.constructor;switch(a){case at:return Pe(s);case u:case b:return new w(+s);case de:return js(s,h);case ot:case ct:case lt:case ht:case ut:case gt:case dt:case _t:case ft:return Fs(s,h);case G:return ks(s,h,o);case tt:case rt:return new w(s);case st:return Us(s);case ge:return qs(s,h,o);case it:return zs(s)}}function Ks(s,a){return a=a??i,!!a&&(typeof s=="number"||Un.test(s))&&s>-1&&s%1==0&&s<a}function Qs(s){var a=typeof s;return a=="string"||a=="number"||a=="symbol"||a=="boolean"?s!=="__proto__":s===null}function Js(s){return!!St&&St in s}function Pt(s){var a=s&&s.constructor,o=typeof a=="function"&&a.prototype||_e;return s===o}function $(s){if(s!=null){try{return Rt.call(s)}catch{}try{return s+""}catch{}}return""}function Xs(s){return Le(s,!0,!0)}function xt(s,a){return s===a||s!==s&&a!==a}function Ys(s){return Zs(s)&&k.call(s,"callee")&&(!Zn.call(s,"callee")||fe.call(s)==c)}var xe=Array.isArray;function Nt(s){return s!=null&&tr(s.length)&&!jt(s)}function Zs(s){return nr(s)&&Nt(s)}var er=ts||rr;function jt(s){var a=ye(s)?fe.call(s):"";return a==f||a==T}function tr(s){return typeof s=="number"&&s>-1&&s%1==0&&s<=i}function ye(s){var a=typeof s;return!!s&&(a=="object"||a=="function")}function nr(s){return!!s&&typeof s=="object"}function Ne(s){return Nt(s)?Is(s):xs(s)}function sr(){return[]}function rr(){return!1}n.exports=Xs})(Z,Z.exports)),Z.exports}var en=Zt();const j=Yt(en);class z{constructor({serial:e,clientId:t,text:r,metadata:i,headers:c,userClaim:l,action:u,version:b,timestamp:_,reactions:f}){this.serial=e,this.clientId=t,this.text=r,this.metadata=i,this.headers=c,this.userClaim=l,this.action=u,this.version=b,this.timestamp=_,this.reactions=f,Object.freeze(this.version),Object.freeze(this.reactions),Object.freeze(this.reactions.multiple),Object.freeze(this.reactions.distinct),Object.freeze(this.reactions.unique),Object.freeze(this)}with(e){if("serial"in e)return this._getLatestMessageVersion(e);if(e.type===A.Created)throw new g.ErrorInfo("unable to apply message event; unable to apply created event to existing message",d.InvalidArgument,400);if(e.type===H.Summary){if(e.messageSerial!==this.serial)throw new g.ErrorInfo("unable to apply message event; event is for a different message",d.InvalidArgument,400);const t={unique:j(e.reactions.unique),distinct:j(e.reactions.distinct),multiple:j(e.reactions.multiple)};return z._clone(this,{reactions:t})}return this._getLatestMessageVersion(e.message)}_getLatestMessageVersion(e){if(e.serial!==this.serial)throw new g.ErrorInfo("unable to apply message event; event is for a different message",d.InvalidArgument,400);return this.version.serial>=e.version.serial?this:z._clone(e,{reactions:this.reactions})}static _clone(e,t){return new z({serial:t?.serial??e.serial,clientId:t?.clientId??e.clientId,text:t?.text??e.text,metadata:t?.metadata??j(e.metadata),headers:t?.headers??j(e.headers),userClaim:t?.userClaim??e.userClaim,action:t?.action??e.action,version:t?.version??j(e.version),timestamp:t?.timestamp??e.timestamp,reactions:t?.reactions??j(e.reactions)})}copy(e={}){return z._clone(this,e)}}const Ge=()=>({unique:{},distinct:{},multiple:{}}),ee=n=>{if(!n||typeof n!="object")return{};const e=n,t={};return e.headers&&typeof e.headers=="object"&&(t.headers=e.headers),typeof e.userClaim=="string"&&(t.userClaim=e.userClaim),t},tn=n=>{const e=n,t=e.data&&typeof e.data=="object"?e.data:{},r=ee(n.extras),i=e.clientId||"",c=t.text||"",l=new Date(e.timestamp||0),u=e.serial||"",b=t.metadata&&typeof t.metadata=="object"?t.metadata:{},_=r.headers||{},f=r.userClaim,T={...e.version,serial:e.version.serial||u,timestamp:new Date(e.version.timestamp||l)},G=Object.values(I).includes(e.action)?e.action:I.MessageCreate;return new z({serial:u,clientId:i,text:c,metadata:b,headers:_,userClaim:f,action:G,version:T,timestamp:l,reactions:Ge()})},te=(n,e,t)=>{if(!n)throw new g.ErrorInfo(`unable to ${e}; ${t} must be a non-empty string`,d.InvalidArgument,400)},nn={"annotation.create":q.Create,"annotation.delete":q.Delete};class Ve{constructor(e,t,r,i,c){this._logger=e,this._options=t,this._api=r,this._roomName=i,this._channel=c,this._emitter=new M,this._unsubscribeMessageEvents=U(c,this._processMessageEvent.bind(this)),this._options?.rawMessageReactions&&(this._unsubscribeAnnotationEvents=U(c.annotations,this._processAnnotationEvent.bind(this))),this._defaultType=this._options?.defaultMessageReactionType??N.Distinct}_processAnnotationEvent(e){this._logger.trace("MessageReactions._processAnnotationEvent();",{event:e});const t=Xt[e.type];if(!t){this._logger.info("MessageReactions._processAnnotationEvent(); ignoring unknown reaction type",{event:e});return}const r=nn[e.action];if(!r){this._logger.info("MessageReactions._processAnnotationEvent(); ignoring unknown reaction event type",{event:e});return}const i=e.name??"",c=ee(e.extras),l={type:r,timestamp:new Date(e.timestamp),reaction:{messageSerial:e.messageSerial,type:t,name:i,clientId:e.clientId??"",userClaim:c.userClaim}};e.count?l.reaction.count=e.count:r===q.Create&&t===N.Multiple&&(l.reaction.count=1),this._emitter.emit(r,l)}_processMessageEvent(e){if(this._logger.trace("MessageReactions._processMessageEvent();",{event:e}),e.action!=="message.summary")return;const t=e.serial,r=e.annotations.summary,i=r[ie.Unique]??{},c=r[ie.Distinct]??{},l=r[ie.Multiple]??{};this._emitter.emit(H.Summary,{type:H.Summary,messageSerial:t,reactions:{unique:i,distinct:c,multiple:l}})}async send(e,t){this._logger.trace("MessageReactions.send();",{messageSerial:e,params:t}),te(e,"send message reaction","messageSerial");let{type:r,count:i}=t;r||(r=this._defaultType),r===N.Multiple&&!i&&(i=1);const c={type:r,name:t.name};return i&&(c.count=i),this._api.sendMessageReaction(this._roomName,e,c)}async delete(e,t){this._logger.trace("MessageReactions.delete();",{messageSerial:e,params:t}),te(e,"delete message reaction","messageSerial");let r=t?.type;if(r||(r=this._defaultType),r!==N.Unique&&!t?.name)throw new g.ErrorInfo(`unable to delete reaction of type ${r}; name not specified`,d.InvalidArgument,400);const i={type:r};return r!==N.Unique&&(i.name=t?.name),this._api.deleteMessageReaction(this._roomName,e,i)}subscribe(e){this._logger.trace("MessageReactions.subscribe();");const t=C(e);return this._emitter.on(H.Summary,t),{unsubscribe:()=>{this._emitter.off(t)}}}subscribeRaw(e){if(this._logger.trace("MessageReactions.subscribeRaw();"),!this._options?.rawMessageReactions)throw new g.ErrorInfo("unable to subscribe to message reactions; raw message reactions are not enabled",d.FeatureNotEnabledInRoom,400);const t=C(e);return this._emitter.on([q.Create,q.Delete],t),{unsubscribe:()=>{this._emitter.off(t)}}}static channelOptionMerger(e){return t=>(t.modes.includes("ANNOTATION_PUBLISH")||t.modes.push("ANNOTATION_PUBLISH"),e.messages.rawMessageReactions&&!t.modes.includes("ANNOTATION_SUBSCRIBE")&&t.modes.push("ANNOTATION_SUBSCRIBE"),t)}async clientReactions(e,t){return this._logger.trace("MessageReactions.clientReactions();",{messageSerial:e,clientId:t}),te(e,"get client reactions","messageSerial"),this._api.getClientReactions(this._roomName,e,t)}dispose(){this._logger.trace("DefaultMessageReactions.dispose();"),this._emitter.off(),this._unsubscribeMessageEvents(),this._unsubscribeAnnotationEvents?.(),this._logger.debug("DefaultMessageReactions.dispose(); disposed successfully")}hasListeners(){return P(this._emitter)}}const ne=n=>{const e={...Ge(),...n.reactions};for(const c of["unique","distinct"]){const l=e[c];for(const u of Object.keys(l)){const b=l[u];b&&!b.clipped&&(b.clipped=!1)}}const t=e.multiple;for(const c of Object.keys(t)){const l=t[c];l&&(l.clipped||(l.clipped=!1),l.totalClientIds||(l.totalClientIds=0))}const r=Object.values(I).includes(n.action)?n.action:I.MessageCreate,i={serial:n.version.serial,timestamp:new Date(n.version.timestamp),clientId:n.version.clientId,description:n.version.description,metadata:n.version.metadata};return new z({serial:n.serial,clientId:n.clientId,text:n.text,metadata:n.metadata,headers:n.headers,userClaim:n.userClaim,action:r,version:i,timestamp:new Date(n.timestamp),reactions:e})},sn=new Map([[I.MessageCreate,A.Created],[I.MessageUpdate,A.Updated],[I.MessageDelete,A.Deleted]]);var ce=(n=>(n.OldestFirst="oldestFirst",n.NewestFirst="newestFirst",n))(ce||{});class rn{constructor(e,t,r,i,c){this._pendingPromiseRejecters=new Set,this._pendingAttachListeners=new Set,this._emitter=new M,this._roomName=e,this._options=t,this._channel=r,this._chatApi=i,this._logger=c,this._listenerSubscriptionPoints=new Map,this._reactions=new Ve(this._logger,t,this._chatApi,this._roomName,this._channel);const l=this._processEvent.bind(this),u=_=>{this._handleAttach(_.resumed)},b=_=>{_.current==="attached"&&_.previous==="attached"&&this._handleAttach(_.resumed)};this._unsubscribeMessageEvents=U(this._channel,[Be.ChatMessage],l),this._offChannelAttached=L(this._channel,"attached",u),this._offChannelUpdate=L(this._channel,"update",b)}get reactions(){return this._reactions}async _getBeforeSubscriptionStart(e,t){this._logger.trace("DefaultSubscriptionManager.getBeforeSubscriptionStart();");const r=this._listenerSubscriptionPoints.get(e);if(r===void 0)throw this._logger.error("DefaultSubscriptionManager.getBeforeSubscriptionStart(); listener has not been subscribed"),new g.ErrorInfo("unable to query history; listener has not been subscribed",d.ListenerNotSubscribed,400);const i=await r;return this._chatApi.history(this._roomName,{...t,orderBy:"newestFirst",...i})}_handleAttach(e){if(this._logger.trace("DefaultSubscriptionManager.handleAttach();"),e)return;const t=this._subscribeAtChannelAttach();for(const[r]of this._listenerSubscriptionPoints.entries())this._listenerSubscriptionPoints.set(r,t)}async _resolveSubscriptionStart(){const e=this._getChannelProperties();if(e.state==="attached"){if(e.properties.channelSerial)return{fromSerial:e.properties.channelSerial};throw this._logger.error("DefaultSubscriptionManager.handleAttach(); channelSerial is undefined"),new g.ErrorInfo("unable to query messages; channel is attached but channelSerial is not defined",d.ChannelSerialNotDefined,500)}return this._subscribeAtChannelAttach()}_getChannelProperties(){return this._channel}async _subscribeAtChannelAttach(){const e=this._getChannelProperties();return new Promise((t,r)=>{this._pendingPromiseRejecters.add(r);const i=()=>{this._pendingPromiseRejecters.delete(r)};if(e.state==="attached"){this._logger.debug("Messages._subscribeAtChannelAttach(); channel is attached already, using attachSerial",{attachSerial:e.properties.attachSerial}),i(),e.properties.attachSerial?t({fromSerial:e.properties.attachSerial}):(this._logger.error("DefaultSubscriptionManager.handleAttach(); attachSerial is undefined"),i(),r(new g.ErrorInfo("unable to query messages; channel is attached but attachSerial is not defined",d.ChannelSerialNotDefined,500)));return}const c=Kt(e,"attached",()=>{this._logger.debug("Messages._subscribeAtChannelAttach(); channel is now attached, using attachSerial",{attachSerial:e.properties.attachSerial}),i(),this._pendingAttachListeners.delete(c),e.properties.attachSerial?t({fromSerial:e.properties.attachSerial}):(this._logger.error("DefaultSubscriptionManager.handleAttach(); attachSerial is undefined"),r(new g.ErrorInfo("unable to query messages; channel is attached but attachSerial is not defined",d.ChannelSerialNotDefined,500)))});this._pendingAttachListeners.add(c)})}async history(e){return this._logger.trace("Messages.query();"),this._chatApi.history(this._roomName,e)}async get(e){return this._logger.trace("Messages.get();",{serial:e}),this._chatApi.getMessage(this._roomName,e)}async send(e){this._logger.trace("Messages.send();",{params:e});const{text:t,metadata:r,headers:i}=e,c=await this._chatApi.sendMessage(this._roomName,{text:t,headers:i,metadata:r});return ne(c)}async delete(e,t){this._logger.trace("Messages.delete();",{serial:e,details:t}),te(e,"delete message","serial");const r=await this._chatApi.deleteMessage(this._roomName,e,t);return ne(r)}async update(e,t,r){this._logger.trace("Messages.update();",{serial:e,updateParams:t,details:r}),te(e,"update message","serial");const i=await this._chatApi.updateMessage(this._roomName,e,{message:{text:t.text,metadata:t.metadata,headers:t.headers},...r});return this._logger.debug("Messages.update(); message update successfully",{updateParams:t}),ne(i)}subscribe(e){this._logger.trace("Messages.subscribe();");const t=C(e);this._emitter.on([A.Created,A.Updated,A.Deleted],t);const r=this._resolveSubscriptionStart();return r.catch(()=>{this._logger.debug("Messages.subscribe(); subscription point was not resolved before the room was released")}),this._listenerSubscriptionPoints.set(t,r),{unsubscribe:()=>{this._listenerSubscriptionPoints.delete(t),this._logger.trace("Messages.unsubscribe();"),this._emitter.off(t)},historyBeforeSubscribe:async i=>this._getBeforeSubscriptionStart(t,i)}}_processEvent(e){this._logger.trace("Messages._processEvent();",{channelEventMessage:e});const{action:t}=e,r=sn.get(t);if(!r){this._logger.debug("Messages._processEvent(); received unknown message action",{action:t});return}const i=tn(e);this._emitter.emit(r,{type:r,message:i})}dispose(){this._logger.trace("DefaultMessages.dispose();"),this._emitter.off();const e=new g.ErrorInfo("unable to query messages; room has been disposed",d.ResourceDisposed,400);for(const t of this._pendingPromiseRejecters)try{t(e)}catch{}this._pendingPromiseRejecters.clear(),this._listenerSubscriptionPoints.clear();for(const t of this._pendingAttachListeners)t();this._pendingAttachListeners.clear(),this._unsubscribeMessageEvents(),this._offChannelAttached(),this._offChannelUpdate(),this._reactions.dispose(),this._logger.debug("DefaultMessages.dispose(); disposed successfully")}hasListeners(){return P(this._emitter)}}class an{constructor(e,t){this._apiProtocolVersion=4,this._realtime=e,this._logger=t}async history(e,t){const r={...t};if(t.orderBy)switch(t.orderBy){case ce.NewestFirst:{r.direction="backwards";break}case ce.OldestFirst:{r.direction="forwards";break}default:throw new g.ErrorInfo(`unable to query messages; invalid orderBy value: ${t.orderBy}`,d.InvalidArgument,400)}const i=await this._makeAuthorizedPaginatedRequest(this._roomUrl(e,"/messages"),r);return this._recursivePaginateMessages(i)}_recursivePaginateMessages(e){const t={};return t.items=e.items.map(r=>ne(r)),t.next=async()=>{const r=await e.next();return r?this._recursivePaginateMessages(r):null},t.first=async()=>{const r=await e.first();return this._recursivePaginateMessages(r)},t.current=async()=>{const r=await e.current();return this._recursivePaginateMessages(r)},t.hasNext=()=>e.hasNext(),t.isLast=()=>e.isLast(),{...e,...t}}async getMessage(e,t){const r=await this._makeAuthorizedRequest(this._messageUrl(e,t),"GET");return ne(r)}async deleteMessage(e,t,r){const i={...r?.description&&{description:r.description},...r?.metadata&&{metadata:r.metadata}};return this._makeAuthorizedRequest(this._messageUrl(e,t,"/delete"),"POST",i,{})}async sendMessage(e,t){const r={text:t.text,...t.metadata&&{metadata:t.metadata},...t.headers&&{headers:t.headers}};return this._makeAuthorizedRequest(this._roomUrl(e,"/messages"),"POST",r)}async updateMessage(e,t,r){return this._makeAuthorizedRequest(this._messageUrl(e,t),"PUT",r)}async sendMessageReaction(e,t,r){return this._makeAuthorizedRequest(this._messageUrl(e,t,"/reactions"),"POST",r)}async deleteMessageReaction(e,t,r){return this._makeAuthorizedRequest(this._messageUrl(e,t,"/reactions"),"DELETE",void 0,r)}async getClientReactions(e,t,r){const i=r?{forClientId:r}:{};return this._makeAuthorizedRequest(this._messageUrl(e,t,"/client-reactions"),"GET",void 0,i)}async getOccupancy(e){return this._makeAuthorizedRequest(this._roomUrl(e,"/occupancy"),"GET")}async _makeAuthorizedRequest(e,t,r,i){return(await this._doRequest(e,t,i,r)).items[0]}async _makeAuthorizedPaginatedRequest(e,t,r){return this._doRequest(e,"GET",t,r)}async _doRequest(e,t,r,i){const c=await this._realtime.request(t,e,this._apiProtocolVersion,r,i);if(!c.success)throw this._logger.error("ChatApi._doRequest(); failed to make request",{url:e,method:t,statusCode:c.statusCode,errorCode:c.errorCode,errorMessage:c.errorMessage}),new g.ErrorInfo(c.errorMessage,c.errorCode,c.statusCode);return c}_roomUrl(e,t=""){return`/chat/v4/rooms/${encodeURIComponent(e)}${t}`}_messageUrl(e,t,r=""){return`${this._roomUrl(e,"/messages")}/${encodeURIComponent(t)}${r}`}}const on=n=>`${n}::$chat`,le="1.2.0",Ke=`chat-js/${le}`,cn=`chat-react/${le}`,Qe=["PUBLISH","SUBSCRIBE"],ln={params:{agent:Ke},attachOnSubscribe:!1,modes:Qe},hn={params:{agent:`${Ke} ${cn}`},attachOnSubscribe:!1,modes:Qe};class un{constructor(e,t,r,i){r.trace("ChannelManager();",{isReact:i}),this._realtime=t,this._logger=r,this._isReact=i,this._registeredOptions=this._defaultChannelOptions(),this._channelId=on(e)}mergeOptions(e){if(this._logger.trace("ChannelManager.mergeOptions();"),this._resolvedChannel)throw this._logger.error("unable to modify channel options; channel has already been requested"),new g.ErrorInfo("unable to modify channel options; channel has already been requested",d.ChannelOptionsCannotBeModified,400);this._registeredOptions=e(this._registeredOptions)}get(){return this._logger.trace("ChannelManager.get();"),this._resolvedChannel??=this._realtime.channels.get(this._channelId,this._registeredOptions),this._resolvedChannel}release(){this._logger.trace("ChannelManager.release();",{channelId:this._channelId}),this._resolvedChannel&&this._realtime.channels.release(this._channelId)}_defaultChannelOptions(){this._logger.trace("ChannelManager._defaultChannelOptions();");const e=this._isReact?hn:ln;return this._logger.trace(this._isReact?"using react channel options":"using default channel options"),{...e,modes:[...e.modes??[]]}}}const gn=n=>{const e=n;let t=0,r=0;if(!e.data||typeof e.data!="object")return{connections:t,presenceMembers:r};const{metrics:i}=e.data;return!i||typeof i!="object"?{connections:t,presenceMembers:r}:(typeof i.connections=="number"&&Number.isInteger(i.connections)&&(t=i.connections),typeof i.presenceMembers=="number"&&Number.isInteger(i.presenceMembers)&&(r=i.presenceMembers),{connections:t,presenceMembers:r})};class Je{constructor(e,t,r,i,c){this._emitter=new M,this._roomName=e,this._channel=t,this._chatApi=r,this._logger=i,this._roomOptions=c;const l=this._internalOccupancyListener.bind(this);this._roomOptions.occupancy.enableEvents?(this._logger.debug("DefaultOccupancy(); subscribing to occupancy events"),this._unsubscribeOccupancyEvents=U(this._channel,[$e.Occupancy],l)):this._unsubscribeOccupancyEvents=()=>{}}subscribe(e){if(this._logger.trace("Occupancy.subscribe();"),!this._roomOptions.occupancy.enableEvents)throw new g.ErrorInfo("unable to subscribe to occupancy; occupancy events are not enabled in room options",d.FeatureNotEnabledInRoom,400);const t=C(e);return this._emitter.on(t),{unsubscribe:()=>{this._logger.trace("Occupancy.unsubscribe();"),this._emitter.off(t)}}}async get(){return this._logger.trace("Occupancy.get();"),this._chatApi.getOccupancy(this._roomName)}get current(){if(this._logger.trace("Occupancy.current();"),!this._roomOptions.occupancy.enableEvents)throw new g.ErrorInfo("unable to get current occupancy; occupancy events are not enabled in room options",d.FeatureNotEnabledInRoom,400);return this._latestOccupancyData}_internalOccupancyListener(e){this._logger.trace("Occupancy._internalOccupancyListener();",e),this._latestOccupancyData=gn(e),this._emitter.emit(ae.Updated,{type:ae.Updated,occupancy:this._latestOccupancyData})}static channelOptionMerger(e){return t=>e.occupancy.enableEvents?{...t,params:{...t.params,occupancy:"metrics"}}:t}dispose(){this._logger.trace("DefaultOccupancy.dispose();"),this._unsubscribeOccupancyEvents(),this._emitter.off(),this._logger.debug("DefaultOccupancy.dispose(); disposed successfully")}hasListeners(){return P(this._emitter)}}class Xe{constructor(e,t,r){this._emitter=new M,this._stateEmitter=new M,this._presenceState={present:!1},this.subscribeToEvents=u=>{this._emitter.emit(u.action,{type:u.action,member:this._realtimeMemberToPresenceMember(u)})},this._channel=e,this._logger=t,this._options=r;const i=this.subscribeToEvents.bind(this),c=u=>{if(u.reason?.code===91004){this._logger.debug("Presence auto-reentry failed",{reason:u.reason}),this._emitPresenceStateChange(!1,u.reason);return}if(u.current==="detached"){this._emitPresenceStateChange(!1);return}},l=u=>{this._emitPresenceStateChange(!1,u.reason)};this._offChannelUpdate=L(this._channel,"update",c),this._offChannelDetach=L(this._channel,["detached","failed"],l),this._unsubscribePresenceEvents=U(this._channel.presence,i)}async get(e){return this._logger.trace("Presence.get()",{params:e}),this._assertChannelState(),(await this._channel.presence.get(e)).map(r=>this._realtimeMemberToPresenceMember(r))}async isUserPresent(e){return this._logger.trace("Presence.isUserPresent()",{clientId:e}),this._assertChannelState(),(await this._channel.presence.get({clientId:e})).length>0}async enter(e){this._logger.trace("Presence.enter()",{data:e}),this._assertChannelState();try{await this._channel.presence.enter(e),this._emitPresenceStateChange(!0)}catch(t){throw this._emitPresenceStateChange(!1,t),t}}async update(e){this._logger.trace("Presence.update()",{data:e}),this._assertChannelState();try{await this._channel.presence.update(e),this._emitPresenceStateChange(!0)}catch(t){throw this._emitPresenceStateChange(!1,t),t}}async leave(e){this._logger.trace("Presence.leave()",{data:e}),this._assertChannelState();try{await this._channel.presence.leave(e),this._emitPresenceStateChange(!1)}catch(t){throw this._emitPresenceStateChange(!1,t),t}}subscribe(e){if(this._logger.trace("Presence.subscribe()"),!this._options.presence.enableEvents)throw this._logger.error("unable to subscribe to presence; presence events are not enabled"),new g.ErrorInfo("unable to subscribe to presence; presence events are not enabled",d.FeatureNotEnabledInRoom,400);const t=C(e);return this._emitter.on(t),{unsubscribe:()=>{this._logger.trace("Presence.unsubscribe();"),this._emitter.off(t)}}}static channelOptionMerger(e){return t=>(t.modes.includes("PRESENCE")||t.modes.push("PRESENCE"),e.presence.enableEvents&&!t.modes.includes("PRESENCE_SUBSCRIBE")&&t.modes.push("PRESENCE_SUBSCRIBE"),t)}dispose(){this._logger.trace("DefaultPresence.dispose();"),this._emitter.off(),this._unsubscribePresenceEvents(),this._offChannelUpdate(),this._offChannelDetach(),this._logger.debug("DefaultPresence.dispose(); disposed successfully")}hasListeners(){return P(this._emitter)}_realtimeMemberToPresenceMember(e){const t=ee(e.extras);return{...e,data:e.data,updatedAt:new Date(e.timestamp),userClaim:t.userClaim}}_assertChannelState(){if(this._channel.state!=="attaching"&&this._channel.state!=="attached")throw this._logger.error("unable to perform presence operation; room is not attached"),new g.ErrorInfo("unable to perform presence operation; room is not attached",d.RoomInInvalidState,400)}_emitPresenceStateChange(e,t){this._logger.trace("Presence._emitPresenceStateChange()",{present:e,error:t});const r={...this._presenceState};this._presenceState={present:e};const i={previous:r,current:this._presenceState,error:t};this._stateEmitter.emit("presence.state.change",i)}onPresenceStateChange(e){this._logger.trace("Presence.onPresenceStateChange()");const t=C(e);return this._stateEmitter.on("presence.state.change",t),{unsubscribe:()=>{this._logger.trace("Presence.unsubscribeFromPresenceStateChanges()"),this._stateEmitter.off(t)}}}}const he=new Error("request for lock canceled");var dn=function(n,e,t,r){function i(c){return c instanceof t?c:new t(function(l){l(c)})}return new(t||(t=Promise))(function(c,l){function u(f){try{_(r.next(f))}catch(T){l(T)}}function b(f){try{_(r.throw(f))}catch(T){l(T)}}function _(f){f.done?c(f.value):i(f.value).then(u,b)}_((r=r.apply(n,e||[])).next())})};class _n{constructor(e,t=he){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((r,i)=>{const c={resolve:r,reject:i,weight:e,priority:t},l=Ye(this._queue,u=>t<=u.priority);l===-1&&e<=this._value?this._dispatchItem(c):this._queue.splice(l+1,0,c)})}runExclusive(e){return dn(this,arguments,void 0,function*(t,r=1,i=0){const[c,l]=yield this.acquire(r,i);try{return yield t(c)}finally{l()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(r=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),fn(this._weightedWaiters[e-1],{resolve:r,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(r=>r.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const r=this._weightedWaiters[t-1];if(!r)continue;const i=r.findIndex(c=>c.priority<=e);(i===-1?r:r.splice(0,i)).forEach((c=>c.resolve()))}}}_couldLockImmediately(e,t){return(this._queue.length===0||this._queue[0].priority<t)&&e<=this._value}}function fn(n,e){const t=Ye(n,r=>e.priority<=r.priority);n.splice(t+1,0,e)}function Ye(n,e){for(let t=n.length-1;t>=0;t--)if(e(n[t]))return t;return-1}var pn=function(n,e,t,r){function i(c){return c instanceof t?c:new t(function(l){l(c)})}return new(t||(t=Promise))(function(c,l){function u(f){try{_(r.next(f))}catch(T){l(T)}}function b(f){try{_(r.throw(f))}catch(T){l(T)}}function _(f){f.done?c(f.value):i(f.value).then(u,b)}_((r=r.apply(n,e||[])).next())})};class Ze{constructor(e){this._semaphore=new _n(1,e)}acquire(){return pn(this,arguments,void 0,function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t})}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}var m=(n=>(n.Initializing="initializing",n.Initialized="initialized",n.Attaching="attaching",n.Attached="attached",n.Detaching="detaching",n.Detached="detached",n.Suspended="suspended",n.Failed="failed",n.Releasing="releasing",n.Released="released",n))(m||{});class mn{constructor(e){this._status="initialized",this._emitter=new M,this._logger=e}get status(){return this._status}get error(){return this._error}onChange(e){const t=C(e);return this._emitter.on(t),{off:()=>{this._emitter.off(t)}}}setStatus(e){const t={current:e.status,error:e.error,previous:this._status};this._status=t.current,this._error=t.error,this._logger.info("room status changed",{...t}),this._emitter.emit(t.current,t)}dispose(){this._logger.trace("DefaultRoomLifecycle.dispose();"),this._emitter.off(),this._logger.debug("DefaultRoomLifecycle.dispose(); disposed successfully")}hasListeners(){return P(this._emitter)}}class yn{constructor(e,t,r){this._channelManager=e,this._roomLifecycle=t,this._logger=r,this._eventEmitter=new M,this._hasAttachedOnce=!1,this._isExplicitlyDetached=!1,this._mutex=new Ze;const i=this._channelStateListener.bind(this),c=this._discontinuityOnAttachedListener.bind(this),l=this._discontinuityOnUpdateListener.bind(this),u=this._channelManager.get();this._unsubscribeChannelStateListener=L(u,i),this._offDiscontinuityAttached=L(u,"attached",c),this._offDiscontinuityUpdate=L(u,"update",l)}onDiscontinuity(e){this._logger.trace("RoomLifecycleManager.onDiscontinuity()");const t=C(e);return this._eventEmitter.on(W.Discontinuity,t),{off:()=>{this._eventEmitter.off(W.Discontinuity,t)}}}async attach(){await this._mutex.runExclusive(async()=>{if(this._logger.trace("RoomLifecycleManager.attach();"),this._checkRoomNotReleasing("attach"),this._roomStatusIs(m.Attached)){this._logger.debug("RoomLifecycleManager.attach(); room already attached, no-op");return}const e=this._channelManager.get();this._logger.debug("RoomLifecycleManager.attach(); attaching room",{channelState:e.state});try{this._setStatus(m.Attaching),await e.attach(),this._setStatus(m.Attached),this._isExplicitlyDetached=!1,this._hasAttachedOnce=!0,this._logger.debug("RoomLifecycleManager.attach(); room attached successfully")}catch(t){const r=t,i=new g.ErrorInfo(`failed to attach room: ${r.message}`,r.code,r.statusCode,r),c=this._mapChannelStateToRoomStatus(e.state);throw this._setStatus(c,i),i}},1)}async detach(){await this._mutex.runExclusive(async()=>{if(this._logger.trace("RoomLifecycleManager.detach();"),this._roomStatusIs(m.Failed))throw new g.ErrorInfo("unable to detach room; room is in failed state",d.RoomInInvalidState,400);if(this._checkRoomNotReleasing("detach"),this._roomStatusIs(m.Detached)){this._logger.debug("RoomLifecycleManager.detach(); room already detached, no-op");return}const e=this._channelManager.get();this._logger.debug("RoomLifecycleManager.detach(); detaching room",{channelState:e.state});try{this._setStatus(m.Detaching),await e.detach(),this._isExplicitlyDetached=!0,this._setStatus(m.Detached),this._logger.debug("RoomLifecycleManager.detach(); room detached successfully")}catch(t){const r=t,i=new g.ErrorInfo(`failed to detach room: ${r.message}`,r.code,r.statusCode,r),c=this._mapChannelStateToRoomStatus(e.state);throw this._setStatus(c,i),i}},1)}async release(){await this._mutex.runExclusive(async()=>{if(this._logger.trace("RoomLifecycleManager.release();"),this._roomStatusIs(m.Released)){this._logger.debug("RoomLifecycleManager.release(); room already released, no-op");return}if(this._roomStatusIs(m.Initialized)||this._roomStatusIs(m.Detached)){this._logger.debug("RoomLifecycleManager.release(); room is initialized or detached, releasing immediately",{status:this._roomLifecycle.status}),this._releaseChannel();return}this._setStatus(m.Releasing);const e=this._channelManager.get();this._logger.debug("RoomLifecycleManager.release(); attempting channel detach before release",{channelState:e.state}),await this._channelDetachLoop(e),this._releaseChannel()},0)}_mapChannelStateToRoomStatus(e){switch(e){case"initialized":return m.Initialized;case"attaching":return m.Attaching;case"attached":return m.Attached;case"detaching":return m.Detaching;case"detached":return m.Detached;case"suspended":return m.Suspended;case"failed":return m.Failed;default:return this._logger.error("RoomLifecycleManager._mapChannelStateToRoomStatus(); unknown channel state",{channelState:e}),m.Failed}}_checkRoomNotReleasing(e){switch(this._roomLifecycle.status){case m.Released:throw new g.ErrorInfo(`unable to ${e} room; room is released`,d.RoomInInvalidState,400);case m.Releasing:throw new g.ErrorInfo(`unable to ${e} room; room is currently releasing`,d.RoomInInvalidState,400)}}_roomStatusIs(e){return this._roomLifecycle.status===e}dispose(){this._unsubscribeChannelStateListener(),this._offDiscontinuityAttached(),this._offDiscontinuityUpdate(),this._eventEmitter.off()}hasListeners(){return P(this._eventEmitter)}_channelStateListener(e){if(this._logger.debug("RoomLifecycleManager.channel state changed",{oldState:e.previous,newState:e.current,reason:e.reason,resumed:e.resumed}),this._operationInProgress()){this._logger.debug("RoomLifecycleManager._startMonitoringChannelState(); ignoring channel state change - operation in progress",{status:this._roomLifecycle.status});return}const t=this._mapChannelStateToRoomStatus(e.current);this._setStatus(t,e.reason)}_discontinuityOnAttachedListener(e){if(!e.resumed&&this._hasAttachedOnce&&!this._isExplicitlyDetached){const t=new g.ErrorInfo("discontinuity detected",d.RoomDiscontinuity,e.reason?.statusCode??0,e.reason);this._logger.warn("RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected",{error:t}),this._eventEmitter.emit(W.Discontinuity,t)}}_discontinuityOnUpdateListener(e){if(!e.resumed&&this._hasAttachedOnce&&!this._isExplicitlyDetached&&e.current==="attached"&&e.previous==="attached"){const t=new g.ErrorInfo("discontinuity detected",d.RoomDiscontinuity,e.reason?.statusCode??0,e.reason);this._logger.warn("RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected",{error:t}),this._eventEmitter.emit(W.Discontinuity,t)}}async _channelDetachLoop(e){for(;;){if(e.state==="failed"){this._logger.debug("RoomLifecycleManager._channelDetachLoop(); channel is failed, skipping detach");break}try{await e.detach();break}catch(r){this._logger.error("RoomLifecycleManager._channelDetachLoop(); failed to detach channel during release",{error:r}),await new Promise(i=>setTimeout(i,250))}}}_setStatus(e,t){this._logger.debug("RoomLifecycleManager._setStatus(); updating room status",{oldStatus:this._roomLifecycle.status,newStatus:e,hasError:!!t}),this._roomLifecycle.setStatus({status:e,error:t})}_releaseChannel(){this._channelManager.release(),this._setStatus(m.Released),this._logger.debug("RoomLifecycleManager._releaseChannel(); room released successfully")}_operationInProgress(){return this._mutex.isLocked()}testForceHasAttachedOnce(e){this._logger.trace("RoomLifecycleManager.testForceHasAttachedOnce();",{firstAttach:e}),this._hasAttachedOnce=e}}const ue={typing:{heartbeatThrottleMs:1e4},occupancy:{enableEvents:!1},presence:{enableEvents:!0},messages:{rawMessageReactions:!1,defaultMessageReactionType:N.Distinct}},bn=n=>new g.ErrorInfo(`unable to create room; invalid room configuration: ${n}`,d.InvalidArgument,400),wn=n=>{vn(n.typing)},vn=n=>{if(n.heartbeatThrottleMs<=0)throw bn("typing heartbeat interval must be greater than 0")},Sn=n=>({...ue.typing,...n?.typing}),Rn=n=>({...ue.occupancy,...n?.occupancy}),Tn=n=>({...ue.presence,...n?.presence}),Cn=n=>({...ue.messages,...n?.messages}),Mn=(n,e)=>({typing:Sn(n),occupancy:Rn(n),presence:Tn(n),messages:Cn(n),isReactClient:e}),et=(n,e)=>({name:n,data:e,extras:{ephemeral:!0}}),An=n=>{const e=n.extras?n.extras:{};return{...n,extras:{...e,ephemeral:!0}}};class In{constructor(e,t,r,i,c,l,u){this.name=e,this.clientId=t,this.createdAt=r,this.isSelf=i,this.metadata=c,this.headers=l,this.userClaim=u,Object.freeze(this)}}const On=(n,e)=>{const t=n,r=t.data?.name&&typeof t.data.name=="string"?t.data.name:"",i=t.clientId??"",c=t.timestamp?new Date(t.timestamp):new Date,l=ee(n.extras);return new In(r,i,c,e?e===i:!1,t.data?.metadata??{},l.headers??{},l.userClaim)};class En{constructor(e,t,r,i){this._emitter=new M,this._forwarder=l=>{const u=On(l,this._clientIdResolver.get());this._emitter.emit(Re.Reaction,{type:Re.Reaction,reaction:u})},this._channel=e,this._connection=t,this._clientIdResolver=r,this._logger=i;const c=this._forwarder.bind(this);this._unsubscribeRoomReactionEvents=U(this._channel,[Se.Reaction],c)}async send(e){this._logger.trace("RoomReactions.send();",e);const{name:t,metadata:r,headers:i}=e;if(!t)throw new g.ErrorInfo("unable to send reaction; name not set and it is required",d.InvalidArgument,400);if(this._connection.state!=="connected")throw new g.ErrorInfo("unable to send reaction; not connected to Ably",d.Disconnected,400);const c={name:t,metadata:r??{}},l={name:Se.Reaction,data:c,extras:{headers:i??{}}};return this._channel.publish(An(l))}subscribe(e){this._logger.trace("RoomReactions.subscribe();");const t=C(e);return this._emitter.on(t),{unsubscribe:()=>{this._logger.trace("RoomReactions.unsubscribe();"),this._emitter.off(t)}}}dispose(){this._unsubscribeRoomReactionEvents(),this._emitter.off()}hasListeners(){return P(this._emitter)}}class Dn extends M{constructor(e,t,r,i){super(),this._timeoutMs=2e3,this._mutex=new Ze,this._internalSubscribeToEvents=c=>{const{name:l,clientId:u}=c;if(this._logger.trace("DefaultTyping._internalSubscribeToEvents(); received event",{name:l,clientId:u}),!u){this._logger.error("DefaultTyping._internalSubscribeToEvents(); invalid clientId in received event",{inbound:c});return}const _=ee(c.extras).userClaim;l===R.Started||l===R.Stopped?this._updateCurrentlyTyping(u,l,_):this._logger.warn("DefaultTyping._internalSubscribeToEvents(); unrecognized event",{name:l})},this._channel=r,this._connection=t,this._heartbeatThrottleMs=e.heartbeatThrottleMs,this._currentlyTyping=new Map,this._logger=i,this._unsubscribeTypingEvents=U(this._channel,[R.Started,R.Stopped],this._internalSubscribeToEvents.bind(this))}_clearAllTypingStates(){this._logger.debug("DefaultTyping._clearAllTypingStates(); clearing all typing states"),this._clearHeartbeatTimer(),this._clearCurrentlyTyping()}_clearHeartbeatTimer(){this._logger.trace("DefaultTyping._clearHeartbeatTimer(); clearing heartbeat timer"),this._heartbeatTimerId&&(clearTimeout(this._heartbeatTimerId),this._heartbeatTimerId=void 0)}_clearCurrentlyTyping(){this._logger.trace("DefaultTyping._clearCurrentlyTyping(); clearing current store and timeouts");for(const[,e]of this._currentlyTyping.entries())clearTimeout(e.timer);this._currentlyTyping.clear()}get current(){return this._logger.trace("DefaultTyping.current();"),new Set(this._currentlyTyping.keys())}get currentTypers(){return this._logger.trace("DefaultTyping.currentTypers();"),this._buildCurrentTypers()}get channel(){return this._channel}_startHeartbeatTimer(){if(!this._heartbeatTimerId){this._logger.trace("DefaultTyping.startHeartbeatTimer();");const e=this._heartbeatTimerId=setTimeout(()=>{this._logger.debug("DefaultTyping.startHeartbeatTimer(); heartbeat timer expired"),e===this._heartbeatTimerId&&(this._heartbeatTimerId=void 0)},this._heartbeatThrottleMs)}}async keystroke(){this._logger.trace("DefaultTyping.keystroke();"),this._mutex.cancel();try{await this._mutex.acquire()}catch(e){if(e===he){this._logger.debug("DefaultTyping.keystroke(); mutex was canceled by a later operation");return}throw new g.ErrorInfo("unable to send keystroke event; failed to enforce sequential execution of the operation",d.OperationSerializationFailed,500)}try{if(this._connection.state!=="connected")throw this._logger.error("DefaultTyping.keystroke(); connection is not connected",{status:this._connection.state}),new g.ErrorInfo("unable to send typing keystroke event; disconnected from Ably",d.Disconnected,400);if(this._heartbeatTimerId){this._logger.debug("DefaultTyping.keystroke(); no-op, already typing and heartbeat timer has not expired");return}await this._channel.publish(et(R.Started)),this._startHeartbeatTimer(),this._logger.trace("DefaultTyping.keystroke(); starting timers")}finally{this._logger.trace("DefaultTyping.keystroke(); releasing mutex"),this._mutex.release()}}async stop(){this._logger.trace("DefaultTyping.stop();"),this._mutex.cancel();try{await this._mutex.acquire()}catch(e){if(e===he){this._logger.debug("DefaultTyping.stop(); mutex was canceled by a later operation");return}throw new g.ErrorInfo("unable to send typing stop event; failed to enforce sequential execution of the operation",d.OperationSerializationFailed,500)}try{if(this._connection.state!=="connected")throw this._logger.error("DefaultTyping.stop(); connection is not connected",{status:this._connection.state}),new g.ErrorInfo("unable to send typing stop event; disconnected from Ably",d.Disconnected,400);if(!this._heartbeatTimerId){this._logger.debug("DefaultTyping.stop(); no-op, not currently typing");return}await this._channel.publish(et(R.Stopped)),this._logger.trace("DefaultTyping.stop(); clearing timers"),clearTimeout(this._heartbeatTimerId),this._heartbeatTimerId=void 0}finally{this._logger.trace("DefaultTyping.stop(); releasing mutex"),this._mutex.release()}}subscribe(e){this._logger.trace("DefaultTyping.subscribe();");const t=C(e);return this.on(t),{unsubscribe:()=>{this._logger.trace("DefaultTyping.unsubscribe();"),this.off(t)}}}async dispose(){for(this._logger.trace("DefaultTyping.dispose();");;)try{this._mutex.cancel(),await this._mutex.acquire();break}catch(e){if(e===he)this._logger.debug("DefaultTyping.dispose(); mutex was canceled"),await new Promise(t=>setTimeout(t,200)),this._logger.debug("DefaultTyping.dispose(); retrying mutex acquisition");else{this._logger.error("DefaultTyping.dispose(); failed to acquire mutex; could not complete resource disposal",{error:e});return}}this._clearAllTypingStates(),this._unsubscribeTypingEvents(),this.off(),this._mutex.release()}_updateCurrentlyTyping(e,t,r){this._logger.trace("DefaultTyping._updateCurrentlyTyping();",{clientId:e,event:t}),t===R.Started?this._handleTypingStart(e,r):this._handleTypingStop(e,r)}_buildCurrentTypers(){return[...this._currentlyTyping.entries()].map(([e,t])=>({clientId:e,userClaim:t.userClaim}))}_startNewClientInactivityTimer(e){this._logger.trace("DefaultTyping._startNewClientInactivityTimer(); starting new inactivity timer",{clientId:e});const t=setTimeout(()=>{this._logger.trace("DefaultTyping._startNewClientInactivityTimer(); client typing timeout expired",{clientId:e});const r=this._currentlyTyping.get(e);if(r?.timer!==t){this._logger.debug("DefaultTyping._startNewClientInactivityTimer(); timeout already cleared; ignoring",{clientId:e});return}const i=r.userClaim;this._currentlyTyping.delete(e),this.emit(x.SetChanged,{type:x.SetChanged,currentlyTyping:new Set(this._currentlyTyping.keys()),currentTypers:this._buildCurrentTypers(),change:{clientId:e,type:R.Stopped,userClaim:i}})},this._heartbeatThrottleMs+this._timeoutMs);return t}_handleTypingStart(e,t){this._logger.debug("DefaultTyping._handleTypingStart();",{clientId:e});const r=this._startNewClientInactivityTimer(e),i=this._currentlyTyping.get(e);this._currentlyTyping.set(e,{timer:r,userClaim:t}),i?(this._logger.debug("DefaultTyping._handleTypingStart(); received heartbeat for currently typing client",{clientId:e}),clearTimeout(i.timer)):(this._logger.debug("DefaultTyping._handleTypingStart(); new client started typing",{clientId:e}),this.emit(x.SetChanged,{type:x.SetChanged,currentlyTyping:new Set(this._currentlyTyping.keys()),currentTypers:this._buildCurrentTypers(),change:{clientId:e,type:R.Started,userClaim:t}}))}_handleTypingStop(e,t){const r=this._currentlyTyping.get(e);if(!r){this._logger.trace('DefaultTyping._handleTypingStop(); received "Stop" event for client not in currentlyTyping list',{clientId:e});return}this._logger.debug("DefaultTyping._handleTypingStop(); client stopped typing",{clientId:e}),clearTimeout(r.timer),this._currentlyTyping.delete(e),this.emit(x.SetChanged,{type:x.SetChanged,currentlyTyping:new Set(this._currentlyTyping.keys()),currentTypers:this._buildCurrentTypers(),change:{clientId:e,type:R.Stopped,userClaim:t}})}get heartbeatThrottleMs(){return this._heartbeatThrottleMs}get hasHeartbeatTimer(){return!!this._heartbeatTimerId}}class Ln{constructor(e,t,r,i,c,l,u){wn(r),this._nonce=t,this._logger=u.withContext({roomName:e,roomNonce:t}),this._logger.debug("Room();",{options:r}),this._name=e,this._options=r,this._chatApi=c,this._lifecycle=new mn(this._logger);const b=this._channelManager=this._getChannelManager(r,i,this._logger),_=b.get();this._messages=new rn(e,r.messages,_,this._chatApi,this._logger),this._presence=new Xe(_,this._logger,r),this._typing=new Dn(r.typing,i.connection,_,this._logger),this._reactions=new En(_,i.connection,l,this._logger),this._occupancy=new Je(e,_,this._chatApi,this._logger,r),this._lifecycleManager=new yn(b,this._lifecycle,this._logger);let f=!1;this._finalizer=async()=>{if(f){this._logger.debug("Room.finalizer(); already finalized");return}await this._lifecycleManager.release(),this._lifecycleManager.dispose(),this._messages.dispose(),this._presence.dispose(),this._reactions.dispose(),this._occupancy.dispose(),await this._typing.dispose(),this._lifecycle.dispose(),f=!0}}_getChannelManager(e,t,r){const i=new un(this._name,t,r,e.isReactClient);return i.mergeOptions(Je.channelOptionMerger(e)),i.mergeOptions(Xe.channelOptionMerger(e)),i.mergeOptions(Ve.channelOptionMerger(e)),i}get name(){return this._name}options(){return j(this._options)}get messages(){return this._messages}get presence(){return this._presence}get reactions(){return this._reactions}get typing(){return this._typing}get occupancy(){return this._occupancy}get status(){return this._lifecycle.status}get error(){return this._lifecycle.error}onStatusChange(e){return this._lifecycle.onChange(e)}async attach(){return this._logger.trace("Room.attach();"),this._lifecycleManager.attach()}async detach(){return this._logger.trace("Room.detach();"),this._lifecycleManager.detach()}async release(){return this._logger.trace("Room.release();"),this._finalizer()}get nonce(){return this._nonce}get lifecycle(){return this._lifecycle}get lifecycleManager(){return this._lifecycleManager}onDiscontinuity(e){return this._logger.trace("Room.onDiscontinuity();"),this._lifecycleManager.onDiscontinuity(e)}get channel(){return this._channelManager.get()}}class Pn{constructor(e,t,r){this._rooms=new Map,this._releasing=new Map,this._isReact=!1,this._disposed=!1,this._realtime=e,this._chatApi=new an(e,r),this._clientIdResolver=t,this._logger=r}async get(e,t){this._logger.trace("Rooms.get();",{roomName:e}),this._ensureNotDisposed();const r=this._rooms.get(e);if(r)return this._handleExistingRoom(r,e,t);const i=this._releasing.get(e),c=qe();return i?this._waitForReleaseAndCreateRoom(e,c,t,i):this._createNewRoom(e,c,t)}async release(e){this._logger.trace("Rooms.release();",{roomName:e});const t=this._rooms.get(e),r=this._releasing.get(e);return t?r?this._handleConcurrentRelease(e,t,r):this._performRoomRelease(e,t):this._handleNonExistentRoomRelease(e,r)}async dispose(){this._logger.trace("Rooms.dispose();"),this._disposed=!0;const e=[...this._rooms.keys()];if(e.length===0){this._logger.debug("Rooms.dispose(); no rooms to release");return}const t=e.map(async c=>this.release(c)),r=[...this._releasing.values()],i=[...t,...r];this._logger.debug("Rooms.dispose(); releasing rooms",{roomCount:e.length,roomNames:e}),await Promise.all(i),this._logger.debug("Rooms.dispose(); all rooms released successfully")}get count(){return this._rooms.size}_ensureNotDisposed(){if(this._disposed)throw new g.ErrorInfo("unable to get room; rooms instance has been disposed",d.ResourceDisposed,400)}async _handleExistingRoom(e,t,r){if(!Y(e.options,r))throw new g.ErrorInfo("unable to get room; room already exists with different options",d.RoomExistsWithDifferentOptions,400);return this._logger.debug("Rooms.get(); returning existing room",{roomName:t,nonce:e.nonce,options:r}),await e.promise}_createNewRoom(e,t,r){const i=this._makeRoom(e,t,r),c={promise:Promise.resolve(i),nonce:t,options:r};return this._rooms.set(e,c),this._logger.debug("Rooms.get(); returning new room",{roomName:e,nonce:i.nonce}),i}async _waitForReleaseAndCreateRoom(e,t,r,i){const c=new AbortController,l=this._createAbortableRoomPromise(e,t,r,i,c);return this._rooms.set(e,{promise:l,options:r,nonce:t,abort:c}),this._logger.debug("Rooms.get(); creating new promise dependent on previous release",{roomName:e}),await l}async _createAbortableRoomPromise(e,t,r,i,c){const l=new Promise((b,_)=>{const f=()=>{this._logger.debug("Rooms.get(); aborted before init",{roomName:e}),_(new g.ErrorInfo("unable to get room; room released before operation could complete",d.RoomReleasedBeforeOperationCompleted,400))};c.signal.addEventListener("abort",f,{once:!0})});return await Promise.race([i,l]),this._logger.debug("Rooms.get(); releasing finished",{roomName:e}),this._makeRoom(e,t,r)}async _handleNonExistentRoomRelease(e,t){if(t){this._logger.debug("Rooms.release(); waiting for previous release call",{roomName:e}),await t;return}this._logger.debug("Rooms.release(); room does not exist",{roomName:e})}async _handleConcurrentRelease(e,t,r){t.abort&&(this._logger.debug("Rooms.release(); aborting get call",{roomName:e,existingNonce:t.nonce}),t.abort.abort(),this._rooms.delete(e)),await r}async _performRoomRelease(e,t){this._rooms.delete(e);const r=this._executeRoomRelease(e,t);this._releasing.set(e,r),this._logger.debug("Rooms.release(); creating new release promise",{roomName:e,nonce:t.nonce}),await r}async _executeRoomRelease(e,t){const r=await t.promise;this._logger.debug("Rooms.release(); releasing room",{roomName:e,nonce:t.nonce}),await r.release(),this._logger.debug("Rooms.release(); room released",{roomName:e,nonce:t.nonce}),this._releasing.delete(e)}_makeRoom(e,t,r){return new Ln(e,t,Mn(r,this._isReact),this._realtime,this._chatApi,this._clientIdResolver,this._logger)}useReact(){this._logger.trace("Rooms.useReact();"),this._isReact=!0}}class xn{constructor(e,t){this._realtime=e,this._clientOptions=Vt(t),this._nonce=qe(),this._logger=Wt(this._clientOptions).withContext({chatClientNonce:this._nonce}),this._connection=new Jt(e,this._logger),this._clientIdResolver=new $t(e,this._logger),this._rooms=new Pn(e,this._clientIdResolver,this._logger),this._addAgent("chat-js"),this._logger.trace(`ably chat client version ${le}; initialized`)}get rooms(){return this._rooms}get connection(){return this._connection}get clientId(){return this._realtime.auth.clientId}get realtime(){return this._realtime}get clientOptions(){return this._clientOptions}get logger(){return this._logger}addReactAgent(){this._addAgent("chat-react"),this._rooms.useReact()}addAgentWithVersion(e,t){this._addAgent(e,t),this._logger.trace(`Added agent ${e} with version ${t}`)}async dispose(){this._logger.trace("ChatClient.dispose();"),await this._rooms.dispose(),this._connection.dispose(),this._logger.debug("ChatClient.dispose(); client disposed successfully")}_addAgent(e,t){const r=this._realtime;r.options.agents={...r.options.agents??r.options.agents,[e]:t??le}}}y.ChatClient=xn,y.ChatMessageAction=I,y.ChatMessageEventType=A,y.ConnectionStatus=Ue,y.ErrorCode=d,y.LogLevel=we,y.MessageReactionRawEventType=q,y.MessageReactionSummaryEventType=H,y.MessageReactionType=N,y.OccupancyEventType=ae,y.OrderBy=ce,y.PresenceEventType=He,y.RoomEventType=W,y.RoomStatus=m,y.TypingEventType=R,y.TypingSetEventType=x,y.errorInfoIs=Bt,Object.defineProperty(y,Symbol.toStringTag,{value:"Module"})}));
//# sourceMappingURL=ably-chat.umd.cjs.map
