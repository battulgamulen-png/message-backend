import * as g from "ably";
var d = /* @__PURE__ */ ((n) => (n[n.BadRequest = 4e4] = "BadRequest", n[n.InvalidArgument = 40003] = "InvalidArgument", n[n.InvalidClientId = 40012] = "InvalidClientId", n[n.ResourceDisposed = 40014] = "ResourceDisposed", n[n.MessageRejectedByBeforePublishRule = 42211] = "MessageRejectedByBeforePublishRule", n[n.MessageRejectedByModeration = 42213] = "MessageRejectedByModeration", n[n.Disconnected = 80003] = "Disconnected", n[n.PresenceAutoReentryFailed = 91004] = "PresenceAutoReentryFailed", n[n.RoomDiscontinuity = 102100] = "RoomDiscontinuity", n[n.RoomInInvalidState = 102112] = "RoomInInvalidState", n[n.RoomReleasedBeforeOperationCompleted = 102106] = "RoomReleasedBeforeOperationCompleted", n[n.RoomExistsWithDifferentOptions = 102107] = "RoomExistsWithDifferentOptions", n[n.FeatureNotEnabledInRoom = 102108] = "FeatureNotEnabledInRoom", n[n.ListenerNotSubscribed = 102109] = "ListenerNotSubscribed", n[n.ChannelSerialNotDefined = 102110] = "ChannelSerialNotDefined", n[n.ChannelOptionsCannotBeModified = 102111] = "ChannelOptionsCannotBeModified", n[n.OperationSerializationFailed = 102113] = "OperationSerializationFailed", n[n.ReactHookMustBeUsedWithinProvider = 102200] = "ReactHookMustBeUsedWithinProvider", n[n.ReactComponentUnmounted = 102201] = "ReactComponentUnmounted", n[n.PresenceFetchFailed = 102202] = "PresenceFetchFailed", n))(d || {});
const er = (n, e) => n.code === e;
class cn {
  constructor(e, t) {
    this._realtime = e, this._logger = t;
  }
  get() {
    const e = this._realtime.auth.clientId;
    if (!e)
      throw this._logger.error("unable to get client id; client id is not set", { clientId: e }), new g.ErrorInfo("unable to get client id; client id is not set", d.InvalidClientId, 400);
    return e;
  }
}
var At = /* @__PURE__ */ ((n) => (n.Trace = "trace", n.Debug = "debug", n.Info = "info", n.Warn = "warn", n.Error = "error", n.Silent = "silent", n))(At || {});
const hn = (n, e, t) => {
  const r = t ? `, context: ${JSON.stringify(t)}` : "", i = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${e.valueOf().toUpperCase()} ably-chat: ${n}${r}`;
  switch (e) {
    case "trace":
    case "debug": {
      console.log(i);
      break;
    }
    case "info": {
      console.info(i);
      break;
    }
    case "warn": {
      console.warn(i);
      break;
    }
    case "error": {
      console.error(i);
      break;
    }
  }
}, ln = (n) => {
  const e = n.logHandler ?? hn;
  return new Le(e, n.logLevel);
}, wt = /* @__PURE__ */ new Map([
  [
    "trace",
    0
    /* Trace */
  ],
  [
    "debug",
    1
    /* Debug */
  ],
  [
    "info",
    2
    /* Info */
  ],
  [
    "warn",
    3
    /* Warn */
  ],
  [
    "error",
    4
    /* Error */
  ],
  [
    "silent",
    5
    /* Silent */
  ]
]);
class Le {
  constructor(e, t, r) {
    this._handler = e, this._context = r;
    const i = wt.get(t);
    if (i === void 0)
      throw new g.ErrorInfo(`unable to create logger; invalid log level: ${t}`, d.InvalidArgument, 400);
    this._levelNumber = i;
  }
  trace(e, t) {
    this._write(e, "trace", 0, t);
  }
  debug(e, t) {
    this._write(e, "debug", 1, t);
  }
  info(e, t) {
    this._write(e, "info", 2, t);
  }
  warn(e, t) {
    this._write(e, "warn", 3, t);
  }
  error(e, t) {
    this._write(e, "error", 4, t);
  }
  withContext(e) {
    const t = [...wt.entries()].find(([, r]) => r === this._levelNumber)?.[0] ?? "error";
    return new Le(this._handler, t, this._mergeContext(e));
  }
  _write(e, t, r, i) {
    r >= this._levelNumber && this._handler(e, t, this._mergeContext(i));
  }
  _mergeContext(e) {
    return this._context ? e ? { ...this._context, ...e } : this._context : e ?? void 0;
  }
}
const un = {
  logLevel: At.Error
}, gn = (n) => (n = n ?? {}, {
  ...n,
  logLevel: n.logLevel ?? un.logLevel
});
function E(n, e, t) {
  if ((Array.isArray(e) || typeof e == "string") && t)
    return n.on(e, t), () => {
      n.off(t);
    };
  if (typeof e == "function")
    return n.on(e), () => {
      n.off(e);
    };
  throw new TypeError("Invalid arguments passed to on()");
}
function dn(n, e, t) {
  if (t)
    return n.once(e, t), () => {
      n.off(t);
    };
  throw new TypeError("Invalid arguments passed to once()");
}
function F(n, e, t) {
  if ((Array.isArray(e) || typeof e == "string") && t) {
    const r = n.subscribe(e, t);
    return () => {
      r.then(() => {
        n.unsubscribe(t);
      }).catch((i) => {
        console.error("Error subscribing to events:", i);
      });
    };
  } else if (typeof e == "function") {
    const r = n.subscribe(e);
    return () => {
      r.then(() => {
        n.unsubscribe(e);
      }).catch((i) => {
        console.error("Error subscribing to events:", i);
      });
    };
  } else
    throw new TypeError("Invalid arguments passed to subscribe()");
}
const _n = g.Realtime.EventEmitter;
class C extends _n {
}
const T = (n) => (...e) => n(...e), P = (n) => {
  const e = n, t = Object.values(e.events).flat().length + e.any.length + Object.values(e.eventsOnce).flat().length + e.anyOnce.length;
  return t ? t > 0 : !1;
};
var pn = /* @__PURE__ */ ((n) => (n.Initialized = "initialized", n.Connecting = "connecting", n.Connected = "connected", n.Disconnected = "disconnected", n.Suspended = "suspended", n.Failed = "failed", n.Closing = "closing", n.Closed = "closed", n))(pn || {});
class fn {
  /**
   * Constructs a new `DefaultConnection` instance.
   * @param ably The Ably Realtime client.
   * @param logger The logger to use.
   */
  constructor(e, t) {
    this._status = "initialized", this._emitter = new C(), this._logger = t, this._status = this._mapAblyStatusToChat(e.connection.state), this._error = e.connection.errorReason;
    const r = (i) => {
      const c = this._mapAblyStatusToChat(i.current);
      if (c === this._status)
        return;
      const h = {
        current: c,
        previous: this._status,
        error: i.reason,
        retryIn: i.retryIn
      };
      this._applyStatusChange(h);
    };
    this._clearAblyConnectionListener = E(e.connection, r);
  }
  /**
   * @inheritdoc
   */
  get status() {
    return this._status;
  }
  /**
   * @inheritdoc
   */
  get error() {
    return this._error;
  }
  /**
   * @inheritdoc
   */
  onStatusChange(e) {
    const t = T(e);
    return this._emitter.on(t), {
      off: () => {
        this._emitter.off(t);
      }
    };
  }
  /**
   * @inheritdoc
   */
  dispose() {
    this._logger.trace("DefaultConnection.dispose();"), this._clearAblyConnectionListener(), this._emitter.off();
  }
  /**
   * Checks if there are any listeners registered on the connection.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */
  hasListeners() {
    return P(this._emitter);
  }
  _applyStatusChange(e) {
    this._status = e.current, this._error = e.error, this._logger.info("Connection state changed", e), this._emitter.emit(e.current, e);
  }
  /**
   * Maps an Ably connection state to a connection status.
   * @param status The Ably connection state to map.
   * @returns The corresponding connection status.
   */
  _mapAblyStatusToChat(e) {
    switch (e) {
      case "initialized":
        return "initialized";
      case "connecting":
        return "connecting";
      case "connected":
        return "connected";
      case "disconnected":
        return "disconnected";
      case "suspended":
        return "suspended";
      case "closing":
        return "closing";
      case "closed":
        return "closed";
      case "failed":
        return "failed";
      default:
        return this._logger.error("DefaultConnection._mapAblyStatusToChat(); unknown connection state", {
          status: e
        }), "failed";
    }
  }
}
const It = () => Math.random().toString(36).slice(2);
var vt = Object.prototype.hasOwnProperty;
function St(n, e, t) {
  for (t of n.keys())
    if (Y(t, e)) return t;
}
function Y(n, e) {
  var t, r, i;
  if (n === e) return !0;
  if (n && e && (t = n.constructor) === e.constructor) {
    if (t === Date) return n.getTime() === e.getTime();
    if (t === RegExp) return n.toString() === e.toString();
    if (t === Array) {
      if ((r = n.length) === e.length)
        for (; r-- && Y(n[r], e[r]); ) ;
      return r === -1;
    }
    if (t === Set) {
      if (n.size !== e.size)
        return !1;
      for (r of n)
        if (i = r, i && typeof i == "object" && (i = St(e, i), !i) || !e.has(i)) return !1;
      return !0;
    }
    if (t === Map) {
      if (n.size !== e.size)
        return !1;
      for (r of n)
        if (i = r[0], i && typeof i == "object" && (i = St(e, i), !i) || !Y(r[1], e.get(i)))
          return !1;
      return !0;
    }
    if (t === ArrayBuffer)
      n = new Uint8Array(n), e = new Uint8Array(e);
    else if (t === DataView) {
      if ((r = n.byteLength) === e.byteLength)
        for (; r-- && n.getInt8(r) === e.getInt8(r); ) ;
      return r === -1;
    }
    if (ArrayBuffer.isView(n)) {
      if ((r = n.byteLength) === e.byteLength)
        for (; r-- && n[r] === e[r]; ) ;
      return r === -1;
    }
    if (!t || typeof n == "object") {
      r = 0;
      for (t in n)
        if (vt.call(n, t) && ++r && !vt.call(e, t) || !(t in e) || !Y(n[t], e[t])) return !1;
      return Object.keys(e).length === r;
    }
  }
  return n !== n && e !== e;
}
var x = /* @__PURE__ */ ((n) => (n.Created = "message.created", n.Updated = "message.updated", n.Deleted = "message.deleted", n))(x || {}), Dt = /* @__PURE__ */ ((n) => (n.ChatMessage = "chat.message", n))(Dt || {}), Ot = /* @__PURE__ */ ((n) => (n.Occupancy = "[meta]occupancy", n))(Ot || {}), L = /* @__PURE__ */ ((n) => (n.MessageCreate = "message.create", n.MessageUpdate = "message.update", n.MessageDelete = "message.delete", n))(L || {}), mn = /* @__PURE__ */ ((n) => (n.Enter = "enter", n.Leave = "leave", n.Update = "update", n.Present = "present", n))(mn || {}), R = /* @__PURE__ */ ((n) => (n.Started = "typing.started", n.Stopped = "typing.stopped", n))(R || {}), q = /* @__PURE__ */ ((n) => (n.SetChanged = "typing.set.changed", n))(q || {}), De = /* @__PURE__ */ ((n) => (n.Reaction = "roomReaction", n))(De || {}), Oe = /* @__PURE__ */ ((n) => (n.Reaction = "reaction", n))(Oe || {}), j = /* @__PURE__ */ ((n) => (n.Unique = "unique", n.Distinct = "distinct", n.Multiple = "multiple", n))(j || {}), ge = /* @__PURE__ */ ((n) => (n.Unique = "reaction:unique.v1", n.Distinct = "reaction:distinct.v1", n.Multiple = "reaction:multiple.v1", n))(ge || {});
const yn = {
  "reaction:unique.v1": "unique",
  "reaction:distinct.v1": "distinct",
  "reaction:multiple.v1": "multiple"
  /* Multiple */
};
var V = /* @__PURE__ */ ((n) => (n.Create = "reaction.create", n.Delete = "reaction.delete", n))(V || {}), Z = /* @__PURE__ */ ((n) => (n.Summary = "reaction.summary", n))(Z || {}), Ee = /* @__PURE__ */ ((n) => (n.Updated = "occupancy.updated", n))(Ee || {}), J = /* @__PURE__ */ ((n) => (n.Discontinuity = "room.discontinuity", n))(J || {}), ue = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function bn(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var X = { exports: {} };
X.exports;
var Rt;
function wn() {
  return Rt || (Rt = 1, (function(n, e) {
    var t = 200, r = "__lodash_hash_undefined__", i = 9007199254740991, c = "[object Arguments]", h = "[object Array]", u = "[object Boolean]", y = "[object Date]", _ = "[object Error]", p = "[object Function]", S = "[object GeneratorFunction]", B = "[object Map]", Pe = "[object Number]", fe = "[object Object]", Ne = "[object Promise]", Ue = "[object RegExp]", ne = "[object Set]", ke = "[object String]", qe = "[object Symbol]", me = "[object WeakMap]", je = "[object ArrayBuffer]", re = "[object DataView]", ze = "[object Float32Array]", Fe = "[object Float64Array]", Be = "[object Int8Array]", $e = "[object Int16Array]", He = "[object Int32Array]", We = "[object Uint8Array]", Ge = "[object Uint8ClampedArray]", Ve = "[object Uint16Array]", Ke = "[object Uint32Array]", kt = /[\\^$.*+?()[\]{}|]/g, qt = /\w*$/, jt = /^\[object .+?Constructor\]$/, zt = /^(?:0|[1-9]\d*)$/, f = {};
    f[c] = f[h] = f[je] = f[re] = f[u] = f[y] = f[ze] = f[Fe] = f[Be] = f[$e] = f[He] = f[B] = f[Pe] = f[fe] = f[Ue] = f[ne] = f[ke] = f[qe] = f[We] = f[Ge] = f[Ve] = f[Ke] = !0, f[_] = f[p] = f[me] = !1;
    var Ft = typeof ue == "object" && ue && ue.Object === Object && ue, Bt = typeof self == "object" && self && self.Object === Object && self, M = Ft || Bt || Function("return this")(), Qe = e && !e.nodeType && e, Je = Qe && !0 && n && !n.nodeType && n, $t = Je && Je.exports === Qe;
    function Ht(s, a) {
      return s.set(a[0], a[1]), s;
    }
    function Wt(s, a) {
      return s.add(a), s;
    }
    function Gt(s, a) {
      for (var o = -1, l = s ? s.length : 0; ++o < l && a(s[o], o, s) !== !1; )
        ;
      return s;
    }
    function Vt(s, a) {
      for (var o = -1, l = a.length, b = s.length; ++o < l; )
        s[b + o] = a[o];
      return s;
    }
    function Xe(s, a, o, l) {
      for (var b = -1, w = s ? s.length : 0; ++b < w; )
        o = a(o, s[b], b, s);
      return o;
    }
    function Kt(s, a) {
      for (var o = -1, l = Array(s); ++o < s; )
        l[o] = a(o);
      return l;
    }
    function Qt(s, a) {
      return s?.[a];
    }
    function Ye(s) {
      var a = !1;
      if (s != null && typeof s.toString != "function")
        try {
          a = !!(s + "");
        } catch {
        }
      return a;
    }
    function Ze(s) {
      var a = -1, o = Array(s.size);
      return s.forEach(function(l, b) {
        o[++a] = [b, l];
      }), o;
    }
    function ye(s, a) {
      return function(o) {
        return s(a(o));
      };
    }
    function et(s) {
      var a = -1, o = Array(s.size);
      return s.forEach(function(l) {
        o[++a] = l;
      }), o;
    }
    var Jt = Array.prototype, Xt = Function.prototype, ie = Object.prototype, be = M["__core-js_shared__"], tt = (function() {
      var s = /[^.]+$/.exec(be && be.keys && be.keys.IE_PROTO || "");
      return s ? "Symbol(src)_1." + s : "";
    })(), st = Xt.toString, D = ie.hasOwnProperty, ae = ie.toString, Yt = RegExp(
      "^" + st.call(D).replace(kt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), nt = $t ? M.Buffer : void 0, rt = M.Symbol, it = M.Uint8Array, Zt = ye(Object.getPrototypeOf, Object), es = Object.create, ts = ie.propertyIsEnumerable, ss = Jt.splice, at = Object.getOwnPropertySymbols, ns = nt ? nt.isBuffer : void 0, rs = ye(Object.keys, Object), we = W(M, "DataView"), K = W(M, "Map"), ve = W(M, "Promise"), Se = W(M, "Set"), Re = W(M, "WeakMap"), Q = W(Object, "create"), is = k(we), as = k(K), os = k(ve), cs = k(Se), hs = k(Re), ot = rt ? rt.prototype : void 0, ct = ot ? ot.valueOf : void 0;
    function N(s) {
      var a = -1, o = s ? s.length : 0;
      for (this.clear(); ++a < o; ) {
        var l = s[a];
        this.set(l[0], l[1]);
      }
    }
    function ls() {
      this.__data__ = Q ? Q(null) : {};
    }
    function us(s) {
      return this.has(s) && delete this.__data__[s];
    }
    function gs(s) {
      var a = this.__data__;
      if (Q) {
        var o = a[s];
        return o === r ? void 0 : o;
      }
      return D.call(a, s) ? a[s] : void 0;
    }
    function ds(s) {
      var a = this.__data__;
      return Q ? a[s] !== void 0 : D.call(a, s);
    }
    function _s(s, a) {
      var o = this.__data__;
      return o[s] = Q && a === void 0 ? r : a, this;
    }
    N.prototype.clear = ls, N.prototype.delete = us, N.prototype.get = gs, N.prototype.has = ds, N.prototype.set = _s;
    function A(s) {
      var a = -1, o = s ? s.length : 0;
      for (this.clear(); ++a < o; ) {
        var l = s[a];
        this.set(l[0], l[1]);
      }
    }
    function ps() {
      this.__data__ = [];
    }
    function fs(s) {
      var a = this.__data__, o = oe(a, s);
      if (o < 0)
        return !1;
      var l = a.length - 1;
      return o == l ? a.pop() : ss.call(a, o, 1), !0;
    }
    function ms(s) {
      var a = this.__data__, o = oe(a, s);
      return o < 0 ? void 0 : a[o][1];
    }
    function ys(s) {
      return oe(this.__data__, s) > -1;
    }
    function bs(s, a) {
      var o = this.__data__, l = oe(o, s);
      return l < 0 ? o.push([s, a]) : o[l][1] = a, this;
    }
    A.prototype.clear = ps, A.prototype.delete = fs, A.prototype.get = ms, A.prototype.has = ys, A.prototype.set = bs;
    function $(s) {
      var a = -1, o = s ? s.length : 0;
      for (this.clear(); ++a < o; ) {
        var l = s[a];
        this.set(l[0], l[1]);
      }
    }
    function ws() {
      this.__data__ = {
        hash: new N(),
        map: new (K || A)(),
        string: new N()
      };
    }
    function vs(s) {
      return ce(this, s).delete(s);
    }
    function Ss(s) {
      return ce(this, s).get(s);
    }
    function Rs(s) {
      return ce(this, s).has(s);
    }
    function Ts(s, a) {
      return ce(this, s).set(s, a), this;
    }
    $.prototype.clear = ws, $.prototype.delete = vs, $.prototype.get = Ss, $.prototype.has = Rs, $.prototype.set = Ts;
    function H(s) {
      this.__data__ = new A(s);
    }
    function Cs() {
      this.__data__ = new A();
    }
    function Ms(s) {
      return this.__data__.delete(s);
    }
    function As(s) {
      return this.__data__.get(s);
    }
    function Is(s) {
      return this.__data__.has(s);
    }
    function Ds(s, a) {
      var o = this.__data__;
      if (o instanceof A) {
        var l = o.__data__;
        if (!K || l.length < t - 1)
          return l.push([s, a]), this;
        o = this.__data__ = new $(l);
      }
      return o.set(s, a), this;
    }
    H.prototype.clear = Cs, H.prototype.delete = Ms, H.prototype.get = As, H.prototype.has = Is, H.prototype.set = Ds;
    function Os(s, a) {
      var o = Me(s) || en(s) ? Kt(s.length, String) : [], l = o.length, b = !!l;
      for (var w in s)
        D.call(s, w) && !(b && (w == "length" || Js(w, l))) && o.push(w);
      return o;
    }
    function ht(s, a, o) {
      var l = s[a];
      (!(D.call(s, a) && dt(l, o)) || o === void 0 && !(a in s)) && (s[a] = o);
    }
    function oe(s, a) {
      for (var o = s.length; o--; )
        if (dt(s[o][0], a))
          return o;
      return -1;
    }
    function Es(s, a) {
      return s && lt(a, Ae(a), s);
    }
    function Te(s, a, o, l, b, w, I) {
      var v;
      if (l && (v = w ? l(s, b, w, I) : l(s)), v !== void 0)
        return v;
      if (!he(s))
        return s;
      var ft = Me(s);
      if (ft) {
        if (v = Vs(s), !a)
          return Hs(s, v);
      } else {
        var G = U(s), mt = G == p || G == S;
        if (sn(s))
          return ks(s, a);
        if (G == fe || G == c || mt && !w) {
          if (Ye(s))
            return w ? s : {};
          if (v = Ks(mt ? {} : s), !a)
            return Ws(s, Es(v, s));
        } else {
          if (!f[G])
            return w ? s : {};
          v = Qs(s, G, Te, a);
        }
      }
      I || (I = new H());
      var yt = I.get(s);
      if (yt)
        return yt;
      if (I.set(s, v), !ft)
        var bt = o ? Gs(s) : Ae(s);
      return Gt(bt || s, function(Ie, le) {
        bt && (le = Ie, Ie = s[le]), ht(v, le, Te(Ie, a, o, l, le, s, I));
      }), v;
    }
    function xs(s) {
      return he(s) ? es(s) : {};
    }
    function Ls(s, a, o) {
      var l = a(s);
      return Me(s) ? l : Vt(l, o(s));
    }
    function Ps(s) {
      return ae.call(s);
    }
    function Ns(s) {
      if (!he(s) || Ys(s))
        return !1;
      var a = pt(s) || Ye(s) ? Yt : jt;
      return a.test(k(s));
    }
    function Us(s) {
      if (!gt(s))
        return rs(s);
      var a = [];
      for (var o in Object(s))
        D.call(s, o) && o != "constructor" && a.push(o);
      return a;
    }
    function ks(s, a) {
      if (a)
        return s.slice();
      var o = new s.constructor(s.length);
      return s.copy(o), o;
    }
    function Ce(s) {
      var a = new s.constructor(s.byteLength);
      return new it(a).set(new it(s)), a;
    }
    function qs(s, a) {
      var o = a ? Ce(s.buffer) : s.buffer;
      return new s.constructor(o, s.byteOffset, s.byteLength);
    }
    function js(s, a, o) {
      var l = a ? o(Ze(s), !0) : Ze(s);
      return Xe(l, Ht, new s.constructor());
    }
    function zs(s) {
      var a = new s.constructor(s.source, qt.exec(s));
      return a.lastIndex = s.lastIndex, a;
    }
    function Fs(s, a, o) {
      var l = a ? o(et(s), !0) : et(s);
      return Xe(l, Wt, new s.constructor());
    }
    function Bs(s) {
      return ct ? Object(ct.call(s)) : {};
    }
    function $s(s, a) {
      var o = a ? Ce(s.buffer) : s.buffer;
      return new s.constructor(o, s.byteOffset, s.length);
    }
    function Hs(s, a) {
      var o = -1, l = s.length;
      for (a || (a = Array(l)); ++o < l; )
        a[o] = s[o];
      return a;
    }
    function lt(s, a, o, l) {
      o || (o = {});
      for (var b = -1, w = a.length; ++b < w; ) {
        var I = a[b], v = void 0;
        ht(o, I, v === void 0 ? s[I] : v);
      }
      return o;
    }
    function Ws(s, a) {
      return lt(s, ut(s), a);
    }
    function Gs(s) {
      return Ls(s, Ae, ut);
    }
    function ce(s, a) {
      var o = s.__data__;
      return Xs(a) ? o[typeof a == "string" ? "string" : "hash"] : o.map;
    }
    function W(s, a) {
      var o = Qt(s, a);
      return Ns(o) ? o : void 0;
    }
    var ut = at ? ye(at, Object) : an, U = Ps;
    (we && U(new we(new ArrayBuffer(1))) != re || K && U(new K()) != B || ve && U(ve.resolve()) != Ne || Se && U(new Se()) != ne || Re && U(new Re()) != me) && (U = function(s) {
      var a = ae.call(s), o = a == fe ? s.constructor : void 0, l = o ? k(o) : void 0;
      if (l)
        switch (l) {
          case is:
            return re;
          case as:
            return B;
          case os:
            return Ne;
          case cs:
            return ne;
          case hs:
            return me;
        }
      return a;
    });
    function Vs(s) {
      var a = s.length, o = s.constructor(a);
      return a && typeof s[0] == "string" && D.call(s, "index") && (o.index = s.index, o.input = s.input), o;
    }
    function Ks(s) {
      return typeof s.constructor == "function" && !gt(s) ? xs(Zt(s)) : {};
    }
    function Qs(s, a, o, l) {
      var b = s.constructor;
      switch (a) {
        case je:
          return Ce(s);
        case u:
        case y:
          return new b(+s);
        case re:
          return qs(s, l);
        case ze:
        case Fe:
        case Be:
        case $e:
        case He:
        case We:
        case Ge:
        case Ve:
        case Ke:
          return $s(s, l);
        case B:
          return js(s, l, o);
        case Pe:
        case ke:
          return new b(s);
        case Ue:
          return zs(s);
        case ne:
          return Fs(s, l, o);
        case qe:
          return Bs(s);
      }
    }
    function Js(s, a) {
      return a = a ?? i, !!a && (typeof s == "number" || zt.test(s)) && s > -1 && s % 1 == 0 && s < a;
    }
    function Xs(s) {
      var a = typeof s;
      return a == "string" || a == "number" || a == "symbol" || a == "boolean" ? s !== "__proto__" : s === null;
    }
    function Ys(s) {
      return !!tt && tt in s;
    }
    function gt(s) {
      var a = s && s.constructor, o = typeof a == "function" && a.prototype || ie;
      return s === o;
    }
    function k(s) {
      if (s != null) {
        try {
          return st.call(s);
        } catch {
        }
        try {
          return s + "";
        } catch {
        }
      }
      return "";
    }
    function Zs(s) {
      return Te(s, !0, !0);
    }
    function dt(s, a) {
      return s === a || s !== s && a !== a;
    }
    function en(s) {
      return tn(s) && D.call(s, "callee") && (!ts.call(s, "callee") || ae.call(s) == c);
    }
    var Me = Array.isArray;
    function _t(s) {
      return s != null && nn(s.length) && !pt(s);
    }
    function tn(s) {
      return rn(s) && _t(s);
    }
    var sn = ns || on;
    function pt(s) {
      var a = he(s) ? ae.call(s) : "";
      return a == p || a == S;
    }
    function nn(s) {
      return typeof s == "number" && s > -1 && s % 1 == 0 && s <= i;
    }
    function he(s) {
      var a = typeof s;
      return !!s && (a == "object" || a == "function");
    }
    function rn(s) {
      return !!s && typeof s == "object";
    }
    function Ae(s) {
      return _t(s) ? Os(s) : Us(s);
    }
    function an() {
      return [];
    }
    function on() {
      return !1;
    }
    n.exports = Zs;
  })(X, X.exports)), X.exports;
}
var vn = wn();
const O = /* @__PURE__ */ bn(vn);
class z {
  constructor({
    serial: e,
    clientId: t,
    text: r,
    metadata: i,
    headers: c,
    userClaim: h,
    action: u,
    version: y,
    timestamp: _,
    reactions: p
  }) {
    this.serial = e, this.clientId = t, this.text = r, this.metadata = i, this.headers = c, this.userClaim = h, this.action = u, this.version = y, this.timestamp = _, this.reactions = p, Object.freeze(this.version), Object.freeze(this.reactions), Object.freeze(this.reactions.multiple), Object.freeze(this.reactions.distinct), Object.freeze(this.reactions.unique), Object.freeze(this);
  }
  with(e) {
    if ("serial" in e)
      return this._getLatestMessageVersion(e);
    if (e.type === x.Created)
      throw new g.ErrorInfo(
        "unable to apply message event; unable to apply created event to existing message",
        d.InvalidArgument,
        400
      );
    if (e.type === Z.Summary) {
      if (e.messageSerial !== this.serial)
        throw new g.ErrorInfo(
          "unable to apply message event; event is for a different message",
          d.InvalidArgument,
          400
        );
      const t = {
        unique: O(e.reactions.unique),
        distinct: O(e.reactions.distinct),
        multiple: O(e.reactions.multiple)
      };
      return z._clone(this, { reactions: t });
    }
    return this._getLatestMessageVersion(e.message);
  }
  /**
   * Get the latest message version, based on the event.
   * If "this" is the latest version, return "this", otherwise clone the message and apply the reactions.
   * @param message The message to get the latest version of
   * @returns The latest message version
   */
  _getLatestMessageVersion(e) {
    if (e.serial !== this.serial)
      throw new g.ErrorInfo(
        "unable to apply message event; event is for a different message",
        d.InvalidArgument,
        400
      );
    return this.version.serial >= e.version.serial ? this : z._clone(e, { reactions: this.reactions });
  }
  // Clone a message, optionally replace the given fields
  static _clone(e, t) {
    return new z({
      serial: t?.serial ?? e.serial,
      clientId: t?.clientId ?? e.clientId,
      text: t?.text ?? e.text,
      metadata: t?.metadata ?? O(e.metadata),
      headers: t?.headers ?? O(e.headers),
      userClaim: t?.userClaim ?? e.userClaim,
      action: t?.action ?? e.action,
      version: t?.version ?? O(e.version),
      timestamp: t?.timestamp ?? e.timestamp,
      reactions: t?.reactions ?? O(e.reactions)
    });
  }
  copy(e = {}) {
    return z._clone(this, e);
  }
}
const Et = () => ({
  unique: {},
  distinct: {},
  multiple: {}
}), se = (n) => {
  if (!n || typeof n != "object")
    return {};
  const e = n, t = {};
  return e.headers && typeof e.headers == "object" && (t.headers = e.headers), typeof e.userClaim == "string" && (t.userClaim = e.userClaim), t;
}, Sn = (n) => {
  const e = n, t = e.data && typeof e.data == "object" ? e.data : {}, r = se(n.extras), i = e.clientId || "", c = t.text || "", h = new Date(e.timestamp || 0), u = e.serial || "", y = t.metadata && typeof t.metadata == "object" ? t.metadata : {}, _ = r.headers || {}, p = r.userClaim, S = {
    ...e.version,
    // Spec: CHA-M4k6
    serial: e.version.serial || u,
    // Spec: CHA-M4k7
    timestamp: new Date(e.version.timestamp || h)
  }, B = Object.values(L).includes(e.action) ? e.action : L.MessageCreate;
  return new z({
    serial: u,
    clientId: i,
    text: c,
    metadata: y,
    headers: _,
    userClaim: p,
    action: B,
    version: S,
    timestamp: h,
    reactions: Et()
  });
}, ee = (n, e, t) => {
  if (!n)
    throw new g.ErrorInfo(
      `unable to ${e}; ${t} must be a non-empty string`,
      d.InvalidArgument,
      400
    );
}, Rn = {
  "annotation.create": V.Create,
  "annotation.delete": V.Delete
};
class xt {
  constructor(e, t, r, i, c) {
    this._logger = e, this._options = t, this._api = r, this._roomName = i, this._channel = c, this._emitter = new C(), this._unsubscribeMessageEvents = F(c, this._processMessageEvent.bind(this)), this._options?.rawMessageReactions && (this._unsubscribeAnnotationEvents = F(c.annotations, this._processAnnotationEvent.bind(this))), this._defaultType = this._options?.defaultMessageReactionType ?? j.Distinct;
  }
  _processAnnotationEvent(e) {
    this._logger.trace("MessageReactions._processAnnotationEvent();", { event: e });
    const t = yn[e.type];
    if (!t) {
      this._logger.info("MessageReactions._processAnnotationEvent(); ignoring unknown reaction type", { event: e });
      return;
    }
    const r = Rn[e.action];
    if (!r) {
      this._logger.info("MessageReactions._processAnnotationEvent(); ignoring unknown reaction event type", { event: e });
      return;
    }
    const i = e.name ?? "", c = se(e.extras), h = {
      type: r,
      timestamp: new Date(e.timestamp),
      reaction: {
        messageSerial: e.messageSerial,
        type: t,
        name: i,
        clientId: e.clientId ?? "",
        userClaim: c.userClaim
      }
    };
    e.count ? h.reaction.count = e.count : r === V.Create && t === j.Multiple && (h.reaction.count = 1), this._emitter.emit(r, h);
  }
  _processMessageEvent(e) {
    if (this._logger.trace("MessageReactions._processMessageEvent();", { event: e }), e.action !== "message.summary")
      return;
    const t = e.serial, r = e.annotations.summary, i = r[ge.Unique] ?? {}, c = r[ge.Distinct] ?? {}, h = r[ge.Multiple] ?? {};
    this._emitter.emit(Z.Summary, {
      type: Z.Summary,
      messageSerial: t,
      reactions: {
        unique: i,
        distinct: c,
        multiple: h
      }
    });
  }
  /**
   * @inheritDoc
   */
  async send(e, t) {
    this._logger.trace("MessageReactions.send();", { messageSerial: e, params: t }), ee(e, "send message reaction", "messageSerial");
    let { type: r, count: i } = t;
    r || (r = this._defaultType), r === j.Multiple && !i && (i = 1);
    const c = { type: r, name: t.name };
    return i && (c.count = i), this._api.sendMessageReaction(this._roomName, e, c);
  }
  /**
   * @inheritDoc
   */
  async delete(e, t) {
    this._logger.trace("MessageReactions.delete();", { messageSerial: e, params: t }), ee(e, "delete message reaction", "messageSerial");
    let r = t?.type;
    if (r || (r = this._defaultType), r !== j.Unique && !t?.name)
      throw new g.ErrorInfo(
        `unable to delete reaction of type ${r}; name not specified`,
        d.InvalidArgument,
        400
      );
    const i = { type: r };
    return r !== j.Unique && (i.name = t?.name), this._api.deleteMessageReaction(this._roomName, e, i);
  }
  /**
   * @inheritDoc
   */
  subscribe(e) {
    this._logger.trace("MessageReactions.subscribe();");
    const t = T(e);
    return this._emitter.on(Z.Summary, t), {
      unsubscribe: () => {
        this._emitter.off(t);
      }
    };
  }
  /**
   * @inheritDoc
   */
  subscribeRaw(e) {
    if (this._logger.trace("MessageReactions.subscribeRaw();"), !this._options?.rawMessageReactions)
      throw new g.ErrorInfo(
        "unable to subscribe to message reactions; raw message reactions are not enabled",
        d.FeatureNotEnabledInRoom,
        400
      );
    const t = T(e);
    return this._emitter.on([V.Create, V.Delete], t), {
      unsubscribe: () => {
        this._emitter.off(t);
      }
    };
  }
  /**
   * Merges the channel options to add support for message reactions.
   * @param roomOptions The room options to merge for.
   * @returns A function that merges the channel options for the room with the ones required for presence.
   */
  static channelOptionMerger(e) {
    return (t) => (t.modes.includes("ANNOTATION_PUBLISH") || t.modes.push("ANNOTATION_PUBLISH"), e.messages.rawMessageReactions && !t.modes.includes("ANNOTATION_SUBSCRIBE") && t.modes.push("ANNOTATION_SUBSCRIBE"), t);
  }
  async clientReactions(e, t) {
    return this._logger.trace("MessageReactions.clientReactions();", { messageSerial: e, clientId: t }), ee(e, "get client reactions", "messageSerial"), this._api.getClientReactions(this._roomName, e, t);
  }
  /**
   * Disposes of the message reactions instance, removing all listeners and subscriptions.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */
  dispose() {
    this._logger.trace("DefaultMessageReactions.dispose();"), this._emitter.off(), this._unsubscribeMessageEvents(), this._unsubscribeAnnotationEvents?.(), this._logger.debug("DefaultMessageReactions.dispose(); disposed successfully");
  }
  /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */
  hasListeners() {
    return P(this._emitter);
  }
}
const te = (n) => {
  const e = {
    ...Et(),
    ...n.reactions
  };
  for (const c of ["unique", "distinct"]) {
    const h = e[c];
    for (const u of Object.keys(h)) {
      const y = h[u];
      y && !y.clipped && (y.clipped = !1);
    }
  }
  const t = e.multiple;
  for (const c of Object.keys(t)) {
    const h = t[c];
    h && (h.clipped || (h.clipped = !1), h.totalClientIds || (h.totalClientIds = 0));
  }
  const r = Object.values(L).includes(n.action) ? n.action : L.MessageCreate, i = {
    serial: n.version.serial,
    timestamp: new Date(n.version.timestamp),
    clientId: n.version.clientId,
    description: n.version.description,
    metadata: n.version.metadata
  };
  return new z({
    serial: n.serial,
    clientId: n.clientId,
    text: n.text,
    metadata: n.metadata,
    headers: n.headers,
    userClaim: n.userClaim,
    action: r,
    version: i,
    timestamp: new Date(n.timestamp),
    reactions: e
  });
}, Tn = /* @__PURE__ */ new Map([
  [L.MessageCreate, x.Created],
  [L.MessageUpdate, x.Updated],
  [L.MessageDelete, x.Deleted]
]);
var xe = /* @__PURE__ */ ((n) => (n.OldestFirst = "oldestFirst", n.NewestFirst = "newestFirst", n))(xe || {});
class Cn {
  /**
   * Constructs a new `DefaultMessages` instance.
   * @param roomName The unique identifier of the room.
   * @param options The room options for the messages.
   * @param channel An instance of the Realtime channel for the room.
   * @param chatApi An instance of the ChatApi.
   * @param logger An instance of the Logger.
   */
  constructor(e, t, r, i, c) {
    this._pendingPromiseRejecters = /* @__PURE__ */ new Set(), this._pendingAttachListeners = /* @__PURE__ */ new Set(), this._emitter = new C(), this._roomName = e, this._options = t, this._channel = r, this._chatApi = i, this._logger = c, this._listenerSubscriptionPoints = /* @__PURE__ */ new Map(), this._reactions = new xt(this._logger, t, this._chatApi, this._roomName, this._channel);
    const h = this._processEvent.bind(this), u = (_) => {
      this._handleAttach(_.resumed);
    }, y = (_) => {
      _.current === "attached" && _.previous === "attached" && this._handleAttach(_.resumed);
    };
    this._unsubscribeMessageEvents = F(this._channel, [Dt.ChatMessage], h), this._offChannelAttached = E(this._channel, "attached", u), this._offChannelUpdate = E(this._channel, "update", y);
  }
  /**
   * @inheritdoc
   */
  get reactions() {
    return this._reactions;
  }
  /**
   * @inheritdoc
   */
  async _getBeforeSubscriptionStart(e, t) {
    this._logger.trace("DefaultSubscriptionManager.getBeforeSubscriptionStart();");
    const r = this._listenerSubscriptionPoints.get(e);
    if (r === void 0)
      throw this._logger.error("DefaultSubscriptionManager.getBeforeSubscriptionStart(); listener has not been subscribed"), new g.ErrorInfo(
        "unable to query history; listener has not been subscribed",
        d.ListenerNotSubscribed,
        400
      );
    const i = await r;
    return this._chatApi.history(this._roomName, {
      ...t,
      orderBy: "newestFirst",
      ...i
    });
  }
  /**
   * Handle the case where the channel experiences a detach and reattaches.
   * @param fromResume Whether the attach is from a resume operation.
   */
  _handleAttach(e) {
    if (this._logger.trace("DefaultSubscriptionManager.handleAttach();"), e) return;
    const t = this._subscribeAtChannelAttach();
    for (const [r] of this._listenerSubscriptionPoints.entries())
      this._listenerSubscriptionPoints.set(r, t);
  }
  /**
   * Create a promise that resolves with the attachSerial of the channel or the serial of the latest message.
   * @returns A promise that resolves to an object containing fromSerial and subscriptionPoint.
   */
  async _resolveSubscriptionStart() {
    const e = this._getChannelProperties();
    if (e.state === "attached") {
      if (e.properties.channelSerial)
        return { fromSerial: e.properties.channelSerial };
      throw this._logger.error("DefaultSubscriptionManager.handleAttach(); channelSerial is undefined"), new g.ErrorInfo(
        "unable to query messages; channel is attached but channelSerial is not defined",
        d.ChannelSerialNotDefined,
        500
      );
    }
    return this._subscribeAtChannelAttach();
  }
  _getChannelProperties() {
    return this._channel;
  }
  async _subscribeAtChannelAttach() {
    const e = this._getChannelProperties();
    return new Promise((t, r) => {
      this._pendingPromiseRejecters.add(r);
      const i = () => {
        this._pendingPromiseRejecters.delete(r);
      };
      if (e.state === "attached") {
        this._logger.debug("Messages._subscribeAtChannelAttach(); channel is attached already, using attachSerial", {
          attachSerial: e.properties.attachSerial
        }), i(), e.properties.attachSerial ? t({ fromSerial: e.properties.attachSerial }) : (this._logger.error("DefaultSubscriptionManager.handleAttach(); attachSerial is undefined"), i(), r(
          new g.ErrorInfo(
            "unable to query messages; channel is attached but attachSerial is not defined",
            d.ChannelSerialNotDefined,
            500
          )
        ));
        return;
      }
      const c = dn(e, "attached", () => {
        this._logger.debug("Messages._subscribeAtChannelAttach(); channel is now attached, using attachSerial", {
          attachSerial: e.properties.attachSerial
        }), i(), this._pendingAttachListeners.delete(c), e.properties.attachSerial ? t({ fromSerial: e.properties.attachSerial }) : (this._logger.error("DefaultSubscriptionManager.handleAttach(); attachSerial is undefined"), r(
          new g.ErrorInfo(
            "unable to query messages; channel is attached but attachSerial is not defined",
            d.ChannelSerialNotDefined,
            500
          )
        ));
      });
      this._pendingAttachListeners.add(c);
    });
  }
  /**
   * @inheritdoc
   */
  async history(e) {
    return this._logger.trace("Messages.query();"), this._chatApi.history(this._roomName, e);
  }
  /**
   * @inheritdoc
   */
  async get(e) {
    return this._logger.trace("Messages.get();", { serial: e }), this._chatApi.getMessage(this._roomName, e);
  }
  /**
   * @inheritdoc
   */
  async send(e) {
    this._logger.trace("Messages.send();", { params: e });
    const { text: t, metadata: r, headers: i } = e, c = await this._chatApi.sendMessage(this._roomName, { text: t, headers: i, metadata: r });
    return te(c);
  }
  /**
   * @inheritdoc
   */
  async delete(e, t) {
    this._logger.trace("Messages.delete();", { serial: e, details: t }), ee(e, "delete message", "serial");
    const r = await this._chatApi.deleteMessage(this._roomName, e, t);
    return te(r);
  }
  /**
   * @inheritdoc
   */
  async update(e, t, r) {
    this._logger.trace("Messages.update();", { serial: e, updateParams: t, details: r }), ee(e, "update message", "serial");
    const i = await this._chatApi.updateMessage(this._roomName, e, {
      message: {
        text: t.text,
        metadata: t.metadata,
        headers: t.headers
      },
      ...r
    });
    return this._logger.debug("Messages.update(); message update successfully", { updateParams: t }), te(i);
  }
  /**
   * @inheritdoc
   */
  subscribe(e) {
    this._logger.trace("Messages.subscribe();");
    const t = T(e);
    this._emitter.on(
      [x.Created, x.Updated, x.Deleted],
      t
    );
    const r = this._resolveSubscriptionStart();
    return r.catch(() => {
      this._logger.debug("Messages.subscribe(); subscription point was not resolved before the room was released");
    }), this._listenerSubscriptionPoints.set(t, r), {
      unsubscribe: () => {
        this._listenerSubscriptionPoints.delete(t), this._logger.trace("Messages.unsubscribe();"), this._emitter.off(t);
      },
      historyBeforeSubscribe: async (i) => this._getBeforeSubscriptionStart(t, i)
    };
  }
  _processEvent(e) {
    this._logger.trace("Messages._processEvent();", {
      channelEventMessage: e
    });
    const { action: t } = e, r = Tn.get(t);
    if (!r) {
      this._logger.debug("Messages._processEvent(); received unknown message action", { action: t });
      return;
    }
    const i = Sn(e);
    this._emitter.emit(r, { type: r, message: i });
  }
  /**
   * Disposes of the messages instance, removing all listeners and subscriptions.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */
  dispose() {
    this._logger.trace("DefaultMessages.dispose();"), this._emitter.off();
    const e = new g.ErrorInfo(
      "unable to query messages; room has been disposed",
      d.ResourceDisposed,
      400
    );
    for (const t of this._pendingPromiseRejecters)
      try {
        t(e);
      } catch {
      }
    this._pendingPromiseRejecters.clear(), this._listenerSubscriptionPoints.clear();
    for (const t of this._pendingAttachListeners)
      t();
    this._pendingAttachListeners.clear(), this._unsubscribeMessageEvents(), this._offChannelAttached(), this._offChannelUpdate(), this._reactions.dispose(), this._logger.debug("DefaultMessages.dispose(); disposed successfully");
  }
  /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */
  hasListeners() {
    return P(this._emitter);
  }
}
class Mn {
  constructor(e, t) {
    this._apiProtocolVersion = 4, this._realtime = e, this._logger = t;
  }
  async history(e, t) {
    const r = { ...t };
    if (t.orderBy)
      switch (t.orderBy) {
        case xe.NewestFirst: {
          r.direction = "backwards";
          break;
        }
        case xe.OldestFirst: {
          r.direction = "forwards";
          break;
        }
        default:
          throw new g.ErrorInfo(
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `unable to query messages; invalid orderBy value: ${t.orderBy}`,
            d.InvalidArgument,
            400
          );
      }
    const i = await this._makeAuthorizedPaginatedRequest(
      this._roomUrl(e, "/messages"),
      r
    );
    return this._recursivePaginateMessages(i);
  }
  _recursivePaginateMessages(e) {
    const t = {};
    return t.items = e.items.map((r) => te(r)), t.next = async () => {
      const r = await e.next();
      return r ? this._recursivePaginateMessages(r) : null;
    }, t.first = async () => {
      const r = await e.first();
      return this._recursivePaginateMessages(r);
    }, t.current = async () => {
      const r = await e.current();
      return this._recursivePaginateMessages(r);
    }, t.hasNext = () => e.hasNext(), t.isLast = () => e.isLast(), { ...e, ...t };
  }
  async getMessage(e, t) {
    const r = await this._makeAuthorizedRequest(this._messageUrl(e, t), "GET");
    return te(r);
  }
  async deleteMessage(e, t, r) {
    const i = {
      ...r?.description && { description: r.description },
      ...r?.metadata && { metadata: r.metadata }
    };
    return this._makeAuthorizedRequest(
      this._messageUrl(e, t, "/delete"),
      "POST",
      i,
      {}
    );
  }
  async sendMessage(e, t) {
    const r = {
      text: t.text,
      ...t.metadata && { metadata: t.metadata },
      ...t.headers && { headers: t.headers }
    };
    return this._makeAuthorizedRequest(this._roomUrl(e, "/messages"), "POST", r);
  }
  async updateMessage(e, t, r) {
    return this._makeAuthorizedRequest(this._messageUrl(e, t), "PUT", r);
  }
  async sendMessageReaction(e, t, r) {
    return this._makeAuthorizedRequest(this._messageUrl(e, t, "/reactions"), "POST", r);
  }
  async deleteMessageReaction(e, t, r) {
    return this._makeAuthorizedRequest(this._messageUrl(e, t, "/reactions"), "DELETE", void 0, r);
  }
  async getClientReactions(e, t, r) {
    const i = r ? { forClientId: r } : {};
    return this._makeAuthorizedRequest(
      this._messageUrl(e, t, "/client-reactions"),
      "GET",
      void 0,
      i
    );
  }
  async getOccupancy(e) {
    return this._makeAuthorizedRequest(this._roomUrl(e, "/occupancy"), "GET");
  }
  async _makeAuthorizedRequest(e, t, r, i) {
    return (await this._doRequest(e, t, i, r)).items[0];
  }
  async _makeAuthorizedPaginatedRequest(e, t, r) {
    return this._doRequest(e, "GET", t, r);
  }
  async _doRequest(e, t, r, i) {
    const c = await this._realtime.request(t, e, this._apiProtocolVersion, r, i);
    if (!c.success)
      throw this._logger.error("ChatApi._doRequest(); failed to make request", {
        url: e,
        method: t,
        statusCode: c.statusCode,
        errorCode: c.errorCode,
        errorMessage: c.errorMessage
      }), new g.ErrorInfo(c.errorMessage, c.errorCode, c.statusCode);
    return c;
  }
  /**
   * Returns a URL for a specific room.
   * @param roomName Name of the room
   * @param suffix The suffix to add to the room URL, prefixed with /
   * @returns string The formatted URL
   */
  _roomUrl(e, t = "") {
    return `/chat/v4/rooms/${encodeURIComponent(e)}${t}`;
  }
  /**
   * Returns a URL for a specific message in the room.
   * @param roomName string Name of the room
   * @param serial string The serial of the message
   * @param suffix The suffix to add to the room URL, prefixed with /
   * @returns string The formatted URL
   */
  _messageUrl(e, t, r = "") {
    return `${this._roomUrl(e, "/messages")}/${encodeURIComponent(t)}${r}`;
  }
}
const An = (n) => `${n}::$chat`, _e = "1.2.0", Lt = `chat-js/${_e}`, In = `chat-react/${_e}`, Pt = ["PUBLISH", "SUBSCRIBE"], Dn = {
  params: { agent: Lt },
  attachOnSubscribe: !1,
  modes: Pt
}, On = {
  // Spec: CHA-IN1b1
  params: { agent: `${Lt} ${In}` },
  attachOnSubscribe: !1,
  modes: Pt
};
class En {
  constructor(e, t, r, i) {
    r.trace("ChannelManager();", { isReact: i }), this._realtime = t, this._logger = r, this._isReact = i, this._registeredOptions = this._defaultChannelOptions(), this._channelId = An(e);
  }
  mergeOptions(e) {
    if (this._logger.trace("ChannelManager.mergeOptions();"), this._resolvedChannel)
      throw this._logger.error("unable to modify channel options; channel has already been requested"), new g.ErrorInfo(
        "unable to modify channel options; channel has already been requested",
        d.ChannelOptionsCannotBeModified,
        400
      );
    this._registeredOptions = e(this._registeredOptions);
  }
  get() {
    return this._logger.trace("ChannelManager.get();"), this._resolvedChannel ??= this._realtime.channels.get(this._channelId, this._registeredOptions), this._resolvedChannel;
  }
  release() {
    this._logger.trace("ChannelManager.release();", { channelId: this._channelId }), this._resolvedChannel && this._realtime.channels.release(this._channelId);
  }
  _defaultChannelOptions() {
    this._logger.trace("ChannelManager._defaultChannelOptions();");
    const e = this._isReact ? On : Dn;
    return this._logger.trace(this._isReact ? "using react channel options" : "using default channel options"), { ...e, modes: [...e.modes ?? []] };
  }
}
const xn = (n) => {
  const e = n;
  let t = 0, r = 0;
  if (!e.data || typeof e.data != "object")
    return { connections: t, presenceMembers: r };
  const { metrics: i } = e.data;
  return !i || typeof i != "object" ? { connections: t, presenceMembers: r } : (typeof i.connections == "number" && Number.isInteger(i.connections) && (t = i.connections), typeof i.presenceMembers == "number" && Number.isInteger(i.presenceMembers) && (r = i.presenceMembers), { connections: t, presenceMembers: r });
};
class Tt {
  /**
   * Constructs a new `DefaultOccupancy` instance.
   * @param roomName The unique identifier of the room.
   * @param channel An instance of the Realtime channel.
   * @param chatApi An instance of the ChatApi.
   * @param logger An instance of the Logger.
   * @param roomOptions The room options.
   */
  constructor(e, t, r, i, c) {
    this._emitter = new C(), this._roomName = e, this._channel = t, this._chatApi = r, this._logger = i, this._roomOptions = c;
    const h = this._internalOccupancyListener.bind(this);
    this._roomOptions.occupancy.enableEvents ? (this._logger.debug("DefaultOccupancy(); subscribing to occupancy events"), this._unsubscribeOccupancyEvents = F(
      this._channel,
      [Ot.Occupancy],
      h
    )) : this._unsubscribeOccupancyEvents = () => {
    };
  }
  /**
   * @inheritdoc
   */
  subscribe(e) {
    if (this._logger.trace("Occupancy.subscribe();"), !this._roomOptions.occupancy.enableEvents)
      throw new g.ErrorInfo(
        "unable to subscribe to occupancy; occupancy events are not enabled in room options",
        d.FeatureNotEnabledInRoom,
        400
      );
    const t = T(e);
    return this._emitter.on(t), {
      unsubscribe: () => {
        this._logger.trace("Occupancy.unsubscribe();"), this._emitter.off(t);
      }
    };
  }
  /**
   * @inheritdoc
   */
  async get() {
    return this._logger.trace("Occupancy.get();"), this._chatApi.getOccupancy(this._roomName);
  }
  /**
   * @inheritdoc
   */
  get current() {
    if (this._logger.trace("Occupancy.current();"), !this._roomOptions.occupancy.enableEvents)
      throw new g.ErrorInfo(
        "unable to get current occupancy; occupancy events are not enabled in room options",
        d.FeatureNotEnabledInRoom,
        400
      );
    return this._latestOccupancyData;
  }
  /**
   * An internal listener that listens for occupancy events from the underlying channel and translates them into
   * occupancy events for the public API.
   * @param message The inbound message containing occupancy data.
   */
  _internalOccupancyListener(e) {
    this._logger.trace("Occupancy._internalOccupancyListener();", e), this._latestOccupancyData = xn(e), this._emitter.emit(Ee.Updated, {
      type: Ee.Updated,
      occupancy: this._latestOccupancyData
    });
  }
  /**
   * Merges the channel options for the room with the ones required for occupancy.
   * @param roomOptions The internal room options.
   * @returns A function that merges the channel options for the room with the ones required for occupancy.
   */
  static channelOptionMerger(e) {
    return (t) => e.occupancy.enableEvents ? { ...t, params: { ...t.params, occupancy: "metrics" } } : t;
  }
  /**
   * Disposes of the occupancy instance, removing all listeners and subscriptions.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */
  dispose() {
    this._logger.trace("DefaultOccupancy.dispose();"), this._unsubscribeOccupancyEvents(), this._emitter.off(), this._logger.debug("DefaultOccupancy.dispose(); disposed successfully");
  }
  /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */
  hasListeners() {
    return P(this._emitter);
  }
}
class Ct {
  /**
   * Constructs a new `DefaultPresence` instance.
   * @param channel The Realtime channel instance.
   * @param logger An instance of the Logger.
   * @param options The room options.
   */
  constructor(e, t, r) {
    this._emitter = new C(), this._stateEmitter = new C(), this._presenceState = {
      present: !1
    }, this.subscribeToEvents = (u) => {
      this._emitter.emit(u.action, {
        type: u.action,
        member: this._realtimeMemberToPresenceMember(u)
      });
    }, this._channel = e, this._logger = t, this._options = r;
    const i = this.subscribeToEvents.bind(this), c = (u) => {
      if (u.reason?.code === 91004) {
        this._logger.debug("Presence auto-reentry failed", { reason: u.reason }), this._emitPresenceStateChange(!1, u.reason);
        return;
      }
      if (u.current === "detached") {
        this._emitPresenceStateChange(!1);
        return;
      }
    }, h = (u) => {
      this._emitPresenceStateChange(!1, u.reason);
    };
    this._offChannelUpdate = E(this._channel, "update", c), this._offChannelDetach = E(this._channel, ["detached", "failed"], h), this._unsubscribePresenceEvents = F(this._channel.presence, i);
  }
  /**
   * @inheritDoc
   */
  async get(e) {
    return this._logger.trace("Presence.get()", { params: e }), this._assertChannelState(), (await this._channel.presence.get(e)).map((r) => this._realtimeMemberToPresenceMember(r));
  }
  /**
   * @inheritDoc
   */
  async isUserPresent(e) {
    return this._logger.trace("Presence.isUserPresent()", { clientId: e }), this._assertChannelState(), (await this._channel.presence.get({ clientId: e })).length > 0;
  }
  /**
   * @inheritDoc
   */
  async enter(e) {
    this._logger.trace("Presence.enter()", { data: e }), this._assertChannelState();
    try {
      await this._channel.presence.enter(e), this._emitPresenceStateChange(!0);
    } catch (t) {
      throw this._emitPresenceStateChange(!1, t), t;
    }
  }
  /**
   * @inheritDoc
   */
  async update(e) {
    this._logger.trace("Presence.update()", { data: e }), this._assertChannelState();
    try {
      await this._channel.presence.update(e), this._emitPresenceStateChange(!0);
    } catch (t) {
      throw this._emitPresenceStateChange(!1, t), t;
    }
  }
  /**
   * @inheritDoc
   */
  async leave(e) {
    this._logger.trace("Presence.leave()", { data: e }), this._assertChannelState();
    try {
      await this._channel.presence.leave(e), this._emitPresenceStateChange(!1);
    } catch (t) {
      throw this._emitPresenceStateChange(!1, t), t;
    }
  }
  /**
   * @inheritDoc
   */
  subscribe(e) {
    if (this._logger.trace("Presence.subscribe()"), !this._options.presence.enableEvents)
      throw this._logger.error("unable to subscribe to presence; presence events are not enabled"), new g.ErrorInfo(
        "unable to subscribe to presence; presence events are not enabled",
        d.FeatureNotEnabledInRoom,
        400
      );
    const t = T(e);
    return this._emitter.on(t), {
      unsubscribe: () => {
        this._logger.trace("Presence.unsubscribe();"), this._emitter.off(t);
      }
    };
  }
  /**
   * Merges the channel options for the room with the ones required for presence.
   * @param roomOptions The room options to merge for.
   * @returns A function that merges the channel options for the room with the ones required for presence.
   */
  static channelOptionMerger(e) {
    return (t) => (t.modes.includes("PRESENCE") || t.modes.push("PRESENCE"), e.presence.enableEvents && !t.modes.includes("PRESENCE_SUBSCRIBE") && t.modes.push("PRESENCE_SUBSCRIBE"), t);
  }
  /**
   * Disposes of the presence instance, removing all listeners and subscriptions.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */
  dispose() {
    this._logger.trace("DefaultPresence.dispose();"), this._emitter.off(), this._unsubscribePresenceEvents(), this._offChannelUpdate(), this._offChannelDetach(), this._logger.debug("DefaultPresence.dispose(); disposed successfully");
  }
  /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */
  hasListeners() {
    return P(this._emitter);
  }
  /**
   * Converts an Ably presence message to a presence member.
   * @param member The Ably presence message to convert.
   * @returns The presence member.
   */
  _realtimeMemberToPresenceMember(e) {
    const t = se(e.extras);
    return {
      // Note that we're casting `extras` from ably-js's `any` to our `JsonObject | undefined`; although ably-js's types don't express it we can assume this type per https://sdk.ably.com/builds/ably/specification/main/features/#TP3i.
      ...e,
      data: e.data,
      updatedAt: new Date(e.timestamp),
      userClaim: t.userClaim
    };
  }
  _assertChannelState() {
    if (this._channel.state !== "attaching" && this._channel.state !== "attached")
      throw this._logger.error("unable to perform presence operation; room is not attached"), new g.ErrorInfo(
        "unable to perform presence operation; room is not attached",
        d.RoomInInvalidState,
        400
      );
  }
  /**
   * Private method to emit the presence state change event.
   * @param present - Whether the user is present
   * @param error - Optional error information
   */
  _emitPresenceStateChange(e, t) {
    this._logger.trace("Presence._emitPresenceStateChange()", { present: e, error: t });
    const r = { ...this._presenceState };
    this._presenceState = { present: e };
    const i = {
      previous: r,
      current: this._presenceState,
      error: t
    };
    this._stateEmitter.emit("presence.state.change", i);
  }
  /**
   * @param listener The listener to subscribe to presence state changes.
   * @returns A subscription that can be used to unsubscribe from presence state changes.
   * @internal
   */
  onPresenceStateChange(e) {
    this._logger.trace("Presence.onPresenceStateChange()");
    const t = T(e);
    return this._stateEmitter.on("presence.state.change", t), {
      unsubscribe: () => {
        this._logger.trace("Presence.unsubscribeFromPresenceStateChanges()"), this._stateEmitter.off(t);
      }
    };
  }
}
const de = new Error("request for lock canceled");
var Ln = function(n, e, t, r) {
  function i(c) {
    return c instanceof t ? c : new t(function(h) {
      h(c);
    });
  }
  return new (t || (t = Promise))(function(c, h) {
    function u(p) {
      try {
        _(r.next(p));
      } catch (S) {
        h(S);
      }
    }
    function y(p) {
      try {
        _(r.throw(p));
      } catch (S) {
        h(S);
      }
    }
    function _(p) {
      p.done ? c(p.value) : i(p.value).then(u, y);
    }
    _((r = r.apply(n, e || [])).next());
  });
};
class Pn {
  constructor(e, t = de) {
    this._value = e, this._cancelError = t, this._queue = [], this._weightedWaiters = [];
  }
  acquire(e = 1, t = 0) {
    if (e <= 0)
      throw new Error(`invalid weight ${e}: must be positive`);
    return new Promise((r, i) => {
      const c = { resolve: r, reject: i, weight: e, priority: t }, h = Nt(this._queue, (u) => t <= u.priority);
      h === -1 && e <= this._value ? this._dispatchItem(c) : this._queue.splice(h + 1, 0, c);
    });
  }
  runExclusive(e) {
    return Ln(this, arguments, void 0, function* (t, r = 1, i = 0) {
      const [c, h] = yield this.acquire(r, i);
      try {
        return yield t(c);
      } finally {
        h();
      }
    });
  }
  waitForUnlock(e = 1, t = 0) {
    if (e <= 0)
      throw new Error(`invalid weight ${e}: must be positive`);
    return this._couldLockImmediately(e, t) ? Promise.resolve() : new Promise((r) => {
      this._weightedWaiters[e - 1] || (this._weightedWaiters[e - 1] = []), Nn(this._weightedWaiters[e - 1], { resolve: r, priority: t });
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(e) {
    this._value = e, this._dispatchQueue();
  }
  release(e = 1) {
    if (e <= 0)
      throw new Error(`invalid weight ${e}: must be positive`);
    this._value += e, this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((e) => e.reject(this._cancelError)), this._queue = [];
  }
  _dispatchQueue() {
    for (this._drainUnlockWaiters(); this._queue.length > 0 && this._queue[0].weight <= this._value; )
      this._dispatchItem(this._queue.shift()), this._drainUnlockWaiters();
  }
  _dispatchItem(e) {
    const t = this._value;
    this._value -= e.weight, e.resolve([t, this._newReleaser(e.weight)]);
  }
  _newReleaser(e) {
    let t = !1;
    return () => {
      t || (t = !0, this.release(e));
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0)
      for (let e = this._value; e > 0; e--) {
        const t = this._weightedWaiters[e - 1];
        t && (t.forEach((r) => r.resolve()), this._weightedWaiters[e - 1] = []);
      }
    else {
      const e = this._queue[0].priority;
      for (let t = this._value; t > 0; t--) {
        const r = this._weightedWaiters[t - 1];
        if (!r)
          continue;
        const i = r.findIndex((c) => c.priority <= e);
        (i === -1 ? r : r.splice(0, i)).forEach(((c) => c.resolve()));
      }
    }
  }
  _couldLockImmediately(e, t) {
    return (this._queue.length === 0 || this._queue[0].priority < t) && e <= this._value;
  }
}
function Nn(n, e) {
  const t = Nt(n, (r) => e.priority <= r.priority);
  n.splice(t + 1, 0, e);
}
function Nt(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    if (e(n[t]))
      return t;
  return -1;
}
var Un = function(n, e, t, r) {
  function i(c) {
    return c instanceof t ? c : new t(function(h) {
      h(c);
    });
  }
  return new (t || (t = Promise))(function(c, h) {
    function u(p) {
      try {
        _(r.next(p));
      } catch (S) {
        h(S);
      }
    }
    function y(p) {
      try {
        _(r.throw(p));
      } catch (S) {
        h(S);
      }
    }
    function _(p) {
      p.done ? c(p.value) : i(p.value).then(u, y);
    }
    _((r = r.apply(n, e || [])).next());
  });
};
class Ut {
  constructor(e) {
    this._semaphore = new Pn(1, e);
  }
  acquire() {
    return Un(this, arguments, void 0, function* (e = 0) {
      const [, t] = yield this._semaphore.acquire(1, e);
      return t;
    });
  }
  runExclusive(e, t = 0) {
    return this._semaphore.runExclusive(() => e(), 1, t);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(e = 0) {
    return this._semaphore.waitForUnlock(1, e);
  }
  release() {
    this._semaphore.isLocked() && this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
}
var m = /* @__PURE__ */ ((n) => (n.Initializing = "initializing", n.Initialized = "initialized", n.Attaching = "attaching", n.Attached = "attached", n.Detaching = "detaching", n.Detached = "detached", n.Suspended = "suspended", n.Failed = "failed", n.Releasing = "releasing", n.Released = "released", n))(m || {});
class kn {
  /**
   * Constructs a new DefaultRoomLifecycle instance.
   * @param logger An instance of the Logger.
   */
  constructor(e) {
    this._status = "initialized", this._emitter = new C(), this._logger = e;
  }
  /**
   * @inheritdoc
   */
  get status() {
    return this._status;
  }
  /**
   * @inheritdoc
   */
  get error() {
    return this._error;
  }
  /**
   * @inheritdoc
   */
  onChange(e) {
    const t = T(e);
    return this._emitter.on(t), {
      off: () => {
        this._emitter.off(t);
      }
    };
  }
  setStatus(e) {
    const t = {
      current: e.status,
      error: e.error,
      previous: this._status
    };
    this._status = t.current, this._error = t.error, this._logger.info("room status changed", { ...t }), this._emitter.emit(t.current, t);
  }
  /**
   * Disposes of the room lifecycle instance, removing all listeners.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */
  dispose() {
    this._logger.trace("DefaultRoomLifecycle.dispose();"), this._emitter.off(), this._logger.debug("DefaultRoomLifecycle.dispose(); disposed successfully");
  }
  /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */
  hasListeners() {
    return P(this._emitter);
  }
}
class qn {
  constructor(e, t, r) {
    this._channelManager = e, this._roomLifecycle = t, this._logger = r, this._eventEmitter = new C(), this._hasAttachedOnce = !1, this._isExplicitlyDetached = !1, this._mutex = new Ut();
    const i = this._channelStateListener.bind(this), c = this._discontinuityOnAttachedListener.bind(this), h = this._discontinuityOnUpdateListener.bind(this), u = this._channelManager.get();
    this._unsubscribeChannelStateListener = E(u, i), this._offDiscontinuityAttached = E(u, "attached", c), this._offDiscontinuityUpdate = E(u, "update", h);
  }
  /**
   * Registers a handler for discontinuity events.
   * @param handler The function to be called when a discontinuity is detected
   * @returns An object with an off() method to deregister the handler
   */
  onDiscontinuity(e) {
    this._logger.trace("RoomLifecycleManager.onDiscontinuity()");
    const t = T(e);
    return this._eventEmitter.on(J.Discontinuity, t), {
      off: () => {
        this._eventEmitter.off(J.Discontinuity, t);
      }
    };
  }
  /**
   * Attaches to the channel and updates room status accordingly.
   * If the room is released/releasing, this operation fails.
   * If already attached, this is a no-op.
   */
  async attach() {
    await this._mutex.runExclusive(
      async () => {
        if (this._logger.trace("RoomLifecycleManager.attach();"), this._checkRoomNotReleasing("attach"), this._roomStatusIs(m.Attached)) {
          this._logger.debug("RoomLifecycleManager.attach(); room already attached, no-op");
          return;
        }
        const e = this._channelManager.get();
        this._logger.debug("RoomLifecycleManager.attach(); attaching room", {
          channelState: e.state
        });
        try {
          this._setStatus(m.Attaching), await e.attach(), this._setStatus(m.Attached), this._isExplicitlyDetached = !1, this._hasAttachedOnce = !0, this._logger.debug("RoomLifecycleManager.attach(); room attached successfully");
        } catch (t) {
          const r = t, i = new g.ErrorInfo(
            `failed to attach room: ${r.message}`,
            r.code,
            r.statusCode,
            r
          ), c = this._mapChannelStateToRoomStatus(e.state);
          throw this._setStatus(c, i), i;
        }
      },
      1
      /* AttachDetach */
    );
  }
  /**
   * Detaches from the channel and updates room status accordingly.
   * If the room is released/releasing, this operation fails.
   * If already detached, this is a no-op.
   */
  async detach() {
    await this._mutex.runExclusive(
      async () => {
        if (this._logger.trace("RoomLifecycleManager.detach();"), this._roomStatusIs(m.Failed))
          throw new g.ErrorInfo("unable to detach room; room is in failed state", d.RoomInInvalidState, 400);
        if (this._checkRoomNotReleasing("detach"), this._roomStatusIs(m.Detached)) {
          this._logger.debug("RoomLifecycleManager.detach(); room already detached, no-op");
          return;
        }
        const e = this._channelManager.get();
        this._logger.debug("RoomLifecycleManager.detach(); detaching room", {
          channelState: e.state
        });
        try {
          this._setStatus(m.Detaching), await e.detach(), this._isExplicitlyDetached = !0, this._setStatus(m.Detached), this._logger.debug("RoomLifecycleManager.detach(); room detached successfully");
        } catch (t) {
          const r = t, i = new g.ErrorInfo(
            `failed to detach room: ${r.message}`,
            r.code,
            r.statusCode,
            r
          ), c = this._mapChannelStateToRoomStatus(e.state);
          throw this._setStatus(c, i), i;
        }
      },
      1
      /* AttachDetach */
    );
  }
  /**
   * Releases the room by detaching the channel and releasing it from the channel manager.
   * If the channel is in a failed state, skips the detach operation.
   * Will retry detach until successful unless in failed state.
   */
  async release() {
    await this._mutex.runExclusive(
      async () => {
        if (this._logger.trace("RoomLifecycleManager.release();"), this._roomStatusIs(m.Released)) {
          this._logger.debug("RoomLifecycleManager.release(); room already released, no-op");
          return;
        }
        if (this._roomStatusIs(m.Initialized) || this._roomStatusIs(m.Detached)) {
          this._logger.debug("RoomLifecycleManager.release(); room is initialized or detached, releasing immediately", {
            status: this._roomLifecycle.status
          }), this._releaseChannel();
          return;
        }
        this._setStatus(m.Releasing);
        const e = this._channelManager.get();
        this._logger.debug("RoomLifecycleManager.release(); attempting channel detach before release", {
          channelState: e.state
        }), await this._channelDetachLoop(e), this._releaseChannel();
      },
      0
      /* Release */
    );
  }
  /**
   * Maps an Ably channel state to a room status
   * @param channelState The Ably channel state to map.
   * @returns The corresponding room status.
   */
  _mapChannelStateToRoomStatus(e) {
    switch (e) {
      case "initialized":
        return m.Initialized;
      case "attaching":
        return m.Attaching;
      case "attached":
        return m.Attached;
      case "detaching":
        return m.Detaching;
      case "detached":
        return m.Detached;
      case "suspended":
        return m.Suspended;
      case "failed":
        return m.Failed;
      default:
        return this._logger.error("RoomLifecycleManager._mapChannelStateToRoomStatus(); unknown channel state", {
          channelState: e
        }), m.Failed;
    }
  }
  _checkRoomNotReleasing(e) {
    switch (this._roomLifecycle.status) {
      case m.Released:
        throw new g.ErrorInfo(`unable to ${e} room; room is released`, d.RoomInInvalidState, 400);
      case m.Releasing:
        throw new g.ErrorInfo(
          `unable to ${e} room; room is currently releasing`,
          d.RoomInInvalidState,
          400
        );
    }
  }
  /**
   * Returns the current room status
   * @param status The room status to check against.
   * @returns true if the room status matches, false otherwise.
   */
  _roomStatusIs(e) {
    return this._roomLifecycle.status === e;
  }
  /**
   * Disposes of the room lifecycle manager, removing all listeners and subscriptions.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */
  dispose() {
    this._unsubscribeChannelStateListener(), this._offDiscontinuityAttached(), this._offDiscontinuityUpdate(), this._eventEmitter.off();
  }
  /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */
  hasListeners() {
    return P(this._eventEmitter);
  }
  _channelStateListener(e) {
    if (this._logger.debug("RoomLifecycleManager.channel state changed", {
      oldState: e.previous,
      newState: e.current,
      reason: e.reason,
      resumed: e.resumed
    }), this._operationInProgress()) {
      this._logger.debug(
        "RoomLifecycleManager._startMonitoringChannelState(); ignoring channel state change - operation in progress",
        {
          status: this._roomLifecycle.status
        }
      );
      return;
    }
    const t = this._mapChannelStateToRoomStatus(e.current);
    this._setStatus(t, e.reason);
  }
  _discontinuityOnAttachedListener(e) {
    if (!e.resumed && this._hasAttachedOnce && !this._isExplicitlyDetached) {
      const t = new g.ErrorInfo(
        "discontinuity detected",
        d.RoomDiscontinuity,
        e.reason?.statusCode ?? 0,
        e.reason
      );
      this._logger.warn("RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected", {
        error: t
      }), this._eventEmitter.emit(J.Discontinuity, t);
    }
  }
  _discontinuityOnUpdateListener(e) {
    if (!e.resumed && this._hasAttachedOnce && !this._isExplicitlyDetached && e.current === "attached" && e.previous === "attached") {
      const t = new g.ErrorInfo(
        "discontinuity detected",
        d.RoomDiscontinuity,
        e.reason?.statusCode ?? 0,
        e.reason
      );
      this._logger.warn("RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected", {
        error: t
      }), this._eventEmitter.emit(J.Discontinuity, t);
    }
  }
  async _channelDetachLoop(e) {
    for (; ; ) {
      if (e.state === "failed") {
        this._logger.debug("RoomLifecycleManager._channelDetachLoop(); channel is failed, skipping detach");
        break;
      }
      try {
        await e.detach();
        break;
      } catch (r) {
        this._logger.error("RoomLifecycleManager._channelDetachLoop(); failed to detach channel during release", {
          error: r
        }), await new Promise((i) => setTimeout(i, 250));
      }
    }
  }
  _setStatus(e, t) {
    this._logger.debug("RoomLifecycleManager._setStatus(); updating room status", {
      oldStatus: this._roomLifecycle.status,
      newStatus: e,
      hasError: !!t
    }), this._roomLifecycle.setStatus({ status: e, error: t });
  }
  _releaseChannel() {
    this._channelManager.release(), this._setStatus(m.Released), this._logger.debug("RoomLifecycleManager._releaseChannel(); room released successfully");
  }
  /**
   * Returns whether there is currently an operation (attach/detach/release) in progress
   * @returns True if an operation is in progress, false otherwise.
   */
  _operationInProgress() {
    return this._mutex.isLocked();
  }
  testForceHasAttachedOnce(e) {
    this._logger.trace("RoomLifecycleManager.testForceHasAttachedOnce();", { firstAttach: e }), this._hasAttachedOnce = e;
  }
}
const pe = {
  /**
   * The default typing options for a chat room.
   */
  typing: {
    /**
     * The default time that a client will wait between sending one typing heartbeat and the next.
     *
     * Spec: CHA-T10.
     */
    heartbeatThrottleMs: 1e4
  },
  /**
   * The default occupancy options for a chat room.
   */
  occupancy: {
    /**
     * Whether to enable occupancy events.
     */
    enableEvents: !1
  },
  /**
   * The default presence options for the room.
   */
  presence: {
    enableEvents: !0
  },
  /**
   * The default options for messages.
   */
  messages: {
    rawMessageReactions: !1,
    defaultMessageReactionType: j.Distinct
  }
}, jn = (n) => new g.ErrorInfo(`unable to create room; invalid room configuration: ${n}`, d.InvalidArgument, 400), zn = (n) => {
  Fn(n.typing);
}, Fn = (n) => {
  if (n.heartbeatThrottleMs <= 0)
    throw jn("typing heartbeat interval must be greater than 0");
}, Bn = (n) => ({
  ...pe.typing,
  ...n?.typing
}), $n = (n) => ({
  ...pe.occupancy,
  ...n?.occupancy
}), Hn = (n) => ({
  ...pe.presence,
  ...n?.presence
}), Wn = (n) => ({
  ...pe.messages,
  ...n?.messages
}), Gn = (n, e) => ({
  typing: Bn(n),
  occupancy: $n(n),
  presence: Hn(n),
  messages: Wn(n),
  isReactClient: e
}), Mt = (n, e) => ({
  name: n,
  data: e,
  extras: {
    ephemeral: !0
  }
}), Vn = (n) => {
  const e = n.extras ? n.extras : {};
  return {
    ...n,
    extras: {
      ...e,
      ephemeral: !0
    }
  };
};
class Kn {
  constructor(e, t, r, i, c, h, u) {
    this.name = e, this.clientId = t, this.createdAt = r, this.isSelf = i, this.metadata = c, this.headers = h, this.userClaim = u, Object.freeze(this);
  }
}
const Qn = (n, e) => {
  const t = n, r = t.data?.name && typeof t.data.name == "string" ? t.data.name : "", i = t.clientId ?? "", c = t.timestamp ? new Date(t.timestamp) : /* @__PURE__ */ new Date(), h = se(n.extras);
  return new Kn(
    r,
    i,
    c,
    e ? e === i : !1,
    t.data?.metadata ?? {},
    h.headers ?? {},
    h.userClaim
  );
};
class Jn {
  /**
   * Constructs a new `DefaultRoomReactions` instance.
   * @param channel The Realtime channel instance.
   * @param connection The connection instance.
   * @param clientIdResolver The client ID resolver.
   * @param logger An instance of the Logger.
   */
  constructor(e, t, r, i) {
    this._emitter = new C(), this._forwarder = (h) => {
      const u = Qn(h, this._clientIdResolver.get());
      this._emitter.emit(Oe.Reaction, {
        type: Oe.Reaction,
        reaction: u
      });
    }, this._channel = e, this._connection = t, this._clientIdResolver = r, this._logger = i;
    const c = this._forwarder.bind(this);
    this._unsubscribeRoomReactionEvents = F(
      this._channel,
      [De.Reaction],
      c
    );
  }
  /**
   * @inheritDoc
   */
  async send(e) {
    this._logger.trace("RoomReactions.send();", e);
    const { name: t, metadata: r, headers: i } = e;
    if (!t)
      throw new g.ErrorInfo(
        "unable to send reaction; name not set and it is required",
        d.InvalidArgument,
        400
      );
    if (this._connection.state !== "connected")
      throw new g.ErrorInfo("unable to send reaction; not connected to Ably", d.Disconnected, 400);
    const c = {
      name: t,
      metadata: r ?? {}
    }, h = {
      name: De.Reaction,
      data: c,
      extras: {
        headers: i ?? {}
      }
    };
    return this._channel.publish(Vn(h));
  }
  /**
   * @inheritDoc
   */
  subscribe(e) {
    this._logger.trace("RoomReactions.subscribe();");
    const t = T(e);
    return this._emitter.on(t), {
      unsubscribe: () => {
        this._logger.trace("RoomReactions.unsubscribe();"), this._emitter.off(t);
      }
    };
  }
  /**
   * Disposes of the room reactions instance, removing all listeners and subscriptions.
   * This method should be called when the room is being released to ensure proper cleanup.
   * @internal
   */
  dispose() {
    this._unsubscribeRoomReactionEvents(), this._emitter.off();
  }
  /**
   * Checks if there are any listeners registered by users.
   * @internal
   * @returns true if there are listeners, false otherwise.
   */
  hasListeners() {
    return P(this._emitter);
  }
}
class Xn extends C {
  /**
   * Constructs a new `DefaultTyping` instance.
   * @param options The options for typing in the room.
   * @param connection The connection instance.
   * @param channel The channel for the room.
   * @param logger An instance of the Logger.
   */
  constructor(e, t, r, i) {
    super(), this._timeoutMs = 2e3, this._mutex = new Ut(), this._internalSubscribeToEvents = (c) => {
      const { name: h, clientId: u } = c;
      if (this._logger.trace("DefaultTyping._internalSubscribeToEvents(); received event", {
        name: h,
        clientId: u
      }), !u) {
        this._logger.error("DefaultTyping._internalSubscribeToEvents(); invalid clientId in received event", {
          inbound: c
        });
        return;
      }
      const _ = se(c.extras).userClaim;
      h === R.Started || h === R.Stopped ? this._updateCurrentlyTyping(u, h, _) : this._logger.warn("DefaultTyping._internalSubscribeToEvents(); unrecognized event", {
        name: h
      });
    }, this._channel = r, this._connection = t, this._heartbeatThrottleMs = e.heartbeatThrottleMs, this._currentlyTyping = /* @__PURE__ */ new Map(), this._logger = i, this._unsubscribeTypingEvents = F(
      this._channel,
      [R.Started, R.Stopped],
      this._internalSubscribeToEvents.bind(this)
    );
  }
  /**
   * Clears all typing states.
   * This includes clearing all timeouts and the currently typing map.
   */
  _clearAllTypingStates() {
    this._logger.debug("DefaultTyping._clearAllTypingStates(); clearing all typing states"), this._clearHeartbeatTimer(), this._clearCurrentlyTyping();
  }
  /**
   * Clears the heartbeat timer.
   */
  _clearHeartbeatTimer() {
    this._logger.trace("DefaultTyping._clearHeartbeatTimer(); clearing heartbeat timer"), this._heartbeatTimerId && (clearTimeout(this._heartbeatTimerId), this._heartbeatTimerId = void 0);
  }
  /**
   * Clears the currently typing store and removes all timeouts for associated clients.
   */
  _clearCurrentlyTyping() {
    this._logger.trace("DefaultTyping._clearCurrentlyTyping(); clearing current store and timeouts");
    for (const [, e] of this._currentlyTyping.entries())
      clearTimeout(e.timer);
    this._currentlyTyping.clear();
  }
  /**
   * CHA-T16
   * @inheritDoc
   */
  get current() {
    return this._logger.trace("DefaultTyping.current();"), new Set(this._currentlyTyping.keys());
  }
  /**
   * @inheritDoc
   */
  get currentTypers() {
    return this._logger.trace("DefaultTyping.currentTypers();"), this._buildCurrentTypers();
  }
  /**
   * @inheritDoc
   */
  get channel() {
    return this._channel;
  }
  /**
   * Start the heartbeat timer. This will expire after the configured interval.
   */
  _startHeartbeatTimer() {
    if (!this._heartbeatTimerId) {
      this._logger.trace("DefaultTyping.startHeartbeatTimer();");
      const e = this._heartbeatTimerId = setTimeout(() => {
        this._logger.debug("DefaultTyping.startHeartbeatTimer(); heartbeat timer expired"), e === this._heartbeatTimerId && (this._heartbeatTimerId = void 0);
      }, this._heartbeatThrottleMs);
    }
  }
  /**
   * @inheritDoc
   */
  async keystroke() {
    this._logger.trace("DefaultTyping.keystroke();"), this._mutex.cancel();
    try {
      await this._mutex.acquire();
    } catch (e) {
      if (e === de) {
        this._logger.debug("DefaultTyping.keystroke(); mutex was canceled by a later operation");
        return;
      }
      throw new g.ErrorInfo(
        "unable to send keystroke event; failed to enforce sequential execution of the operation",
        d.OperationSerializationFailed,
        500
      );
    }
    try {
      if (this._connection.state !== "connected")
        throw this._logger.error("DefaultTyping.keystroke(); connection is not connected", {
          status: this._connection.state
        }), new g.ErrorInfo(
          "unable to send typing keystroke event; disconnected from Ably",
          d.Disconnected,
          400
        );
      if (this._heartbeatTimerId) {
        this._logger.debug("DefaultTyping.keystroke(); no-op, already typing and heartbeat timer has not expired");
        return;
      }
      await this._channel.publish(Mt(R.Started)), this._startHeartbeatTimer(), this._logger.trace("DefaultTyping.keystroke(); starting timers");
    } finally {
      this._logger.trace("DefaultTyping.keystroke(); releasing mutex"), this._mutex.release();
    }
  }
  /**
   * @inheritDoc
   */
  async stop() {
    this._logger.trace("DefaultTyping.stop();"), this._mutex.cancel();
    try {
      await this._mutex.acquire();
    } catch (e) {
      if (e === de) {
        this._logger.debug("DefaultTyping.stop(); mutex was canceled by a later operation");
        return;
      }
      throw new g.ErrorInfo(
        "unable to send typing stop event; failed to enforce sequential execution of the operation",
        d.OperationSerializationFailed,
        500
      );
    }
    try {
      if (this._connection.state !== "connected")
        throw this._logger.error("DefaultTyping.stop(); connection is not connected", {
          status: this._connection.state
        }), new g.ErrorInfo(
          "unable to send typing stop event; disconnected from Ably",
          d.Disconnected,
          400
        );
      if (!this._heartbeatTimerId) {
        this._logger.debug("DefaultTyping.stop(); no-op, not currently typing");
        return;
      }
      await this._channel.publish(Mt(R.Stopped)), this._logger.trace("DefaultTyping.stop(); clearing timers"), clearTimeout(this._heartbeatTimerId), this._heartbeatTimerId = void 0;
    } finally {
      this._logger.trace("DefaultTyping.stop(); releasing mutex"), this._mutex.release();
    }
  }
  /**
   * @inheritDoc
   */
  subscribe(e) {
    this._logger.trace("DefaultTyping.subscribe();");
    const t = T(e);
    return this.on(t), {
      unsubscribe: () => {
        this._logger.trace("DefaultTyping.unsubscribe();"), this.off(t);
      }
    };
  }
  /**
   * @inheritDoc
   */
  // CHA-RL3h
  async dispose() {
    for (this._logger.trace("DefaultTyping.dispose();"); ; )
      try {
        this._mutex.cancel(), await this._mutex.acquire();
        break;
      } catch (e) {
        if (e === de)
          this._logger.debug("DefaultTyping.dispose(); mutex was canceled"), await new Promise((t) => setTimeout(t, 200)), this._logger.debug("DefaultTyping.dispose(); retrying mutex acquisition");
        else {
          this._logger.error("DefaultTyping.dispose(); failed to acquire mutex; could not complete resource disposal", {
            error: e
          });
          return;
        }
      }
    this._clearAllTypingStates(), this._unsubscribeTypingEvents(), this.off(), this._mutex.release();
  }
  /**
   * Update the currently typing users. This method is called when a typing event is received.
   * It will also acquire a mutex to ensure that the currentlyTyping state is updated safely.
   * @param clientId The client ID of the user.
   * @param event The typing event.
   * @param userClaim The user claim from the typing event, if any.
   */
  _updateCurrentlyTyping(e, t, r) {
    this._logger.trace("DefaultTyping._updateCurrentlyTyping();", { clientId: e, event: t }), t === R.Started ? this._handleTypingStart(e, r) : this._handleTypingStop(e, r);
  }
  /**
   * Builds an array of TypingMember objects from the current typing state.
   * @returns Array of {@link TypingMember} objects for users currently typing
   */
  _buildCurrentTypers() {
    return [...this._currentlyTyping.entries()].map(([e, t]) => ({
      clientId: e,
      userClaim: t.userClaim
    }));
  }
  /**
   * Starts a new inactivity timer for the client.
   * This timer will expire after the configured timeout,
   * which is the sum of the heartbeat interval and the inactivity timeout.
   * @param clientId The client ID for which to start the timer.
   * @returns The timeout ID for the new timer.
   */
  _startNewClientInactivityTimer(e) {
    this._logger.trace("DefaultTyping._startNewClientInactivityTimer(); starting new inactivity timer", {
      clientId: e
    });
    const t = setTimeout(() => {
      this._logger.trace("DefaultTyping._startNewClientInactivityTimer(); client typing timeout expired", {
        clientId: e
      });
      const r = this._currentlyTyping.get(e);
      if (r?.timer !== t) {
        this._logger.debug("DefaultTyping._startNewClientInactivityTimer(); timeout already cleared; ignoring", {
          clientId: e
        });
        return;
      }
      const i = r.userClaim;
      this._currentlyTyping.delete(e), this.emit(q.SetChanged, {
        type: q.SetChanged,
        currentlyTyping: new Set(this._currentlyTyping.keys()),
        currentTypers: this._buildCurrentTypers(),
        change: {
          clientId: e,
          type: R.Stopped,
          userClaim: i
        }
      });
    }, this._heartbeatThrottleMs + this._timeoutMs);
    return t;
  }
  /**
   * Handles logic for TypingEventType.Started, including starting a new timeout or resetting an existing one.
   * @param clientId The client ID that started typing.
   * @param userClaim The user claim from the typing event, if any.
   */
  _handleTypingStart(e, t) {
    this._logger.debug("DefaultTyping._handleTypingStart();", { clientId: e });
    const r = this._startNewClientInactivityTimer(e), i = this._currentlyTyping.get(e);
    this._currentlyTyping.set(e, { timer: r, userClaim: t }), i ? (this._logger.debug("DefaultTyping._handleTypingStart(); received heartbeat for currently typing client", {
      clientId: e
    }), clearTimeout(i.timer)) : (this._logger.debug("DefaultTyping._handleTypingStart(); new client started typing", {
      clientId: e
    }), this.emit(q.SetChanged, {
      type: q.SetChanged,
      currentlyTyping: new Set(this._currentlyTyping.keys()),
      currentTypers: this._buildCurrentTypers(),
      change: {
        clientId: e,
        type: R.Started,
        userClaim: t
      }
    }));
  }
  /**
   * Handles logic for TypingEventType.Stopped, including clearing the timeout for the client.
   * @param clientId The client ID that stopped typing.
   * @param userClaim The user claim from the stop event, if any.
   */
  _handleTypingStop(e, t) {
    const r = this._currentlyTyping.get(e);
    if (!r) {
      this._logger.trace(
        'DefaultTyping._handleTypingStop(); received "Stop" event for client not in currentlyTyping list',
        { clientId: e }
      );
      return;
    }
    this._logger.debug("DefaultTyping._handleTypingStop(); client stopped typing", { clientId: e }), clearTimeout(r.timer), this._currentlyTyping.delete(e), this.emit(q.SetChanged, {
      type: q.SetChanged,
      currentlyTyping: new Set(this._currentlyTyping.keys()),
      currentTypers: this._buildCurrentTypers(),
      change: {
        clientId: e,
        type: R.Stopped,
        userClaim: t
      }
    });
  }
  get heartbeatThrottleMs() {
    return this._heartbeatThrottleMs;
  }
  get hasHeartbeatTimer() {
    return !!this._heartbeatTimerId;
  }
}
class Yn {
  /**
   * Constructs a new Room instance.
   * @param name The unique identifier of the room.
   * @param nonce A random identifier for the room instance, useful in debugging and logging.
   * @param options The options for the room.
   * @param realtime An instance of the Ably Realtime client.
   * @param chatApi An instance of the ChatApi.
   * @param clientIdResolver An instance of the ClientIdResolver.
   * @param logger An instance of the Logger.
   */
  constructor(e, t, r, i, c, h, u) {
    zn(r), this._nonce = t, this._logger = u.withContext({ roomName: e, roomNonce: t }), this._logger.debug("Room();", { options: r }), this._name = e, this._options = r, this._chatApi = c, this._lifecycle = new kn(this._logger);
    const y = this._channelManager = this._getChannelManager(r, i, this._logger), _ = y.get();
    this._messages = new Cn(e, r.messages, _, this._chatApi, this._logger), this._presence = new Ct(_, this._logger, r), this._typing = new Xn(r.typing, i.connection, _, this._logger), this._reactions = new Jn(_, i.connection, h, this._logger), this._occupancy = new Tt(e, _, this._chatApi, this._logger, r), this._lifecycleManager = new qn(y, this._lifecycle, this._logger);
    let p = !1;
    this._finalizer = async () => {
      if (p) {
        this._logger.debug("Room.finalizer(); already finalized");
        return;
      }
      await this._lifecycleManager.release(), this._lifecycleManager.dispose(), this._messages.dispose(), this._presence.dispose(), this._reactions.dispose(), this._occupancy.dispose(), await this._typing.dispose(), this._lifecycle.dispose(), p = !0;
    };
  }
  /**
   * Gets the channel manager for the room, which handles merging channel options together and creating channels.
   * @param options The room options.
   * @param realtime  An instance of the Ably Realtime client.
   * @param logger An instance of the Logger.
   * @returns The channel manager instance.
   */
  _getChannelManager(e, t, r) {
    const i = new En(this._name, t, r, e.isReactClient);
    return i.mergeOptions(Tt.channelOptionMerger(e)), i.mergeOptions(Ct.channelOptionMerger(e)), i.mergeOptions(xt.channelOptionMerger(e)), i;
  }
  /**
   * @inheritdoc
   */
  get name() {
    return this._name;
  }
  /**
   * @inheritDoc
   */
  options() {
    return O(this._options);
  }
  /**
   * @inheritdoc
   */
  get messages() {
    return this._messages;
  }
  /**
   * @inheritdoc
   */
  get presence() {
    return this._presence;
  }
  /**
   * @inheritdoc
   */
  get reactions() {
    return this._reactions;
  }
  /**
   * @inheritdoc
   */
  get typing() {
    return this._typing;
  }
  /**
   * @inheritdoc
   */
  get occupancy() {
    return this._occupancy;
  }
  /**
   * @inheritdoc
   */
  get status() {
    return this._lifecycle.status;
  }
  /**
   * @inheritdoc
   */
  get error() {
    return this._lifecycle.error;
  }
  /**
   * @inheritdoc
   */
  onStatusChange(e) {
    return this._lifecycle.onChange(e);
  }
  /**
   * @inheritdoc
   */
  async attach() {
    return this._logger.trace("Room.attach();"), this._lifecycleManager.attach();
  }
  /**
   * @inheritdoc
   */
  async detach() {
    return this._logger.trace("Room.detach();"), this._lifecycleManager.detach();
  }
  /**
   * Releases resources associated with the room.
   * @returns A promise that resolves when the room is released.
   */
  async release() {
    return this._logger.trace("Room.release();"), this._finalizer();
  }
  /**
   * A random identifier for the room instance, useful in debugging and logging.
   * @returns The nonce.
   */
  get nonce() {
    return this._nonce;
  }
  /**
   * @internal
   * @returns The internal room lifecycle.
   */
  get lifecycle() {
    return this._lifecycle;
  }
  /**
   * @internal
   * @returns The room lifecycle manager.
   */
  get lifecycleManager() {
    return this._lifecycleManager;
  }
  /**
   * @inheritdoc
   */
  onDiscontinuity(e) {
    return this._logger.trace("Room.onDiscontinuity();"), this._lifecycleManager.onDiscontinuity(e);
  }
  /**
   * @inheritdoc
   */
  get channel() {
    return this._channelManager.get();
  }
}
class Zn {
  /**
   * Constructs a new Rooms instance.
   * @param realtime An instance of the Ably Realtime client.
   * @param clientIdResolver A resolver for the clientId.
   * @param logger An instance of the Logger.
   */
  constructor(e, t, r) {
    this._rooms = /* @__PURE__ */ new Map(), this._releasing = /* @__PURE__ */ new Map(), this._isReact = !1, this._disposed = !1, this._realtime = e, this._chatApi = new Mn(e, r), this._clientIdResolver = t, this._logger = r;
  }
  /**
   * @inheritDoc
   */
  async get(e, t) {
    this._logger.trace("Rooms.get();", { roomName: e }), this._ensureNotDisposed();
    const r = this._rooms.get(e);
    if (r)
      return this._handleExistingRoom(r, e, t);
    const i = this._releasing.get(e), c = It();
    return i ? this._waitForReleaseAndCreateRoom(e, c, t, i) : this._createNewRoom(e, c, t);
  }
  /**
   * @inheritDoc
   */
  async release(e) {
    this._logger.trace("Rooms.release();", { roomName: e });
    const t = this._rooms.get(e), r = this._releasing.get(e);
    return t ? r ? this._handleConcurrentRelease(e, t, r) : this._performRoomRelease(e, t) : this._handleNonExistentRoomRelease(e, r);
  }
  /**
   * Disposes all rooms that are currently in the rooms map and waits for any ongoing release operations to complete.
   * This method releases all rooms concurrently, waits for any in-flight releases to finish, and clears the rooms map.
   * After this method resolves, all rooms will have been fully released and cleaned up.
   * @internal
   * @returns A promise that resolves when all rooms have been released.
   */
  async dispose() {
    this._logger.trace("Rooms.dispose();"), this._disposed = !0;
    const e = [...this._rooms.keys()];
    if (e.length === 0) {
      this._logger.debug("Rooms.dispose(); no rooms to release");
      return;
    }
    const t = e.map(async (c) => this.release(c)), r = [...this._releasing.values()], i = [...t, ...r];
    this._logger.debug("Rooms.dispose(); releasing rooms", { roomCount: e.length, roomNames: e }), await Promise.all(i), this._logger.debug("Rooms.dispose(); all rooms released successfully");
  }
  /**
   * @inheritDoc
   */
  get count() {
    return this._rooms.size;
  }
  /**
   * Ensures the rooms instance has not been disposed.
   */
  _ensureNotDisposed() {
    if (this._disposed)
      throw new g.ErrorInfo("unable to get room; rooms instance has been disposed", d.ResourceDisposed, 400);
  }
  /**
   * Handles the case where a room already exists.
   * @param existingRoom The existing room entry in the map.
   * @param name The unique identifier of the room.
   * @param options The options for the room.
   * @returns A promise that resolves to the existing room.
   */
  async _handleExistingRoom(e, t, r) {
    if (!Y(e.options, r))
      throw new g.ErrorInfo(
        "unable to get room; room already exists with different options",
        d.RoomExistsWithDifferentOptions,
        400
      );
    return this._logger.debug("Rooms.get(); returning existing room", {
      roomName: t,
      nonce: e.nonce,
      options: r
    }), await e.promise;
  }
  /**
   * Creates a new room when no existing room or ongoing release exists.
   * @param name The unique identifier of the room.
   * @param nonce A random, internal identifier useful for debugging and logging.
   * @param options The options for the room.
   * @returns A new room object.
   */
  _createNewRoom(e, t, r) {
    const i = this._makeRoom(e, t, r), c = {
      promise: Promise.resolve(i),
      nonce: t,
      options: r
    };
    return this._rooms.set(e, c), this._logger.debug("Rooms.get(); returning new room", { roomName: e, nonce: i.nonce }), i;
  }
  /**
   * Waits for an ongoing release to complete, then creates a new room.
   * @param name The unique identifier of the room.
   * @param nonce A random, internal identifier useful for debugging and logging.
   * @param options The options for the room.
   * @param ongoingRelease The promise of an ongoing release operation.
   * @returns A promise that resolves to a room.
   */
  async _waitForReleaseAndCreateRoom(e, t, r, i) {
    const c = new AbortController(), h = this._createAbortableRoomPromise(e, t, r, i, c);
    return this._rooms.set(e, {
      promise: h,
      options: r,
      nonce: t,
      abort: c
    }), this._logger.debug("Rooms.get(); creating new promise dependent on previous release", { roomName: e }), await h;
  }
  /**
   * Creates a promise that can be aborted if the room is released before completion.
   * @param name The unique identifier of the room.
   * @param nonce A random, internal identifier useful for debugging and logging.
   * @param options The options for the room.
   * @param ongoingRelease A promise that resolves when the previous release operation is complete.
   * @param abortController An AbortController to manage the abort signal.
   * @returns A promise that resolves to a new room or rejects if the operation is aborted.
   */
  async _createAbortableRoomPromise(e, t, r, i, c) {
    const h = new Promise((y, _) => {
      const p = () => {
        this._logger.debug("Rooms.get(); aborted before init", { roomName: e }), _(
          new g.ErrorInfo(
            "unable to get room; room released before operation could complete",
            d.RoomReleasedBeforeOperationCompleted,
            400
          )
        );
      };
      c.signal.addEventListener("abort", p, { once: !0 });
    });
    return await Promise.race([i, h]), this._logger.debug("Rooms.get(); releasing finished", { roomName: e }), this._makeRoom(e, t, r);
  }
  /**
   * Handles release when no room exists.
   * @param name The unique identifier of the room.
   * @param ongoingRelease An ongoing release promise, if any.
   * @returns A promise that resolves when the release operation is complete.
   */
  async _handleNonExistentRoomRelease(e, t) {
    if (t) {
      this._logger.debug("Rooms.release(); waiting for previous release call", { roomName: e }), await t;
      return;
    }
    this._logger.debug("Rooms.release(); room does not exist", { roomName: e });
  }
  /**
   * Handles release when there's already a release in progress.
   * @param name The unique identifier of the room.
   * @param existingRoom The existing room entry in the map.
   * @param ongoingRelease The promise of an ongoing release operation.
   */
  async _handleConcurrentRelease(e, t, r) {
    t.abort && (this._logger.debug("Rooms.release(); aborting get call", {
      roomName: e,
      existingNonce: t.nonce
    }), t.abort.abort(), this._rooms.delete(e)), await r;
  }
  /**
   * Performs the actual room release operation.
   * @param name The unique identifier of the room.
   * @param existingRoom The existing room entry in the map.
   */
  async _performRoomRelease(e, t) {
    this._rooms.delete(e);
    const r = this._executeRoomRelease(e, t);
    this._releasing.set(e, r), this._logger.debug("Rooms.release(); creating new release promise", {
      roomName: e,
      nonce: t.nonce
    }), await r;
  }
  /**
   * Executes the room release and cleanup.
   * @param name The unique identifier of the room.
   * @param existingRoom The existing room entry in the map.
   */
  async _executeRoomRelease(e, t) {
    const r = await t.promise;
    this._logger.debug("Rooms.release(); releasing room", { roomName: e, nonce: t.nonce }), await r.release(), this._logger.debug("Rooms.release(); room released", { roomName: e, nonce: t.nonce }), this._releasing.delete(e);
  }
  /**
   * makes a new room object
   * @param name The unique identifier of the room.
   * @param nonce A random, internal identifier useful for debugging and logging.
   * @param options The options for the room.
   * @returns DefaultRoom A new room object.
   */
  _makeRoom(e, t, r) {
    return new Yn(
      e,
      t,
      Gn(r, this._isReact),
      this._realtime,
      this._chatApi,
      this._clientIdResolver,
      this._logger
    );
  }
  /**
   * Sets react JS mode.
   */
  useReact() {
    this._logger.trace("Rooms.useReact();"), this._isReact = !0;
  }
}
class tr {
  /**
   * Creates a new ChatClient instance for interacting with Ably Chat.
   *
   * The ChatClient is the main entry point for the Ably Chat SDK. It requires a Realtime client
   * and provides access to chat rooms through the rooms property.
   *
   * **Important**: The Ably Realtime client must have a clientId set. This identifies
   * the user in chat rooms and is required for all chat operations.
   *
   * **NOTE**: You can provide optional overrides to the {@link ChatClient}, these will be merged
   * with the default options. See {@link ChatClientOptions} for the available options.
   * @param realtime - An initialized Ably Realtime client with a configured clientId
   * @param clientOptions - Optional configuration for the chat client
   * @example
   * ```typescript
   * import * as Ably from 'ably';
   * import { ChatClient, LogLevel } from '@ably/chat';
   *
   * // Preferred in production: Use auth URL that returns a JWT
   * const realtimeClientWithJWT = new Ably.Realtime({
   *   authUrl: '/api/ably-auth', // Your server endpoint that returns a JWT with clientId
   *   authMethod: 'POST'
   * });
   *
   * const chatClient = new ChatClient(realtimeClientWithJWT)
   *```
   * @example
   *```typescript
   * // Alternative for development and server-side operations: Set clientId directly (requires API key)
   * const realtimeClientWithKey = new Ably.Realtime({
   *   key: 'your-ably-api-key',
   *   clientId: 'user-123'
   * });
   *
   * const chatClient = new ChatClient(realtimeClientWithKey)
   * ```
   * @example
   * ```typescript
   * const realtimeClient = new Ably.Realtime({
   *   authUrl: '/api/ably-auth',
   *   authMethod: 'POST'
   * });
   *
   * // With custom logging configuration: Defaults to LogLevel.Info and console logging
   * const chatClientWithLogging = new ChatClient(realtimeClient, {
   *   logLevel: LogLevel.Debug,
   *   logHandler: (message, level, context) => {
   *     // Send to your logging service
   *     yourLoggerInstance.log({
   *       level,
   *       message,
   *       context,
   *       timestamp: new Date()
   *     });
   *   }
   * });
   * ```
   */
  constructor(e, t) {
    this._realtime = e, this._clientOptions = gn(t), this._nonce = It(), this._logger = ln(this._clientOptions).withContext({
      chatClientNonce: this._nonce
    }), this._connection = new fn(e, this._logger), this._clientIdResolver = new cn(e, this._logger), this._rooms = new Zn(e, this._clientIdResolver, this._logger), this._addAgent("chat-js"), this._logger.trace(`ably chat client version ${_e}; initialized`);
  }
  /**
   * Provides access to the rooms instance for creating and managing chat rooms.
   * @returns The Rooms instance for managing chat rooms
   * @example
   * ```typescript
   * const chatClient: ChatClient; // existing ChatClient instance
   *
   * // Get a room with default options
   * const room = await chatClient.rooms.get('general-chat');
   *
   * // Get a room with custom options (merges with defaults)
   * const configuredRoom = await chatClient.rooms.get('team-chat', {
   *   typing: { heartbeatThrottleMs: 1000 }
   * });
   *
   * // Release a room when done
   * await chatClient.rooms.release('general-chat');
   * ```
   */
  get rooms() {
    return this._rooms;
  }
  /**
   * Provides access to the underlying connection to Ably for monitoring connectivity.
   * @returns The Connection instance
   * @example
   * ```typescript
   * const chatClient: ChatClient; // existing ChatClient instance
   *
   * // Check current connection status
   * console.log('Status:', chatClient.connection.status);
   * console.log('Error:', chatClient.connection.error);
   *
   * // Monitor connection changes
   * const { off } = chatClient.connection.onStatusChange((change) => {
   *   console.log(`Connection: ${change.previous} -> ${change.current}`);
   * });
   * ```
   */
  get connection() {
    return this._connection;
  }
  /**
   * Returns the clientId of the current client, if known.
   *
   * **Important** When using an Ably key for authentication, this value is determined immediately. If using a token,
   * the clientId is not known until the client has successfully connected to and authenticated with
   * the server. Use the `chatClient.connection.status` to check the connection status.
   * @returns The clientId, or undefined if unknown.
   */
  get clientId() {
    return this._realtime.auth.clientId;
  }
  /**
   * Provides direct access to the underlying Ably Realtime client.
   *
   * Use this for advanced scenarios requiring direct Ably access. Most chat
   * operations should use the high-level chat SDK methods instead.
   *
   * **Note**: Directly interacting with the Ably Realtime client can lead to
   * unexpected behavior.
   * @returns The underlying Ably Realtime client instance
   */
  get realtime() {
    return this._realtime;
  }
  /**
   * The configuration options used to initialize the chat client.
   * @returns The resolved client options including defaults
   */
  get clientOptions() {
    return this._clientOptions;
  }
  /**
   * Returns the logger instance for the client.
   * @internal
   * @returns The logger instance.
   */
  get logger() {
    return this._logger;
  }
  /**
   * Adds additional agent information to the client.
   * Used internally to add React-specific agent information.
   * @internal
   */
  addReactAgent() {
    this._addAgent("chat-react"), this._rooms.useReact();
  }
  /**
   * Adds additional agent information to the client.
   * This is used internally to add a specific agent with a version.
   * @param agent - The agent to add.
   * @param version - The version of the agent, defaults to the current client version.
   * @internal
   */
  addAgentWithVersion(e, t) {
    this._addAgent(e, t), this._logger.trace(`Added agent ${e} with version ${t}`);
  }
  /**
   * Disposes of the ChatClient instance and releases all resources.
   *
   * Releases all chat rooms, removes event listeners, and cleans up connections.
   * After calling dispose, the ChatClient instance is no longer usable. This should
   * be called when you're completely done with the chat functionality.
   *
   * **Note**: This will release ALL rooms managed by this ChatClient and the ChatClient cannot be reused after disposal.
   * @returns Promise that resolves when all resources are released
   * @example
   * ```typescript
   * import * as Ably from 'ably';
   * import { ChatClient } from '@ably/chat';
   *
   * const chatClient: ChatClient; // existing ChatClient instance
   *
   * // Use the chat client
   * const roomOne = await chatClient.rooms.get('general-chat');
   * const roomTwo = await chatClient.rooms.get('random-chat');
   *
   * // ... chat operations ...
   *
   * // Clean up when completely done
   * try {
   *   await chatClient.dispose();
   *   console.log('Chat client disposed successfully');
   * } catch (error) {
   *   console.error('Failed to dispose chat client:', error);
   * }
   *
   * ```
   */
  async dispose() {
    this._logger.trace("ChatClient.dispose();"), await this._rooms.dispose(), this._connection.dispose(), this._logger.debug("ChatClient.dispose(); client disposed successfully");
  }
  /**
   * Sets the agent string for the client.
   * @param agent - The agent to add.
   * @param version - The version of the agent, defaults to the current client version.
   * @internal
   */
  _addAgent(e, t) {
    const r = this._realtime;
    r.options.agents = { ...r.options.agents ?? r.options.agents, [e]: t ?? _e };
  }
}
export {
  tr as ChatClient,
  L as ChatMessageAction,
  x as ChatMessageEventType,
  pn as ConnectionStatus,
  d as ErrorCode,
  At as LogLevel,
  V as MessageReactionRawEventType,
  Z as MessageReactionSummaryEventType,
  j as MessageReactionType,
  Ee as OccupancyEventType,
  xe as OrderBy,
  mn as PresenceEventType,
  J as RoomEventType,
  m as RoomStatus,
  R as TypingEventType,
  q as TypingSetEventType,
  er as errorInfoIs
};
//# sourceMappingURL=ably-chat.js.map
